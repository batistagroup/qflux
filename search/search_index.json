{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the QFlux Documentation","text":"<p>This is a Python package containing various protocols for performing quantum dynamics simulations with quantum devices. Each submodule contains object-oriented implementations for these protocols as demonstrated in our publication, as well as comprehensive tutorial notebooks designed to help users understand, implement and build upon various simulation techniques for studying quantum dynamics using quantum computer frameworks. Each tutorial is provided in Python, using Jupyter Notebooks to offer detailed explanations in both markdown and code comments.</p>"},{"location":"#installation","title":"Installation","text":"<p>This project uses <code>uv</code> for fast and reliable Python package management. To set up your development environment:</p> <pre><code># Create and activate a virtual environment\nuv venv\nsource .venv/bin/activate\n\n# Install the package and all development dependencies\nuv pip install -e \".[dev]\"\n# Initiate pre-commit checks\npre-commit install\n</code></pre> <p>This will install all necessary dependencies, including development tools like pre-commit hooks, testing frameworks, and documentation generators.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>.\n\u251c\u2500\u2500 data/           # Data files and resources\n\u251c\u2500\u2500 docs/           # Documentation files (MkDocs)\n\u251c\u2500\u2500 scripts/        # Utility and automation scripts\n\u251c\u2500\u2500 src/            # Source code\n\u2502   \u2514\u2500\u2500 qflux/\n\u251c\u2500\u2500 tests/          # Test files\n\u251c\u2500\u2500 .github/        # GitHub Actions workflows\n\u251c\u2500\u2500 mkdocs.yml      # MkDocs configuration\n\u251c\u2500\u2500 pyproject.toml  # Project dependencies and settings\n\u2514\u2500\u2500 .pre-commit-config.yaml  # Pre-commit hooks configuration\n</code></pre>"},{"location":"#development-setup","title":"Development Setup","text":""},{"location":"#documentation","title":"Documentation","text":"<p>This project uses MkDocs with the Material theme for documentation. To work with the documentation locally:</p> <ol> <li>Make sure you have all development dependencies installed</li> <li>Run the documentation server:</li> </ol> <pre><code>mkdocs serve\n</code></pre> <ol> <li>Open your browser and navigate to <code>http://127.0.0.1:8000</code></li> </ol> <p>The documentation will automatically reload when you make changes to the markdown files.</p>"},{"location":"#code-quality-tools","title":"Code Quality Tools","text":"<p>We use pre-commit hooks to ensure code quality and consistency. The following tools are configured in <code>.pre-commit-config.yaml</code>:</p> <ul> <li>Ruff: A fast Python linter and formatter</li> <li>Runs linting checks with auto-fix capability</li> <li>Handles code formatting</li> </ul> <p>After installing the development dependencies (as described in the Installation section), enable the pre-commit hooks by running:</p> <pre><code>pre-commit install\n</code></pre> <p>Now the hooks will run automatically on every commit, ensuring code quality and consistency.</p>"},{"location":"#managing-dependencies","title":"Managing Dependencies","text":"<p>This project uses <code>uv</code> for fast and reliable dependency management. Here's how to manage your dependencies:</p>"},{"location":"#adding-new-dependencies","title":"Adding New Dependencies","text":"<p>To add a new package dependency:</p> <pre><code>uv add package_name\n# Add a development dependency\nuv add --dev package_name\n</code></pre> <p>This will:</p> <ol> <li>Install the package in your virtual environment</li> <li>Update your <code>pyproject.toml</code> with the new dependency</li> <li>Update the <code>uv.lock</code> file with exact versions</li> </ol>"},{"location":"#synchronizing-dependencies","title":"Synchronizing Dependencies","text":"<p>If you pull changes that include new dependencies or switch branches, synchronize your environment:</p> <pre><code>uv sync\n</code></pre> <p>This ensures your virtual environment exactly matches the dependencies specified in the lock file, removing any packages you don't need and installing any that are missing.</p>"},{"location":"#writing-documentation","title":"Writing Documentation","text":"<p>This project follows a structured approach to documentation. Each module should have its own markdown file in the <code>docs/batistatemplate/</code> directory. Documentation files might include:</p> <ol> <li>Overview: A brief description of the module's purpose and key features</li> <li>Concepts: Explanation of important concepts and design decisions</li> <li>Examples: Code examples showing common usage patterns</li> <li>Source Code: Auto-generated documentation from source code annotations</li> </ol>"},{"location":"CONTRIBUTING/","title":"Welcome to the QFlux Contributing Guide!","text":"<p>Thank you for taking the time to contribute to the QFlux package. Your help improves the software and expands its utility for the scientific community.</p> <p>This guide contains an overview of how to open issues, make code or documentation changes, and contribute via pull requests (PRs).</p>"},{"location":"CONTRIBUTING/#new-contributor-guide","title":"New Contributor Guide","text":"<p>If you're new to open-source or QFlux, welcome! You're encouraged to start by:</p> <ul> <li>Reading existing issues.</li> <li>Examining existing example notebooks under <code>demos/</code>.</li> <li>Looking at the <code>good first issue</code> or <code>help wanted</code> tags.</li> <li>Exploring the source code under <code>src/qflux</code>.</li> <li>Reviewing documentation in the <code>docs/</code> folder (built with MkDocs).</li> </ul>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":"<p>The general procedure for contributing to <code>QFlux</code> is: </p> <ol> <li>Clone the repository.</li> <li>Install dependencies.</li> <li>Create a branch.</li> <li>Add your edits/modifications.</li> <li>Create a pull request.</li> </ol>"},{"location":"CONTRIBUTING/#clone-the-repository","title":"Clone the repository","text":"<pre><code>git clone git@github.com:batistagroup/qflux.git\ncd qflux\n</code></pre>"},{"location":"CONTRIBUTING/#requirements","title":"Requirements","text":"<p>QFlux uses uv for dependency management. You will need:</p> <ul> <li>Python \u22653.10</li> <li>uv: Install with <code>pip install uv</code></li> <li>mkdocs for documentation</li> <li>mkdocs-material documentation theme</li> </ul> <p>All dependencies can be installed with the following steps (assuming you have already cloned the github repository and are within the main <code>qflux</code> directory): </p> <ol> <li>Install <code>uv</code>:</li> </ol> <pre><code>pip install uv\n</code></pre> <ol> <li>Create a virtual environment:</li> </ol> <pre><code>uv venv\n</code></pre> <ol> <li>Activate the virtual environment:</li> </ol> <pre><code>source .venv/bin/activate\n</code></pre> <ol> <li>Install dependencies, including those necessary for development:</li> </ol> <pre><code>uv pip install -e \".[dev]\"\n</code></pre> <p>You should now have a proper environment with all necessary dependencies! </p>"},{"location":"CONTRIBUTING/#project-structure","title":"Project structure","text":"<pre><code>qflux/\n\u251c\u2500\u2500 src/           # Core package source code, split according to subdomain (e.g., src/qflux)\n\u251c\u2500\u2500 data/          # Input/output data files for examples\n\u251c\u2500\u2500 docs/          # Markdown documentation for use with MkDocs\n\u251c\u2500\u2500 tests/         # Unit and integration tests\n\u251c\u2500\u2500 pyproject.toml # Project configuration with uv and build info\n</code></pre>"},{"location":"CONTRIBUTING/#issues","title":"Issues","text":""},{"location":"CONTRIBUTING/#create-an-issue","title":"Create an Issue","text":"<ol> <li>Go to the Issues tab.</li> <li>Use an appropriate template (e.g., bug, feature request, or question).</li> <li>Be concise and clear.</li> <li>Link to relevant code lines/commit if applicable.</li> </ol>"},{"location":"CONTRIBUTING/#solve-an-issue","title":"Solve an Issue","text":"<ul> <li>If you'd like to address an open issue, comment on it to indicate you're working on it.</li> <li>Fork the repository and follow the development workflow below.</li> </ul>"},{"location":"CONTRIBUTING/#make-changes","title":"Make Changes","text":"<p>All changes and additions to the QFlux code and documentation will follow the MIT License for the repository.</p>"},{"location":"CONTRIBUTING/#new-feature","title":"New Feature","text":"<ol> <li>Create a feature branch:</li> </ol> <p><pre><code>git checkout -b feat/qumode_dynamics\n</code></pre> 2. Implement your code under a relevant submodule of <code>src/qflux/</code>. 3. Add or update relevant tests in <code>tests/</code>. 4. Add or update relevant <code>[package_name]</code> dependencies through <code>uv</code>:</p> <p><pre><code>uv add package_name\n</code></pre> 5. Ensure the test suite passes:</p> <pre><code>uv pip install -r requirements-dev.txt\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#documentation-updates","title":"Documentation Updates","text":"<p>In this section, we will provide a general workflow for updating the documentation. We will first emphasize an important consideration prior to editing the docs. You should navigate to the directory for the module that you want to edit the documentation for. In order to determine the \"routing\" for these markdown files, you should consult the <code>mkdocs</code> configuration file in the top-level <code>qflux/</code> directory, named <code>mkdocs.yml</code>. In this file, you'll see a <code>nav:</code> section which  specifies the pages/routing for the documentation website. Individual pages are specified as key-value pairs where the key specifies the page title and the  value specifies the corresponding markdown file that the page is constructed from. </p> <ol> <li>Make a docs-related branch:</li> </ol> <p><pre><code>git checkout -b docs/pII_open_systems_spinchain\n</code></pre> 2. Edit the relevant markdown file in the <code>docs/</code> directory. Within the <code>docs/</code> directory, we are only concerned with the <code>docs/qflux/</code>, which contains separate directories for each module, as well as a global <code>images/</code> directory. </p> <p><pre><code>vim docs/qflux/Open_Systems/spin_chain.md\n</code></pre> 3. Preview the documentation to ensure all markdown is correctly rendered within <code>mkdocs</code>. You can create a live preview server to see your changes as you edit by running:</p> <p><pre><code>mkdocs serve\n</code></pre> 4. If a new page, ensure it is added to the navigation section of <code>qflux/mkdocs.yml</code>:    <pre><code>nav: # Note: All paths must be relative to the docs dir\n  - Open Systems:\n    - Spin Chain Demo: 'qflux/Open_Systems/spinchainOpen.md'\n</code></pre> 5. Commit your changes:</p> <pre><code>git add docs/qflux/Open_Systems/spin_chain.md\ngit commit -m 'DOCS: Added docs on the spin chain example with Lindblad'\ngit push\n</code></pre> <p>\ud83d\udccc All documentation should be concise and not a copy-paste of manuscripts or tutorials. Use clear markdown formatting. For ease of editing, you can use your favorite markdown editor, IDE, or Jupyter Notebooks to write your initial markdown and then refine/ensure everything renders properly by using your favorite text-editor with the live interactive preview server created via <code>mkdocs serve</code>.</p>"},{"location":"CONTRIBUTING/#commiting-the-update","title":"Commiting the Update","text":"<p>Follow conventional commit guidelines:</p> <ul> <li><code>FEAT:</code> for new features</li> <li><code>FIX:</code> for bug fixes</li> <li><code>DOCS:</code> for documentation</li> <li><code>TEST:</code> for testing additions</li> <li><code>REFACTOR:</code> for code improvements</li> </ul> <p>Example:</p> <pre><code>git commit -m \"FEAT: Add Lindblad trajectory sampling module\"\n</code></pre>"},{"location":"CONTRIBUTING/#pull-request","title":"Pull Request","text":"<ol> <li>Push your feature branch:</li> </ol> <p><pre><code>git push origin feat/qumode_dynamics\n</code></pre> 2. Open a PR against the <code>main</code> branch via GitHub. 3. Provide a meaningful title and description. 4. Link related issues using keywords like <code>Closes #42</code>.</p>"},{"location":"CONTRIBUTING/#merging-a-pull-request","title":"Merging a Pull Request","text":"<ul> <li>All PRs should be reviewed and approved by at least one maintainer.</li> <li>Ensure the CI (tests + docs build) passes.</li> </ul>"},{"location":"CONTRIBUTING/#keeping-your-fork-updated","title":"Keeping Your Fork Updated","text":"<pre><code>git remote add upstream https://github.com/batistagroup/qflux.git\ngit pull upstream main\ngit push origin main\n</code></pre> <p>Thank you again for contributing! The QFlux development team appreciates your support.</p>"},{"location":"qflux/Closed_Systems/","title":"Closed Systems Documentation and User Guide","text":"<p>This section includes documentation and tutorials focused on illustrating the usage and versatility of the <code>qflux.closed_systems</code> module. </p>"},{"location":"qflux/Closed_Systems/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>closed_systems</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/Closed_Systems/#examples-and-introductory-concepts","title":"Examples and Introductory Concepts","text":"<p>Before we look at doing Quantum Dynamics on a quantum computer, we'll start out by looking at some ways that we can do quantum dynamics on a classical computer! This is an important step as it will familiarize you with the general ingredients of a quantum dynamics simulation and will also provide us with a means of validating the results obtained from a quantum computer.</p> <ul> <li>Anatomy of a Dynamics Simulation: Advanced Use Cases</li> <li>Example: Quantum Harmonic Oscillator</li> <li>Example: Adenine-Thymine Base Pair</li> <li>Example: Spin Chain</li> <li>Example: Dynamics for an Arbitrary Hamiltonian</li> <li>API Documentation</li> </ul>"},{"location":"qflux/Closed_Systems/AT_basepair/","title":"Simulation of Proton Transfer Dynamics in Adenine-Thymine Base Pair","text":"<p>In this section, we will compute the dynamics for the proton transfer in an Adenine-Thymine Base Pair as it would be implemented on a qubit-based quantum computer. We will model the Adenine-Thymine base pair following this paper. A cartoon schematic of our model is shown here:</p> <p></p>"},{"location":"qflux/Closed_Systems/AT_basepair/#setting-up-the-simulation","title":"Setting Up The Simulation","text":"<p>We have included the Adenine-Thymine base pair potential as a default quartic potential in <code>qflux</code>. It can be implemented with the following code: </p> <pre><code>from qflux.closed_systems.utils import get_proton_mass\nfrom qflux.closed_systems import DynamicsCS\n\nx0 = 1.9592 # x_0 scaling factor\nomega = 0.00436 # frequency corresponding to right well from V''(x)\nproton_mass = get_proton_mass() # Proton mass in a.u.\n\n# Instantiate our class with 128 grid points, initial displacement, mass of proton, and frequency\ndw_dyn_obj = DynamicsCS(n_basis=128, xo=1.5*x0, mass=proton_mass, omega=omega)\n\n# Define our coordinate grid range\ndw_dyn_obj.set_coordinate_operators(x_min=-4.0, x_max=4.0)\n# Initialize operators\ndw_dyn_obj.initialize_operators()\n# Construct initial state\ndw_dyn_obj.set_initial_state(wfn_omega=omega)\n\n# Define the propagation time\ntotal_time = convert_fs_to_au(30.0)\nN_steps = 3000\ndw_dyn_obj.set_propagation_time(total_time, N_steps)\n\n# Set our hamiltonian as a quartic potential\ndw_dyn_obj.set_hamiltonian(potential_type='quartic')\n# Propagate\ndw_dyn_obj.propagate_qSOFT()\ndw_dyn_obj.propagate_SOFT()\ndw_dyn_obj.propagate_qt()\n</code></pre> <p>We can check the initial state by plotting on the potential: </p> <pre><code>import matplotlib.pyplot as plt\nfig, ax = plt.subplots()\nax.plot(dw_dyn_obj.x_grid, dw_dyn_obj._PE_grid + 0.008 , '-', color='black', label='A-T Basepair Potential')\nax.plot(dw_dyn_obj.x_grid, np.real(0.04*dw_dyn_obj.psio_grid.conj()*dw_dyn_obj.psio_grid), '--', color='red', label='Initial Coherent State')\nax.plot(dw_dyn_obj.x_grid, np.real(0.04*dw_dyn_obj.dynamics_results_qSOFT[0].conj()*\n                                   dw_dyn_obj.dynamics_results_qSOFT[0])/dw_dyn_obj.dx,\n        '--o', markevery=3, color='dodgerblue', label='Initial Qubit State')\nax.axhline(0, lw=0.5, color='black', alpha=1.0)\nax.axvline(-dw_dyn_obj.x0, lw=0.5, color='black', alpha=0.5)\nax.axvline(dw_dyn_obj.x0, lw=0.5, color='black', alpha=0.5)\nax.axvline(dw_dyn_obj.x0*1.5, lw=0.5, color='red', alpha=0.5)\nax.set_xlabel('x, Bohr',fontsize=18)\nax.set_ylabel('Energy, Hartree',fontsize=18)We i\nax.tick_params(labelsize=16, grid_alpha=0.5)\nplt.ylim(-0.03,0.07)\nplt.legend(fontsize=14,loc='upper center')\n</code></pre> <p>Which should produce a plot like this: </p> <p></p> <p>And we can also visualize with the final propagated state: </p> <pre><code>from scipy.interpolate import interp1d\nimport numpy as np \n\nx_1024 = np.linspace(dw_dyn_obj.x_grid[0], dw_dyn_obj.x_grid[-1], 1024)\nf_interp = interp1d(dw_dyn_obj.x_grid, dw_dyn_obj.dynamics_results_grid[-1], kind='cubic')\nfq_interp = interp1d(dw_dyn_obj.x_grid, dw_dyn_obj.dynamics_results_qSOFT[-1], kind='cubic')\nrho_interp = f_interp(x_1024)\nrho_q_interp = fq_interp(x_1024)\n\nfig, ax = plt.subplots()\nax.plot(dw_dyn_obj.x_grid, dw_dyn_obj._PE_grid + 0.008,\n        '-',color='black',label='A-T Basepair Potential', lw=3)\nax.plot(dw_dyn_obj.x_grid, 0.04*np.real(dw_dyn_obj.psio_grid.conj()*dw_dyn_obj.psio_grid),\n        '-',color='crimson',label='Initial Coherent State', lw=1.8)\nax.plot(dw_dyn_obj.x_grid, np.real(0.04*dw_dyn_obj.dynamics_results_qSOFT[0].conj()*\n                                   dw_dyn_obj.dynamics_results_qSOFT[0])/dw_dyn_obj.dx,\n        'o', markevery=3, color='crimson', label='Initial Qubit State')\n\nax.plot(x_1024, 0.04*np.real(rho_interp.conj()*rho_interp),'-',color='dodgerblue', \n        label=f'State at t = {convert_au_to_fs(total_time)} fs', lw=1.8)\nax.plot(x_1024, 0.04*np.real(rho_q_interp.conj()*rho_q_interp)/dw_dyn_obj.dx,'o',color='dodgerblue', \n        label=f'Qubit State at t = {convert_au_to_fs(total_time)} fs', lw=0, markevery=3)\n\nax.axhline(0, lw=0.5, color='black', alpha=1.0)\nax.set_xlabel('$x$, Bohr',fontsize=18)\nax.set_ylabel('Energy, Hartree',fontsize=18)\nax.tick_params(labelsize=16, grid_alpha=0.5)\nplt.ylim(-0.03,0.07)\nplt.xlim(-4, 4)\nplt.legend(fontsize=14,loc='upper center')\n</code></pre> <p></p> <p>And we can also look at the expectation value of the position as a function of time: </p> <pre><code>from qflux.closed_systems.utils import calculate_expectation_values, convert_au_to_fs\n\navxgrid = calculate_expectation_values(dw_dyn_obj.dynamics_results_grid, dw_dyn_obj.x_grid)\nqb_x = calculate_expectation_values(dw_dyn_obj.dynamics_results_qSOFT, dw_dyn_obj.x_grid, dx=1)\n\nfig, ax = plt.subplots()\nax.plot(dw_dyn_obj.tlist*convert_au_to_fs(1.), avxgrid, '-', color='dodgerblue',label=r'SOFT')\nax.plot(dw_dyn_obj.tlist*convert_au_to_fs(1.), qb_x, 'o', markevery=50, \n        color='dodgerblue',label=r'qSOFT', lw=0, fillstyle='none', ms=6)\nax.axhline(-x0, ls='--', lw=0.5, color='black', alpha=0.5)\nax.axhline( x0, ls='--', lw=0.5, color='black', alpha=0.5)\nplt.text(20, x0-0.1, 'Reactant Well', fontsize = 16, backgroundcolor='white')\nplt.text(5, -x0-0.1, 'Product Well', fontsize = 16, backgroundcolor='white')\nax.set_xlabel(r'Time, fs')\nax.set_ylabel(r'$\\left\\langle x \\right\\rangle$, Bohr')\nax.tick_params(grid_alpha=0.5)\nplt.ylim(-3,4)\nplt.xlim(-.10, 30.1)\nplt.legend(loc='upper right')\n</code></pre> <p></p> <p>We can see that we have good agreement between the expectation values computed from the qubit dynamics and the classical grid-based dynamics. </p> <p>Lastly, we can visualize the evolution over time and see that the dynamics are nearly identical: </p> <p>Note: We can visualize the quantum circuit behind the evolution for a single time-step: </p> <pre><code>dw_dyn_obj.quantum_circuit.draw('mpl', fold=-1)\n</code></pre> <p>And get a nice simplified diagram for the quantum circuit: </p> <p></p> <p>But, in order to get an actual idea for how complex the circuit is, we should first call the <code>.decompose()</code> method, which will break things up into fundamental gates. The resulting circuit is massive (I'll let you see for yourself!):</p> <pre><code>dw_dyn_obj.quantum_circuit.decompose(reps=1).draw('mpl', fold=-1)\n</code></pre> <p>You can increase the number of <code>reps</code> repetitions that the circuit will be decomposed to further decompose the circuit. Here, we're just going to highlight that the number of non-local gates (those involving at least 2 qubits) is greater than 3000 - far more than we can reasonably run on current NISQ devices. </p>"},{"location":"qflux/Closed_Systems/arbitrary_evo/","title":"Evolution for an Arbitrary Hamiltonian","text":"<p>Let us now consider the task of running quantum dynamics for an arbitrary Hamiltonian describing a system of interest, \\(\\hat{H}\\). To do this on a quantum device, we must first express the Hamiltonian in a way that can be easily understood by the quantum device, that is to say that we must express the Hamiltonian as a series of native quantum gates. We can do this by expressing the Hamiltonian as a weighted combination of Pauli strings: </p> \\[ \\hat{H}_{\\text{Pauli}} = \\sum_{i} \\alpha_{i} P_{i} \\] <p>where \\(P_{i}\\) is an \\(n\\)-qubit Pauli string corresponding to Pauli gates acting acting on an \\(n\\)-qubit quantum register. </p> <p>This task can be completed via the <code>decompose()</code> utility function in <code>qflux</code>. </p> <p>Once we've rewritten our Hamiltonian, we can implement real-time dynamics on the quantum device by representing the propagator as a quantum circuit: </p> \\[ \\hat{U} = e^{- \\frac{i}{\\hbar} \\hat{H}_{\\text{Pauli}} \\tau} \\] <p>where \\(\\tau\\) is the time-step. By applying the propagator to a quantum register initialized to our initial state for dynamics calculation (\\(\\left| \\psi_{0} \\right\\rangle\\)), we can obtain the time-evolved state \\(\\left| \\psi ( t ) \\right\\rangle\\). </p> <p>In the following example, we follow this example and look at the time evolution of an Ising Model on linear lattices of length \\(L\\) consisting of an array of spins \\(\\sigma_{i}^{z}\\) with nearest-neighbor interactions. These spins can have two orientations: \\(\\uparrow\\) and \\(\\downarrow\\), which corresopnd to a magnetization of +1 and -1. </p> <p>The Hamiltonian for this sort of system can be written as: </p> \\[ H = - J \\sum_{i=0}^{L-2} \\sigma_{i} \\sigma_{i+1} - h \\sum_{i=0}^{L-1} \\sigma_{i} \\] <p>where \\(J\\) describes the interaction energy between neighboring spins and \\(h\\) describes the magnitude of an applied field. We can write this in terms of Pauli matrix and take the angle (with respect to the trasnversal direction) of the applied field into account: </p> \\[ H = - J \\sum_{i=0}^{L-2} Z_{i} Z_{i+1} - h \\sum_{i=0}^{L-1} \\left( \\sin(\\alpha) Z_{i} + \\cos(\\alpha) X_{i} \\right) \\] <p>We can write a Python function to construct this Hamiltonian: </p> <pre><code>from qiskit.quantum_info import SparsePauliOp\nfrom math import sin, cos, pi\n\ndef get_hamiltonian(L: int, J: float, h: float, alpha: float):\n    r'''\n    Function to construct the Ising Model Hamiltonian for a linear chain \n    of length L with nearest-neighbor interactions, subject to an external\n    field applied at an angle $\\alpha$ with respect to the transversal direction.\n\n    '''\n    # Construct the Hamiltonian by creating 3-tuples with:\n    # (1) the Pauli string\n    # (2) the qubit indices corresponding to the Pauli string\n    # (3) the coefficient\n    pauli_tuples = []\n    for ii in range(L-1):\n        pauli_tuples.append((\"ZZ\", [ii, ii+1], -J))\n        pauli_tuples.append((\"Z\", [ii], -h * sin(alpha)))\n        pauli_tuples.append((\"X\", [ii], -h * cos(alpha)))\n    pauli_tuples.append((\"Z\", [L-1], -h * sin(alpha)))\n    pauli_tuples.append((\"X\", [L-1], -h * cos(alpha)))\n    # Construct the Hamiltonian as a SparsePauliOp from our sparse list\n    hamiltonian = SparsePauliOp.from_sparse_list(pauli_tuples, num_qubits=L)\n    return(hamiltonian.simplify())\n</code></pre> <p>We first look at a spin chain with two spins: </p> <pre><code>spin_H = get_hamiltonian(L=2, J=0.2, h=1.0, alpha=pi/8.)\n</code></pre> <p>And we can now construct an initial state: </p> <pre><code>from qiskit.quantum_info import Statevector\n# Create an initial state with the first spin-up and the second spin-down\nintial_state = Statevector.from_label(\"10\")\n</code></pre> <p>Now we can create our dynamics object with <code>qflux</code> and compute the propagation:</p> <pre><code>from qflux.closed_systems import QubitDynamicsCS\nspin_dyn_obj = QubitDynamicsCS(n_basis=4)\n\n# Specify propagation time:\ntotal_time = 1.6\nN_steps    = 1\n\nspin_dyn_obj.set_propagation_time(total_time, N_steps)\n\n# Set the backend\nfrom qiskit_aer import Aer\nbackend = Aer.get_backend('statevector_simulator')\nspin_dyn_obj.propagate_qmatvec(backend=backend, n_shots=1024, \n                               hamiltonian_matrix=spin_H.to_matrix(), \n                               initial_state=initial_state.data)\n</code></pre> <p>Now we can use this workflow to look at measurement probabilities at a series of angles for the applied external field: </p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nbar_width = 0.1\n# We prepare an initial state \u2191\u2193 (01).\n# Note that Statevector and SparsePauliOp interpret the qubits from right to left\ninitial_state = Statevector.from_label(\"10\")\nfinal_time = 1.6\neps = 1e-5\n\n# We create the list of angles in radians, with a small epsilon\n# the exactly longitudinal field, which would present no dynamics at all\nalphas = np.linspace(-np.pi / 2 + eps, np.pi / 2 - eps, 5)\nlabels = [r'$\\left| 00 \\right\\rangle$', r'$\\left| 01 \\right\\rangle$',\n          r'$\\left| 10 \\right\\rangle$', r'$\\left| 11 \\right\\rangle$']\n\nfor i, alpha in enumerate(alphas):\n    H_alpha = get_hamiltonian(L=2, J=0.2, h=1.0, alpha=alpha)\n    spin_dyn_obj.propagate_qmatvec(backend=backend, n_shots=2048,\n                                   hamiltonian_matrix=H_alpha.to_matrix(),\n                                   initial_state=initial_state.data)\n\n    evolved_state = Statevector(spin_dyn_obj.dynamics_results_qubit[-1])\n    # Dictionary of probabilities\n    amplitudes_dict = evolved_state.probabilities_dict()\n\n    values = list(amplitudes_dict.values())\n    # Convert angle to degrees\n    alpha_str = f\"$\\\\alpha={int(np.round(alpha * 180 / pi))}^\\\\circ$\"\n    plt.bar(np.arange(4) + i * bar_width, values, bar_width, label=alpha_str, alpha=0.7)\n\nplt.xticks(np.arange(4) + 2 * bar_width, labels)\nplt.xlabel(\"Measurement\")\nplt.ylabel(\"Probability\")\nplt.suptitle(\n    f\"Measurement probabilities at $t={final_time}$, for various field angles $\\\\alpha$\\n\"\n    r\"Initial state: $\\left| 1 0 \\right\\rangle$, Linear lattice of size $L=2$\"\n)\nplt.legend()\nplt.tight_layout()\n</code></pre> <p>Which gives us the following plot: </p> <p></p>"},{"location":"qflux/Closed_Systems/arbitrary_evo/#observables","title":"Observables","text":"<p>In this example, we will look at computing observables with the output of a dynamics calculation for a longer chain of spins. We begin with the calculation of the Hamiltonian: </p> <pre><code>L = 6\nspin_H = get_hamiltonian(L=L, J=0.2, h=1.2, alpha=pi/8.)\n</code></pre> <p>And we proceed just as we did before with the construction of our construction object: </p> <pre><code># Instantiate our Dynamics Object \nspin_dyn_obj = QubitDynamicsCS(n_basis=2**L)\n\n# Specify Propagation Time\ntotal_time    = 30.0\nnum_timesteps = 60\nspin_dyn_obj.set_propagation_time(total_time, num_timesteps)\n\n# Set initial State: \ninitial_state = Statevector.from_label(\"001100\")\n\n# Set the backend\nfrom qiskit_aer import Aer\nbackend = Aer.get_backend('statevector_simulator')\nspin_dyn_obj.propagate_qmatvec(backend=backend, n_shots=1024, \n                               hamiltonian_matrix=spin_H.to_matrix(), \n                               initial_state=initial_state.data)\n</code></pre> <p>For our observables, we can construct a magnetization operator \\(\\sum_{i} Z_{i}\\) and a mean spin correlation operator \\(\\sum_{i} Z_{i} Z_{i+1} / (L-1)\\): </p> <pre><code>magnetization_op = SparsePauliOp.from_sparse_list(\n    [(\"Z\", [i], 1.0) for i in range(0, L)], num_qubits=L\n)\ncorrelation_op = SparsePauliOp.from_sparse_list(\n    [(\"ZZ\", [i, i + 1], 1.0) for i in range(0, L - 1)], num_qubits=L\n) / (L - 1)\n</code></pre> <p>And we define a function for calculating the expectation values: </p> <pre><code>def calculate_expectation_value(dynamics_results, observable):\n    expect_out = []\n\n    if type(observable) != np.ndarray:\n        observable = observable.to_matrix()\n\n    for ii in range(len(dynamics_results)):\n        expect_out.append((dynamics_results[ii].conj().T @ observable).dot(dynamics_results[ii]))\n    return(np.asarray(expect_out))\n</code></pre> <p>which we can use to calculate the expectation values: </p> <pre><code>expectation_magnetization = calculate_expectation_value(spin_dyn_obj.dynamics_results_qubit, magnetization_op)\nexpectation_spinspin_corr = calculate_expectation_value(spin_dyn_obj.dynamics_results_qubit, correlation_op)\nexpectation_energy        = calculate_expectation_value(spin_dyn_obj.dynamics_results_qubit, spin_H)\n</code></pre> <p>We can compare this to the exact evolution computed as follows: </p> <pre><code>import scipy\n\nH_array = spin_H.to_matrix()\n\n# We define a slightly denser time mesh\nexact_times = np.linspace(0, total_time, 101)\n\n# We compute the exact evolution using the exp\nexact_evolution = [scipy.linalg.expm(-1j * time * H_array) @ initial_state.data for time in exact_times]\n</code></pre> <p>And we compute the expectation values: </p> <pre><code>exact_energy        = calculate_expectation_value(exact_evolution, H_array)\nexact_magnetization = calculate_expectation_value(exact_evolution, magnetization_op)\nexact_correlation   = calculate_expectation_value(exact_evolution, correlation_op)\n</code></pre> <p>And plot the results of the dynamics computed with <code>qflux</code> and <code>scipy</code> for comparison: </p> <pre><code>fig, axes = plt.subplots(3, sharex=True, figsize=(6, 6))\ntimes = np.linspace(0, total_time, num_timesteps + 1)  # includes initial state\naxes[0].plot(spin_dyn_obj.tlist, expectation_energy, label='Pauli Trotter',\n             marker=\"x\", c=\"darkmagenta\", ls=\"-\", lw=0.8)\naxes[1].plot(spin_dyn_obj.tlist, expectation_magnetization, label='Pauli Trotter',\n             marker=\"x\", c=\"darkmagenta\", ls=\"-\", lw=0.8)\naxes[2].plot(spin_dyn_obj.tlist, expectation_spinspin_corr, label='Pauli Trotter',\n             marker=\"x\", c=\"darkmagenta\", ls=\"-\", lw=0.8)\naxes[0].set_ylabel(\"Energy\", fontsize=16)\naxes[1].set_ylabel(\"Magnetization\", fontsize=16)\naxes[2].set_ylabel(\"Avg. Spin Correlation\", fontsize=16)\naxes[2].set_xlabel(\"Time\")\n\n\n\naxes[0].plot(exact_times, exact_energy, c=\"k\", ls=\":\", label=\"Exact\")\naxes[1].plot(exact_times, exact_magnetization, c=\"k\", ls=\":\", label=\"Exact\")\naxes[2].plot(exact_times, exact_correlation, c=\"k\", ls=\":\", label=\"Exact\")\n# Select the labels of only the first axis\nlegend = fig.legend(\n    *axes[0].get_legend_handles_labels(),\n    bbox_to_anchor=(1.0, 0.5),\n    loc=\"center left\",\n    framealpha=0.5, ncols=2\n)\nfig.suptitle(\"Observable evolution\")\nfig.tight_layout()\n</code></pre> <p>which should look like the following: </p> <p></p> <p>We can also compute the site-specific magnetization: </p> <pre><code>site_specific_magnetizations = np.real(\n                                    [[Statevector(tmp_state).expectation_value(term) for term in magnetization_op]\n                                     for tmp_state in exact_evolution]\n                                        )\n</code></pre> <p>And plot it: </p> <pre><code>from matplotlib import cm\n\nplt.figure(figsize=(14, 2))\n# Create the 2-dim xx and yy arrays tiling the grid with the x and y values\nxx, yy = np.meshgrid(exact_times, np.arange(L))\nplt.pcolor(xx, yy, site_specific_magnetizations.T, vmin=-1, vmax=+1, cmap=\"RdBu\")\n# Force the figure to have all y ticks from 0 to 5\nplt.yticks(np.arange(L))\nplt.ylabel(\"Site $i$\")\nplt.xlabel(\"Time\")\nplt.colorbar(label=\"$\\\\langle Z_i \\\\rangle$\", aspect=1.8)\n</code></pre> <p></p> <p>Similarly, we can compute the site-specific magnetization with our dynamics results: </p> <pre><code>site_specific_magnetizations = np.real(\n                                    [[Statevector(tmp_state).expectation_value(term) for term in magnetization_op] \n                                     for tmp_state in spin_dyn_obj.dynamics_results_qubit]\n                                        )\n</code></pre> <p>And plot it just as we did for the exact dynamics result: </p> <pre><code>from matplotlib import cm\n\nplt.figure(figsize=(14, 2))\n# Create the 2-dim xx and yy arrays tiling the grid with the x and y values\nxx, yy = np.meshgrid(spin_dyn_obj.tlist, np.arange(L))\nplt.pcolor(xx, yy, site_specific_magnetizations.T, vmin=-1, vmax=+1, cmap=\"RdBu\")\n# Force the figure to have all y ticks from 0 to 5\nplt.yticks(np.arange(L))\nplt.ylabel(\"Site $i$\")\nplt.xlabel(\"Time\")\nplt.colorbar(label=\"$\\\\langle Z_i \\\\rangle$\", aspect=1.8)\n</code></pre> <p></p>"},{"location":"qflux/Closed_Systems/basics/","title":"Anatomy of a Closed System Quantum Dynamics Simulation","text":"<p>To run a dynamics simulation, we need to define some key quantities. This section will walk you through the process of defining these things within <code>qflux</code>.</p> <p>As a reminder, the task at hand is compute the time evolution of a wavefunction according to the Schrodinger equation: </p> \\[ \\left| \\psi (t) \\right\\rangle = e^{- \\frac{i}{\\hbar} H t} \\left| \\psi_{0} \\right\\rangle \\] <p>To do this, we must: </p> <ul> <li> <p>Define the initial state \\(\\psi_{0}\\). </p> </li> <li> <p>Define the Hamiltonian describing the system of interest.</p> </li> <li> <p>Define a propagation time-step \\(t\\) and the number of time steps \\(n\\) for which we want to compute the evolved wavefunction. </p> </li> </ul> <p>We will now look at how each of these steps can be done with qflux. </p>"},{"location":"qflux/Closed_Systems/basics/#definition-of-the-initial-state","title":"Definition of the Initial State","text":"<p>The initial state is our wavefunction \\(\\psi_{0}\\). In order to define this abstract object on a computer, we must define a finite space in which it exists. The number of discrete points in this space is controlled by the <code>n_basis</code> parameter that is passed to the <code>DynamicsCS</code> class upon instantiation. Note that if you do not define this argument, the default value of 128 is used. Given 128 grid points, we can begin defining operators. To compute the dynamics in the so-called \"Fock basis\", we define the ladder operators \\(\\hat{a}\\), \\(\\hat{x}\\), and \\(\\hat{p}\\). This is done by calling the <code>.intialize_operator()</code> method. To compute the dynamics in the position/coordinate basis, we must define a range of position-values that define the x-grid of our space. This can be done with the <code>.set_coordinate_operators(x_min=-7., x_max=7)</code> method, which will define an array of <code>n_basis</code> points, ranging from <code>x_min</code> to <code>x_max</code>. Now that we've defined the space in which our wavefunction can exist, we can finally define the wavefunction. </p> <p>When instantiating a dynamics object with the <code>DynamicsCS</code> class, there are some other important arguments that are taken into account: </p> <ul> <li><code>xo</code>: The initial displacement in the position-coordinate. </li> <li><code>po</code>: The initial displacement in the momentum-coordinate. </li> <li><code>mass</code>: The mass of the particle/system of interest.</li> </ul> <p>Note that these should all be defined in atomic units. </p> <p>To define the initial state in our default way, you can simply use the <code>.set_initial_state()</code> method. This takes the optional argument of <code>wfn_omega</code> defining the frequency/width of the intiial state, which takes the default value of 1.0 au. The default initial state in the coordinate basis is defined as a Gaussian coherent state: </p> \\[ \\psi_{0} = \\left( \\frac{m \\omega}{\\pi \\hbar} \\right)^{1/4} e^{- \\frac{m \\omega}{2 \\hbar} \\left( x - x_{0} \\right)^{2} + \\frac{i}{\\hbar} p_{0} x} \\] <p>The default initial state in the ladder/Fock basis is defined as the coherent state with amplitude \\(\\alpha = (x_{0} + i p_{0})/ \\sqrt{2}\\), defined in the Fock basis as: </p> \\[ \\left| \\alpha \\right\\rangle = \\sum_{n=0}^{n_{basis}} \\frac{\\alpha^{n}}{\\sqrt{n!}} e^{- \\frac{1}{2} \\left| \\alpha \\right|^{2}} \\left| n \\right\\rangle \\] <p>where \\(n\\) is a state in the Fock basis. </p> <p>Note that <code>qflux</code> also provides functionality for custom state initialization, in which a user-defined function can be provided. </p> <p>Custom initialization in the coordinate basis is done with the <code>.custom_grid_state_initialization()</code> method. This can be used if you wish to initialize with a different state. To exemplify the usage of this functionality, we can define some function that takes arguments necessary to define a state: </p> <pre><code>import numpy as np\n\ndef custom_gaussian(xvals, xo, po, omega, mass, hbar):\n    normalization_factor = (mass * omega / (np.pi * hbar))**(0.25)\n    exp_func = np.exp( - mass * omega / (2 * hbar) * (xvals - xo)**2 + 1j/hbar * po * xvals)\n    return(normalization_factor * exp_func)\n</code></pre> <p>Then, we can set-up a dynamics object that is ready to initialize a state: </p> <pre><code>from qflux.closed_systems import DynamicsCS, QubitDynamicsCS\n\ndyn_obj = DynamicsCS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=0.2)\ndyn_obj.set_coordinate_operators()\ndyn_obj.initialize_operators()\n</code></pre> <p>And define some arguments to provide to the function: </p> <pre><code>func_args = {'xvals': dyn_obj.x_grid,\n             'xo'   : dyn_obj.xo,\n             'po'   : dyn_obj.po,\n             'omega': 1.0,\n             'mass': dyn_obj.mass,\n             'hbar': 1.0}\n</code></pre> <p>And we can now define the state by calling: </p> <pre><code>dyn_obj.custom_grid_state_initialization(custom_gaussian, **func_args)\n</code></pre> <p>Similarly, to define a custom initial state to be used in the Fock/ladder basis, we follow a similar pattern. We first define some custom function that will return a <code>qutip.Qobj</code>: </p> <pre><code>def custom_coherent_state(N_basis):\n    '''\n    Function to define a squeezed coherent state by squeezing, then displacing the vacuum state.\n    '''\n    squeezed_coh_state = qt.displace(N_basis, 2) * qt.squeeze(N_basis, 1.0) * qt.basis(N_basis, 0)\n    return(squeezed_coh_state)\n</code></pre> <p>And define the keyword arguments as a dictionary:</p> <pre><code>qt_func_args = {'N_basis': dyn_obj.n_basis}\n</code></pre> <p>Then we can perform the custom initialization by calling the <code>.custom_ladder_state_initialization()</code> method:</p> <pre><code>dyn_obj.custom_ladder_state_initialization(custom_coherent_state, **qt_func_args)\n</code></pre> <p>For the custom Fock/ladder basis initialization, the custom function must return a <code>qutip.Qobj</code>. </p>"},{"location":"qflux/Closed_Systems/basics/#defining-the-hamiltonian","title":"Defining the Hamiltonian","text":"<p>The next step for running our dynamics simulation is to define the Hamiltonian, which should describe the system of interest. For the coordinate basis, we assume that the Hamiltonian takes the form of: </p> \\[ H = \\frac{p^{2}}{2 m} + V(x) \\] <p>where \\(V(x)\\) describes the potential energy of our system. <code>qflux</code> provides some example systems out of the box, which we will now demonstrate how to use.</p> <p>To use the built-in potential energy functions, all one must do is use the <code>.set_hamiltonian()</code> method. This method has the optional keyword argument <code>potential_type</code>, which can be used to choose one of the two currently implemented potentials: - Harmonic Oscillator Potential - Arbitrary Quartic Potential</p> <p>The harmonic oscilator potential is implemented in the grid-basis as: </p> \\[ V(x) = \\frac{1}{2} m \\omega^{2} x^{2} \\] <p>and in the ladder basis as: </p> \\[ H = \\hbar \\omega \\left( \\hat{a}^{\\dagger} \\hat{a} + \\frac{1}{2} \\right) \\] <p>The frequency (\\(\\omega\\)) and mass (\\(m\\)) can be controlled when instantiating the dynamics object with the <code>mass</code> and <code>omega</code> keyword arguments. </p> <p>The quartic potential is implemented as: </p> \\[ V(x) = a_{0} + a_{1} \\frac{x}{x_{0}} + a_{2} \\frac{x^{2}}{x_{0}^{2}} + a_{3} \\frac{x^{3}}{x_{0}^{3}} + a_{4} \\frac{x^{4}}{x_{0}^{4}} \\] <p>To use a custom quartic potential, the user should provide a dictionary of keyword arguments that define the coefficients (\\(a_{0}, a_{1}, a_{2}, a_{3}, a_{4}\\)) and the scaling factor \\(x_{0}\\): </p> <pre><code>coeffs_dict = {'a0': 1, 'a1': 1, 'a2': 1, 'a3': 1, 'a4': 1, 'x0': 1}\ndyn_obj.set_hamiltonian(potential_type='quartic', **coeffs_dict)\n</code></pre> <p>For the Fock/ladder basis, the \\(x\\) in the previous equation is replaced with an operator \\(\\hat{a}\\) defined in terms of the creation and annihilation operators as \\(\\hat{x} = \\frac{1}{\\sqrt{2}} \\left( \\hat{a}^{\\dagger} + \\hat{a} \\right)\\) and in the kinetic energy term \\(\\frac{p^{2}}{2m}\\), \\(p\\) is replaced with \\(\\hat{p} =  \\frac{i}{\\sqrt{2}} \\left( \\hat{a}^{\\dagger} - \\hat{a} \\right)\\).</p> <p><code>qflux</code> also supports arbitrary customization of the potential energy function by use of the <code>.set_H_grid_with_custom_potential()</code> and <code>.set_H_op_with_custom_potential()</code> methods. These methods expect a function and a dictionary (of keyword arguments for that function) as arguments. This is illustrated in the following example: </p> <p>Suppose you have some arbitrary Morse-like potential of the form:</p> \\[ V_{Morse} = De ( 1 - e^{- a (x-x_{eq})})^{2} \\] <p>We can define a python function to to construct this potential:</p> <pre><code>def morse_potential(x_eq=None, mass=None, omega=None, xval=None):\n    De = 8\n    xe = 0\n    k = mass*omega**2\n    a = np.sqrt(k/(2*De))\n    y = De * ((1 - np.exp(-a*(xval-x_eq)))**2)\n    return(y)\n</code></pre> <p>And define a dictionary with parameters to define a specific potential:</p> <pre><code>morse_args = {'x_eq': -1.0, 'mass': 1.0, 'omega': 1.5, 'xval': dyn_obj.x_grid}\n</code></pre> <p>And then construct a Hamiltonian with this custom function for our dynamics object by calling: </p> <pre><code>dyn_obj.set_H_grid_with_custom_potential(morse_potential, **morse_args)\n</code></pre> <p>Similarly, we can do this in a <code>qutip.Qobj</code>-compatible format: </p> <pre><code>def morse_potential_op(x_eq=None, mass=None, omega=None, xval=None):\n    De = 8\n    xe = 0\n    k = mass*omega**2\n    a = np.sqrt(k/(2*De))\n    exponential_f = (-a * (xval - x_eq)).expm()\n    y = De * ((1 - exponential_f)**2)\n    return(y)\n</code></pre> <p>And define our dictionary of custom parameters: </p> <pre><code>morse_op_args = {'x_eq': -1.0, 'mass': 1.0, 'omega': 1.5, 'xval': dyn_obj.x_op}\n</code></pre> <p>And finally we can set our Hamiltonian for the Fock/ladder basis by calling: </p> <pre><code>dyn_obj.set_H_op_with_custom_potential(morse_potential_op, **morse_op_args)\n</code></pre>"},{"location":"qflux/Closed_Systems/basics/#definition-of-the-time-grid","title":"Definition of the Time Grid","text":"<p>Given some total propagation time \\(t_{\\text{final}}\\) and a number of steps \\(N_{\\text{steps}}\\), the time list is generated as a numpy array ranging from \\(0\\) to \\(t_{\\text{final}}\\) with an interval \\(dt = t_{\\textrm{final}} / N_{\\text{steps}}\\). This is done with <code>qflux</code> by calling the <code>.set_propagation_time(total_time=20, n_tsteps=400)</code> method. </p>"},{"location":"qflux/Closed_Systems/cs_api/","title":"Source Code","text":""},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems","title":"<code>qflux.closed_systems</code>","text":"<p>qflux v.0.1.0</p> <p>version = 0.1.0</p> <p>Description: </p> <p>classical_methods.py --&gt; DynamicsCS : Closed-System dynamics  qubit_methods.py     --&gt; QubitDynamicsCS : Qubit-based dynamics spin_dynamics_oo.py  --&gt; SpinDynamicsS, SpinDynamicsH : Statevector and hadamard-test implementations (respectively) for spin-chain systems</p>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS","title":"<code>DynamicsCS</code>","text":"<p>Class for closed-system dynamics. All input parameters must be in atomic units to ensure consistency. Please be sure to convert your parameters to atomic units prior to instantiation.</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>class DynamicsCS:\n    \"\"\"\n        Class for closed-system dynamics. **All input parameters must be in\n        atomic units to ensure consistency. Please be sure to convert your\n        parameters to atomic units prior to instantiation.**\n\n    \"\"\"\n\n    def __init__(self, n_basis: int = 128, xo: float = 1.0, po: float = 0.0, mass: float = 1.0,\n                 omega: float = 1.0) -&gt; None:\n        \"\"\"\n        Args:\n            n_basis (int): Number of states to include in the chosen representation. If basis\n                = 'ladder', this is the Fock cutoff and defines the number of states\n                used for representing the ladder operators. If basis = 'coordinate',\n                this defines the number of points for the position and momenta.\n\n            xo (float, optional): Defines the displacement of the initial state in the position\n                coordinate. Default is 1.0 Bohr.\n\n            po (float, optional): Defines the displacement of the initial state in the position\n                coordinate. Default is 1.0 au.\n\n            mass (float, optional): Defines the mass of the particle/system of interest.\n                Default is 1.0 au.\n\n            omega (float, optional): Frequency of harmonic oscillator.\n                Default is 1.0 au.\n\n        \"\"\"\n        #--------- Required Attributes Populated During Execution ----------#\n        self.n_basis                   = n_basis\n        self.xo                        = xo\n        self.po                        = po\n        self.mass                      = mass\n        self.hbar                      = 1.0\n        self.omega                     = omega\n        #--------- Below are Attributes Populated During Execution ---------#\n        self.total_time                = 0.\n        self.n_tsteps                  = 0.\n        self._KE_op                    = None\n        self._PE_op                    = None\n        self.H_op                      = None\n        self.prop_KE_op                = None\n        self.prop_PE_op                = None\n        self.prop_H_op                 = None\n        # Grid operators\n        self._KE_grid                  = None\n        self._PE_grid                  = None\n        self.H_grid                    = None\n        self.PE_prop_grid              = None\n        self.KE_prop_grid              = None\n\n\n    def _get_xgrid(self, x_min: float, x_max: float) -&gt; None:\n        \"\"\"\n        Populate the `self.x_grid` and `self.dx` attributes. This function\n        generates an array of `self.n_basis` evenly spaced values between\n        `x_min` and `x_max`.\n\n        Args:\n            x_min (float): Minimum value of x-coordinates\n            x_max (float): Maximum value of x-coordinates\n\n        Returns:\n            self.dx (float): Spacing between points in the x-coordinate grid.\n            self.xgrid (array_like): Array of grid points from x_min to x_max with spacing of dx\n        \"\"\"\n        dx = (x_max - x_min) / self.n_basis\n        x_grid = np.arange(-self.n_basis / 2, self.n_basis / 2) * dx\n        self.dx = dx\n        self.x_grid = x_grid\n        return\n\n\n    def _get_pgrid(self, x_min: float, x_max: float, reorder: bool = True) -&gt; None:\n        \"\"\"\n        Populate the `self.p_grid` and `self.dp` attributes. This function\n        generates an array of `self.n_basis` evenly spaced values.\n\n        Args:\n            x_min (float): Minimum value of x-coordinates\n            x_max (float): Maximum value of x-coordinates\n            reorder (bool): Boolean flag to determine whether points should be reordered to be\n                compatible with the FFT routine or not.\n\n        Returns:\n            self.dp (float): Spacing between points in the p-coordinate grid.\n            self.pgrid (array_like): Array of momentum grid points\n        \"\"\"\n        dp = 2 * np.pi / (x_max - x_min)\n        pmin = -dp * self.n_basis / 2\n        pmax = dp * self.n_basis / 2\n        plus_pgrid = np.linspace(0, pmax, self.n_basis // 2 + 1)\n        minus_pgrid = - np.flip(np.copy(plus_pgrid))\n        if reorder:\n            p_grid = np.concatenate((plus_pgrid[:-1], minus_pgrid[:-1]))\n        else:\n            p_grid = np.concatenate((minus_pgrid, plus_pgrid))\n        self.p_grid = p_grid\n        self.dp = dp\n        return\n\n\n    def set_coordinate_operators(self, x_min: float = -7., x_max: float = 7., reorder_p: bool = True) -&gt; None:\n        \"\"\"\n        Populate the `self.x_grid`, `self.p_grid`, `self.dx`, and `self.dp`\n        attributes. This functions generates an array of `self.n_basis`\n        evenly spaced values.\n\n        Args:\n            x_min : float\n                Minimum value of x-coordinates\n            x_max : float\n                Maximum value of x-coordinates\n            reorder_p : bool\n                Boolean flag to determine whether momentum values should be\n                reordered to be compatible with the FFT routine or not.\n\n        Returns:\n            self.dx : float\n                Spacing between points in the x-coordinate grid.\n            self.xgrid : array_like\n                Array of x-values\n            self.dp : float\n                Spacing between points in the p-coordinate grid.\n            self.pgrid : array_like\n                Array of p-values\n        \"\"\"\n        self._get_xgrid(x_min, x_max)\n        self._get_pgrid(x_min, x_max, reorder=reorder_p)\n        return\n\n\n    def initialize_operators(self):\n        \"\"\"\n            Function to initialize core operators in the chosen basis.\n\n        \"\"\"\n\n        self.a_op = qt.destroy(self.n_basis)\n        self.x_op = qt.position(self.n_basis)\n        self.p_op = qt.momentum(self.n_basis)\n        return\n\n\n    def _set_hamiltonian_grid(self, potential_type: str = 'harmonic', **kwargs):\n        if potential_type == 'harmonic':\n\n            # Set attributes for the coordinate basis\n            self._PE_grid = self.mass * self.omega ** 2 * self.x_grid ** 2 / 2.\n            self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n            self.H_grid = self._PE_grid + self._KE_grid\n        elif potential_type == 'quartic':\n            if kwargs:\n                if 'a0' in kwargs:\n                    a0 = kwargs['a0']\n                if 'a1' in kwargs:\n                    a1 = kwargs['a1']\n                if 'a2' in kwargs:\n                    a2 = kwargs['a2']\n                if 'a3' in kwargs:\n                    a3 = kwargs['a3']\n                if 'a4' in kwargs:\n                    a4 = kwargs['a4']\n                if 'x0' in kwargs:\n                    x0 = kwargs['x0']\n                # Assume that all inputs have the proper atomic units:\n                cf = 1.0\n                xi = self.x_op\n\n            else:\n                # Define relevant parameters\n                cf = convert_eV_to_au(1.)\n                x0 = 1.9592\n                a0 = 0.0\n                a1 = 0.429\n                a2 = -1.126\n                a3 = -0.143\n                a4 = 0.563\n                # Do calculation for ladder basis\n                xi = self.x_grid / x0\n            self._PE_grid = cf * (a0 + a1 * xi + a2 * xi ** 2 + a3 * xi ** 3 + a4 * xi ** 4)\n            self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n            self.H_grid = self._PE_grid + self._KE_grid\n        return\n\n\n    def _set_hamiltonian_qt(self, potential_type: str = 'harmonic', **kwargs):\n        if potential_type == 'harmonic':\n            # Set attributes for the ladder basis\n            self.H_op = self.hbar * self.omega * (self.a_op.dag() * self.a_op + 0.5)\n            self._KE_op = self.p_op ** 2 / (2. * self.mass)\n            self._PE_op = self.mass * self.omega ** 2 * self.x_op ** 2 / 0.5\n            self.H_xp_op = self._PE_op + self._KE_op\n        elif potential_type == 'quartic':\n            if kwargs:\n                if 'a0' in kwargs:\n                    a0 = kwargs['a0']\n                if 'a1' in kwargs:\n                    a1 = kwargs['a1']\n                if 'a2' in kwargs:\n                    a2 = kwargs['a2']\n                if 'a3' in kwargs:\n                    a3 = kwargs['a3']\n                if 'a4' in kwargs:\n                    a4 = kwargs['a4']\n                if 'x0' in kwargs:\n                    x0 = kwargs['x0']\n                # Assume that all inputs have the proper atomic units:\n                cf = 1.0\n                xi = self.x_op\n\n            else:\n                # Define relevant parameters\n                cf = convert_eV_to_au(1.)\n                x0 = 1.9592\n                a0 = 0.0\n                a1 = 0.429\n                a2 = -1.126\n                a3 = -0.143\n                a4 = 0.563\n                # Do calculation for ladder basis\n                xi = self.x_op / x0\n            self.x0 = x0\n            self._PE_op = cf * (a0 + a1 * xi + a2 * xi ** 2 + a3 * xi ** 3 + a4 * xi ** 4)\n            self._KE_op = self.p_op ** 2 / (2. * self.mass)\n            self.H_op = self._PE_op + self._KE_op\n            return\n\n    def set_hamiltonian(self, potential_type: str = 'harmonic', **kwargs):\n        \"\"\"\n        Function to define Hamiltonian.\n\n        Args:\n            potential_type : str\n                String defining the type of potential energy surface.\n                Available options are: ('harmonic', 'quartic', ...)\n\n                Note: You can manually define your potential energy using the functions:\n                    - set_H_grid_with_custom_potential\n                    - set_H_op_with_custom_potential\n\n        \"\"\"\n\n        if potential_type == 'harmonic':\n            self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n            self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n        elif potential_type == 'quartic':\n            self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n            self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n        else:\n            print('Error, this potential type has not yet been implemented!')\n            print('Set your parameters with the custom functions!')\n        return\n\n\n    def set_H_grid_with_custom_potential(self, custom_function: Callable, **kwargs):\n        \"\"\"\n        Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n        Args:\n            custom_function (Callable): Function that defines the custom potential\n                energy. Must return an array\n\n        \"\"\"\n        potential = custom_function(**kwargs)\n        self._PE_grid = potential\n        self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n        self.H_grid = self._PE_grid + self._KE_grid\n        return\n\n\n    def set_H_op_with_custom_potential(self, custom_function: Callable, **kwargs):\n        \"\"\"\n        Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n        Args:\n            custom_function (Callable): Function that defines the potential\n                energy in terms of qutip QObj operators. Must return a qutip.Qobj\n        \"\"\"\n        potential = custom_function(**kwargs)\n        self._PE_op = potential\n        self._KE_op = self.p_op ** 2 / (2. * self.mass)\n        self.H_op = self._PE_op + self._KE_op\n        return\n\n\n    def set_initial_state(self, wfn_omega: float = 1.0):\n        \"\"\"\n        Function to define the initial state. By default, a coherent state is\n        used as the initial state defined in the basis chosen upon instantiation\n\n        Args:\n            wfn_omega (float, optional): Defines the frequency/width of the initial state.\n                Default is 1.0 au.\n        \"\"\"\n\n        alpha_val = (self.xo + 1j * self.po) / np.sqrt(2)\n        psio = qt.coherent(self.n_basis, alpha=alpha_val)\n        # Now populate the initial state in the grid basis\n        normalization = (self.mass * wfn_omega / np.pi / self.hbar) ** (0.25)\n        exponential = np.exp(-1 * (self.mass * wfn_omega / self.hbar / 2) *\n                             ((self.x_grid - self.xo) ** 2)\n                             + 1j * self.po * self.x_grid / self.hbar\n                             )\n\n        coherent_state = normalization * exponential\n        # Set the attributes\n        self.psio_grid = coherent_state\n        self.psio_op = psio\n        return\n\n\n\n    def custom_grid_state_initialization(self, function_name: Callable, **kwargs):\n        \"\"\"\n        Function to allow for customized grid state initialization.\n\n        Args:\n            function_name (Callable): name of user-defined function that returns\n                the initial state. Must return an array\n        \"\"\"\n\n        self.psio_grid = function_name(**kwargs)\n        return\n\n    def custom_ladder_state_initialization(self, function_name: Callable, **kwargs):\n        \"\"\"\n        Function to allow for customized ladder state initialization.\n\n        Args:\n            function_name (Callable): name of user-defined function that returns\n                the initial state. Must return a qutip.Qobj.\n        \"\"\"\n\n        self.psio_op = function_name(**kwargs)\n        return\n\n    def set_propagation_time(self, total_time: float, n_tsteps: int):\n        \"\"\"\n        Function to define the propagation time, an array of times from\n        t=0 to total_time, with n_tsteps equally-spaced steps.\n\n        Args:\n        total_time : float\n            The total time for which we wish to compute the dynamics.\n        n_tsteps : int\n            The number of equally-spaced time steps used to compute the dynamics\n\n        Returns:\n        self.tlist : array-like\n\n        \"\"\"\n\n        self.tlist = np.linspace(0., total_time, n_tsteps+1)\n        self.dt = self.tlist[1] - self.tlist[0]\n        self.n_tsteps = n_tsteps\n        return\n\n\n    def propagate_qt(self, solver_options : dict = None):\n        \"\"\"\n        Function used to propagate with qutip.\n\n        Args:\n            solver_options (dict): A dictionary of arguments to pass to the qutip.sesolve function\n\n        Returns:\n            dynamics_results (array-like): array containing the propagated state\n\n        \"\"\"\n\n        options = {'nsteps': len(self.tlist),\n                    'progress_bar': True}\n\n        if solver_options:\n            for key in solver_options:\n                options[key] = solver_options[key]\n\n        results = qt.sesolve(self.H_op, self.psio_op, self.tlist,\n                             options=options)\n\n        self.dynamics_results_op = results.states\n        return\n\n\n    def propagate_SOFT(self):\n        \"\"\"\n        Function used to propagate with the 2nd-Order Trotter Expansion.\n\n        $$\n        e^{- \\\\frac{i}{\\\\hbar} H t} \\\\approx e^{- \\\\frac{i}{\\\\hbar} V t/2} e^{- \\\\frac{i}{\\\\hbar} T t} e^{- \\\\frac{i}{\\\\hbar} V t/2} + \\\\mathcal{O}^{3}\n        $$\n\n        Returns:\n            dynamics_results_grid (array-like): array containing the propagated state\n                                                shape (n_tsteps x self.n_basis)\n\n        \"\"\"\n        self.tau = self.tlist[1] - self.tlist[0]\n        PE_prop = np.exp(-1.0j * self._PE_grid / 2 * self.tau / self.hbar)\n        KE_prop = np.exp(-1.0j * self._KE_grid * self.tau / self.hbar)\n\n        self.PE_prop_grid = PE_prop\n        self.KE_prop_grid = KE_prop\n\n        propagated_states = [self.psio_grid]\n        psi_t = self.psio_grid\n        for ii in range(1, len(self.tlist)):\n            psi_t_position_grid = PE_prop * psi_t\n            psi_t_momentum_grid = KE_prop * np.fft.fft(psi_t_position_grid, norm=\"ortho\")\n            psi_t = PE_prop * np.fft.ifft(psi_t_momentum_grid, norm=\"ortho\")\n            propagated_states.append(psi_t)\n\n        self.dynamics_results_grid = np.asarray(propagated_states)\n        return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.__init__","title":"<code>__init__(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>n_basis</code> <code>int</code> <p>Number of states to include in the chosen representation. If basis = 'ladder', this is the Fock cutoff and defines the number of states used for representing the ladder operators. If basis = 'coordinate', this defines the number of points for the position and momenta.</p> <code>128</code> <code>xo</code> <code>float</code> <p>Defines the displacement of the initial state in the position coordinate. Default is 1.0 Bohr.</p> <code>1.0</code> <code>po</code> <code>float</code> <p>Defines the displacement of the initial state in the position coordinate. Default is 1.0 au.</p> <code>0.0</code> <code>mass</code> <code>float</code> <p>Defines the mass of the particle/system of interest. Default is 1.0 au.</p> <code>1.0</code> <code>omega</code> <code>float</code> <p>Frequency of harmonic oscillator. Default is 1.0 au.</p> <code>1.0</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def __init__(self, n_basis: int = 128, xo: float = 1.0, po: float = 0.0, mass: float = 1.0,\n             omega: float = 1.0) -&gt; None:\n    \"\"\"\n    Args:\n        n_basis (int): Number of states to include in the chosen representation. If basis\n            = 'ladder', this is the Fock cutoff and defines the number of states\n            used for representing the ladder operators. If basis = 'coordinate',\n            this defines the number of points for the position and momenta.\n\n        xo (float, optional): Defines the displacement of the initial state in the position\n            coordinate. Default is 1.0 Bohr.\n\n        po (float, optional): Defines the displacement of the initial state in the position\n            coordinate. Default is 1.0 au.\n\n        mass (float, optional): Defines the mass of the particle/system of interest.\n            Default is 1.0 au.\n\n        omega (float, optional): Frequency of harmonic oscillator.\n            Default is 1.0 au.\n\n    \"\"\"\n    #--------- Required Attributes Populated During Execution ----------#\n    self.n_basis                   = n_basis\n    self.xo                        = xo\n    self.po                        = po\n    self.mass                      = mass\n    self.hbar                      = 1.0\n    self.omega                     = omega\n    #--------- Below are Attributes Populated During Execution ---------#\n    self.total_time                = 0.\n    self.n_tsteps                  = 0.\n    self._KE_op                    = None\n    self._PE_op                    = None\n    self.H_op                      = None\n    self.prop_KE_op                = None\n    self.prop_PE_op                = None\n    self.prop_H_op                 = None\n    # Grid operators\n    self._KE_grid                  = None\n    self._PE_grid                  = None\n    self.H_grid                    = None\n    self.PE_prop_grid              = None\n    self.KE_prop_grid              = None\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.custom_grid_state_initialization","title":"<code>custom_grid_state_initialization(function_name, **kwargs)</code>","text":"<p>Function to allow for customized grid state initialization.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>Callable</code> <p>name of user-defined function that returns the initial state. Must return an array</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def custom_grid_state_initialization(self, function_name: Callable, **kwargs):\n    \"\"\"\n    Function to allow for customized grid state initialization.\n\n    Args:\n        function_name (Callable): name of user-defined function that returns\n            the initial state. Must return an array\n    \"\"\"\n\n    self.psio_grid = function_name(**kwargs)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.custom_ladder_state_initialization","title":"<code>custom_ladder_state_initialization(function_name, **kwargs)</code>","text":"<p>Function to allow for customized ladder state initialization.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>Callable</code> <p>name of user-defined function that returns the initial state. Must return a qutip.Qobj.</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def custom_ladder_state_initialization(self, function_name: Callable, **kwargs):\n    \"\"\"\n    Function to allow for customized ladder state initialization.\n\n    Args:\n        function_name (Callable): name of user-defined function that returns\n            the initial state. Must return a qutip.Qobj.\n    \"\"\"\n\n    self.psio_op = function_name(**kwargs)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.initialize_operators","title":"<code>initialize_operators()</code>","text":"<p>Function to initialize core operators in the chosen basis.</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def initialize_operators(self):\n    \"\"\"\n        Function to initialize core operators in the chosen basis.\n\n    \"\"\"\n\n    self.a_op = qt.destroy(self.n_basis)\n    self.x_op = qt.position(self.n_basis)\n    self.p_op = qt.momentum(self.n_basis)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.propagate_SOFT","title":"<code>propagate_SOFT()</code>","text":"<p>Function used to propagate with the 2nd-Order Trotter Expansion.</p> \\[ e^{- \\frac{i}{\\hbar} H t} \\approx e^{- \\frac{i}{\\hbar} V t/2} e^{- \\frac{i}{\\hbar} T t} e^{- \\frac{i}{\\hbar} V t/2} + \\mathcal{O}^{3} \\] <p>Returns:</p> Name Type Description <code>dynamics_results_grid</code> <code>array - like</code> <p>array containing the propagated state                                 shape (n_tsteps x self.n_basis)</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def propagate_SOFT(self):\n    \"\"\"\n    Function used to propagate with the 2nd-Order Trotter Expansion.\n\n    $$\n    e^{- \\\\frac{i}{\\\\hbar} H t} \\\\approx e^{- \\\\frac{i}{\\\\hbar} V t/2} e^{- \\\\frac{i}{\\\\hbar} T t} e^{- \\\\frac{i}{\\\\hbar} V t/2} + \\\\mathcal{O}^{3}\n    $$\n\n    Returns:\n        dynamics_results_grid (array-like): array containing the propagated state\n                                            shape (n_tsteps x self.n_basis)\n\n    \"\"\"\n    self.tau = self.tlist[1] - self.tlist[0]\n    PE_prop = np.exp(-1.0j * self._PE_grid / 2 * self.tau / self.hbar)\n    KE_prop = np.exp(-1.0j * self._KE_grid * self.tau / self.hbar)\n\n    self.PE_prop_grid = PE_prop\n    self.KE_prop_grid = KE_prop\n\n    propagated_states = [self.psio_grid]\n    psi_t = self.psio_grid\n    for ii in range(1, len(self.tlist)):\n        psi_t_position_grid = PE_prop * psi_t\n        psi_t_momentum_grid = KE_prop * np.fft.fft(psi_t_position_grid, norm=\"ortho\")\n        psi_t = PE_prop * np.fft.ifft(psi_t_momentum_grid, norm=\"ortho\")\n        propagated_states.append(psi_t)\n\n    self.dynamics_results_grid = np.asarray(propagated_states)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.propagate_qt","title":"<code>propagate_qt(solver_options=None)</code>","text":"<p>Function used to propagate with qutip.</p> <p>Parameters:</p> Name Type Description Default <code>solver_options</code> <code>dict</code> <p>A dictionary of arguments to pass to the qutip.sesolve function</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dynamics_results</code> <code>array - like</code> <p>array containing the propagated state</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def propagate_qt(self, solver_options : dict = None):\n    \"\"\"\n    Function used to propagate with qutip.\n\n    Args:\n        solver_options (dict): A dictionary of arguments to pass to the qutip.sesolve function\n\n    Returns:\n        dynamics_results (array-like): array containing the propagated state\n\n    \"\"\"\n\n    options = {'nsteps': len(self.tlist),\n                'progress_bar': True}\n\n    if solver_options:\n        for key in solver_options:\n            options[key] = solver_options[key]\n\n    results = qt.sesolve(self.H_op, self.psio_op, self.tlist,\n                         options=options)\n\n    self.dynamics_results_op = results.states\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_H_grid_with_custom_potential","title":"<code>set_H_grid_with_custom_potential(custom_function, **kwargs)</code>","text":"<p>Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.</p> <p>Parameters:</p> Name Type Description Default <code>custom_function</code> <code>Callable</code> <p>Function that defines the custom potential energy. Must return an array</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_H_grid_with_custom_potential(self, custom_function: Callable, **kwargs):\n    \"\"\"\n    Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n    Args:\n        custom_function (Callable): Function that defines the custom potential\n            energy. Must return an array\n\n    \"\"\"\n    potential = custom_function(**kwargs)\n    self._PE_grid = potential\n    self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n    self.H_grid = self._PE_grid + self._KE_grid\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_H_op_with_custom_potential","title":"<code>set_H_op_with_custom_potential(custom_function, **kwargs)</code>","text":"<p>Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.</p> <p>Parameters:</p> Name Type Description Default <code>custom_function</code> <code>Callable</code> <p>Function that defines the potential energy in terms of qutip QObj operators. Must return a qutip.Qobj</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_H_op_with_custom_potential(self, custom_function: Callable, **kwargs):\n    \"\"\"\n    Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n    Args:\n        custom_function (Callable): Function that defines the potential\n            energy in terms of qutip QObj operators. Must return a qutip.Qobj\n    \"\"\"\n    potential = custom_function(**kwargs)\n    self._PE_op = potential\n    self._KE_op = self.p_op ** 2 / (2. * self.mass)\n    self.H_op = self._PE_op + self._KE_op\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_coordinate_operators","title":"<code>set_coordinate_operators(x_min=-7.0, x_max=7.0, reorder_p=True)</code>","text":"<p>Populate the <code>self.x_grid</code>, <code>self.p_grid</code>, <code>self.dx</code>, and <code>self.dp</code> attributes. This functions generates an array of <code>self.n_basis</code> evenly spaced values.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <p>float Minimum value of x-coordinates</p> <code>-7.0</code> <code>x_max</code> <p>float Maximum value of x-coordinates</p> <code>7.0</code> <code>reorder_p</code> <p>bool Boolean flag to determine whether momentum values should be reordered to be compatible with the FFT routine or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>self.dx : float Spacing between points in the x-coordinate grid.</p> <code>None</code> <p>self.xgrid : array_like Array of x-values</p> <code>None</code> <p>self.dp : float Spacing between points in the p-coordinate grid.</p> <code>None</code> <p>self.pgrid : array_like Array of p-values</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_coordinate_operators(self, x_min: float = -7., x_max: float = 7., reorder_p: bool = True) -&gt; None:\n    \"\"\"\n    Populate the `self.x_grid`, `self.p_grid`, `self.dx`, and `self.dp`\n    attributes. This functions generates an array of `self.n_basis`\n    evenly spaced values.\n\n    Args:\n        x_min : float\n            Minimum value of x-coordinates\n        x_max : float\n            Maximum value of x-coordinates\n        reorder_p : bool\n            Boolean flag to determine whether momentum values should be\n            reordered to be compatible with the FFT routine or not.\n\n    Returns:\n        self.dx : float\n            Spacing between points in the x-coordinate grid.\n        self.xgrid : array_like\n            Array of x-values\n        self.dp : float\n            Spacing between points in the p-coordinate grid.\n        self.pgrid : array_like\n            Array of p-values\n    \"\"\"\n    self._get_xgrid(x_min, x_max)\n    self._get_pgrid(x_min, x_max, reorder=reorder_p)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_hamiltonian","title":"<code>set_hamiltonian(potential_type='harmonic', **kwargs)</code>","text":"<p>Function to define Hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>potential_type</code> <p>str String defining the type of potential energy surface. Available options are: ('harmonic', 'quartic', ...)</p> <p>Note: You can manually define your potential energy using the functions:     - set_H_grid_with_custom_potential     - set_H_op_with_custom_potential</p> <code>'harmonic'</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_hamiltonian(self, potential_type: str = 'harmonic', **kwargs):\n    \"\"\"\n    Function to define Hamiltonian.\n\n    Args:\n        potential_type : str\n            String defining the type of potential energy surface.\n            Available options are: ('harmonic', 'quartic', ...)\n\n            Note: You can manually define your potential energy using the functions:\n                - set_H_grid_with_custom_potential\n                - set_H_op_with_custom_potential\n\n    \"\"\"\n\n    if potential_type == 'harmonic':\n        self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n        self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n    elif potential_type == 'quartic':\n        self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n        self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n    else:\n        print('Error, this potential type has not yet been implemented!')\n        print('Set your parameters with the custom functions!')\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_initial_state","title":"<code>set_initial_state(wfn_omega=1.0)</code>","text":"<p>Function to define the initial state. By default, a coherent state is used as the initial state defined in the basis chosen upon instantiation</p> <p>Parameters:</p> Name Type Description Default <code>wfn_omega</code> <code>float</code> <p>Defines the frequency/width of the initial state. Default is 1.0 au.</p> <code>1.0</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_initial_state(self, wfn_omega: float = 1.0):\n    \"\"\"\n    Function to define the initial state. By default, a coherent state is\n    used as the initial state defined in the basis chosen upon instantiation\n\n    Args:\n        wfn_omega (float, optional): Defines the frequency/width of the initial state.\n            Default is 1.0 au.\n    \"\"\"\n\n    alpha_val = (self.xo + 1j * self.po) / np.sqrt(2)\n    psio = qt.coherent(self.n_basis, alpha=alpha_val)\n    # Now populate the initial state in the grid basis\n    normalization = (self.mass * wfn_omega / np.pi / self.hbar) ** (0.25)\n    exponential = np.exp(-1 * (self.mass * wfn_omega / self.hbar / 2) *\n                         ((self.x_grid - self.xo) ** 2)\n                         + 1j * self.po * self.x_grid / self.hbar\n                         )\n\n    coherent_state = normalization * exponential\n    # Set the attributes\n    self.psio_grid = coherent_state\n    self.psio_op = psio\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_propagation_time","title":"<code>set_propagation_time(total_time, n_tsteps)</code>","text":"<p>Function to define the propagation time, an array of times from t=0 to total_time, with n_tsteps equally-spaced steps.</p> <p>total_time : float     The total time for which we wish to compute the dynamics. n_tsteps : int     The number of equally-spaced time steps used to compute the dynamics</p> <p>Returns: self.tlist : array-like</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_propagation_time(self, total_time: float, n_tsteps: int):\n    \"\"\"\n    Function to define the propagation time, an array of times from\n    t=0 to total_time, with n_tsteps equally-spaced steps.\n\n    Args:\n    total_time : float\n        The total time for which we wish to compute the dynamics.\n    n_tsteps : int\n        The number of equally-spaced time steps used to compute the dynamics\n\n    Returns:\n    self.tlist : array-like\n\n    \"\"\"\n\n    self.tlist = np.linspace(0., total_time, n_tsteps+1)\n    self.dt = self.tlist[1] - self.tlist[0]\n    self.n_tsteps = n_tsteps\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.QubitDynamicsCS","title":"<code>QubitDynamicsCS</code>","text":"<p>               Bases: <code>DynamicsCS</code></p> <p>Class to extend <code>DynamicsCS</code> by adding qubit-based methods for dynamics.</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>class QubitDynamicsCS(DynamicsCS):\n    \"\"\"\n    Class to extend `DynamicsCS` by adding qubit-based methods for dynamics.\n\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.n_qubits        = int(np.log2(self.n_basis))\n        self.quantum_circuit = None\n\n\n    def _create_QSOFT_Circuit(self, psio: npt.ArrayLike=None):\n        \"\"\"\n        Function to construct the QSOFT Circuit.\n\n        Args:\n            psio (npt.ArrayLike): initial state that we wish to propagate\n        \"\"\"\n        tgrid = self.tlist\n        time_step = self.dt\n        n_qubits = self.n_qubits\n        # Qubit-Basis Propagators\n        self.prop_PE_qubit = np.diag(np.exp(-1j*self._PE_grid/2*time_step))\n        self.prop_KE_qubit = np.diag(np.exp(-1j*self._KE_grid*time_step))\n\n        q_reg = QuantumRegister(n_qubits)\n        c_reg = ClassicalRegister(n_qubits)\n        qc = QuantumCircuit(q_reg)\n        if type(psio) == type(None):\n            qc.initialize(self._psio_grid, q_reg[:], normalize=True)\n        else:\n            qc.initialize(psio, q_reg[:], normalize=True)\n        # Define our PE and KE propagators in Qiskit-friendly manner\n        PE_cirq_op = Operator(self.prop_PE_qubit)\n        KE_cirq_op = Operator(self.prop_KE_qubit)\n        qc.append(PE_cirq_op, q_reg)\n        qc.append(QFT(self.n_qubits, do_swaps=True, inverse=False), q_reg)\n        qc.append(KE_cirq_op, q_reg)\n        qc.append(QFT(self.n_qubits, do_swaps=True, inverse=True), q_reg)\n        qc.append(PE_cirq_op, q_reg)\n        self.quantum_circuit = qc\n        return(qc)\n\n\n    def _execute_circuit(self, QCircuit: QuantumCircuit, backend=None, shots: int = None, real_backend: bool = False):\n        \"\"\"\n            Function to replace the now-deprecated Qiskit\n            `QuantumCircuit.execute()` method.\n\n            Args:\n                QCircuit (qiskit.QuantumCircuit): qiskit.QuantumCircuit object\n                backend (qiskit.Backend): qiskit backend instance\n                shots (int): the number of shots to use for circuit sampling\n\n            Returns:\n                job: an executed quantum circuit job\n        \"\"\"\n        if shots:\n            n_shots = shots\n        else:\n            n_shots = 1024 # Use the qiskit default if not specified\n        backend_type = type(backend)\n        sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n        if backend_type == sv_type:\n            real_backend = False\n        else:\n            real_backend = True\n\n        if real_backend:\n            QCircuit.measure_all()\n            qc = transpile(QCircuit, backend=backend)\n            sampler = Sampler(backend)\n            job = sampler.run([qc], shots=n_shots)\n        else:\n            # Transpile circuit with statevector backend\n            tmp_circuit = transpile(QCircuit, backend)\n            # Run the transpiled circuit\n            job = backend.run(tmp_circuit, n_shots=shots)\n        return(job)\n\n\n    def propagate_qSOFT(self, backend=None, n_shots: int = 1024):\n        \"\"\"Function to propagate dynamics object with the qubit SOFT method.\n\n            Args:\n                backend (qiskit.Backend): qiskit backend object\n                n_shots (int): specifies the number of shots to use when\n                    executing the circuit\n\n            Example for using the Statevector Simulator backend:\n                &gt;&gt;&gt; from qiskit_aer import Aer\n                &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n                &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n        \"\"\"\n        if backend is None:\n            print('A valid backend must be provided ')\n        backend_type = type(backend)\n        sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n        if backend_type != sv_type:\n            self._propagate_qSOFT_real(backend=backend, n_shots=n_shots)\n            return\n        else:\n\n            psi_in = self.psio_grid\n            # Get initial state from qiskit routine\n            q_reg = QuantumRegister(self.n_qubits)\n            c_reg = ClassicalRegister(self.n_qubits)\n            qc = QuantumCircuit(q_reg, c_reg)\n            qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n            qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n            psio_cirq = qc_result.result().get_statevector().data\n            psi_in = psio_cirq\n            # Now do propagation loop\n            qubit_dynamics_results = [psio_cirq]\n            for ii in trange(1, len(self.tlist)):\n                circuit = self._create_QSOFT_Circuit(psio=psi_in)\n                executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n                psi_out = executed_circuit.result().get_statevector().data\n                qubit_dynamics_results.append(psi_out)\n                psi_in = psi_out\n\n            self.dynamics_results_qSOFT = np.asarray(qubit_dynamics_results)\n            return\n\n\n    def get_statevector_from_counts(self, counts, n_shots):\n        new_statevector = np.zeros_like(self.psio_grid)\n\n        for key in counts:\n            little_endian_int = int(key, 2)\n            new_statevector[little_endian_int] = counts[key]/n_shots\n        return(new_statevector)\n\n\n    def _propagate_qSOFT_real(self, backend='statevector_simulator', n_shots=1024):\n        \"\"\"\n            Function to propagate dynamics object with the qubit SOFT method.\n\n            Args:\n                backend (qiskit.Backend): qiskit backend object\n                n_shots (int): specifies the number of shots to use when\n                    executing the circuit\n\n            Example for using the Statevector Simulator backend:\n                &gt;&gt;&gt; from qiskit_aer import Aer\n                &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n                &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n        \"\"\"\n\n\n        psi_in = self.psio_grid\n        # Get initial state from qiskit routine\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits, name='c')\n        qc = QuantumCircuit(q_reg, c_reg)\n        qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n        # Now do propagation loop\n        qubit_dynamics_results = []\n        for ii in trange(len(self.tlist)):\n            circuit = self._create_QSOFT_Circuit(psio=psi_in)\n            executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n            circuit_result = executed_circuit.result()\n            measured_psi = circuit_result[0].data['meas'].get_counts()\n            self._last_measurement = measured_psi\n            psi_out = self.get_statevector_from_counts(measured_psi, n_shots)\n            psi_in = psi_out\n            qubit_dynamics_results.append(psi_out)\n            psi_in = psi_out\n\n        self.dynamics_results_qSOFT = np.asarray(qubit_dynamics_results)\n        return\n\n\n    def _construct_pauli_gate(self, hamiltonian_matrix=None):\n        \"\"\"\n            Function to construct a pauli evolution gate from Hamiltonian\n\n            Args:\n                hamiltonian_matrix (npt.ArrayLike): array-like matrix representing the hamiltonian of interest\n                    If not provided, use the operator representation of the Hamiltonian by default.\n\n        \"\"\"\n\n        if type(hamiltonian_matrix) == type(None):\n            decomposed_H = decompose(self.H_op.full())\n        else:\n            decomposed_H = decompose(hamiltonian_matrix)\n        H_pauli_sum  = pauli_strings_2_pauli_sum(decomposed_H)\n        synthesizer  = LieTrotter(reps=2)\n        prop_pauli_H = PauliEvolutionGate(operator=H_pauli_sum, time=self.dt, synthesis=synthesizer)\n        self.pauli_prop = prop_pauli_H\n        self._pauli_hamiltonian = decomposed_H\n        return\n\n\n    def _construct_pauli_cirq(self, psio=None):\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits)\n        qc = QuantumCircuit(q_reg, c_reg)\n        qc.initialize(psio, q_reg[:], normalize=True)\n        qc.append(self.pauli_prop, q_reg)\n        self.quantum_circuit = qc\n        return(qc)\n\n\n    def propagate_qmatvec(self, backend=None, n_shots: int = 1024, hamiltonian_matrix=None, initial_state=None):\n        r\"\"\"\n            Function to propagate dynamics object with the qubit matvec method.\n\n            Args:\n                backend (qiskit.Backend): qiskit backend object\n                n_shots (int): specifies the number of shots to use when\n                    executing the circuit\n                hamiltonian_matrix (npt.ArrayLike): array-like matrix representing the Hamiltonian\n                    Used to construct the propagator:\n\n                    $$ U(t) = e^{- i H t / \\hbar} $$ \n\n                    By default, the operator representation of the hamiltonian `self.H_op` is used.\n                initial_state (npt.ArrayLike): array-like vector representing the initial state\n            Example for using the Statevector Simulator backend:\n                &gt;&gt;&gt; from qiskit_aer import Aer\n                &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n                &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n        \"\"\"\n\n        # Create the Pauli propagator:\n        self._construct_pauli_gate(hamiltonian_matrix=hamiltonian_matrix)\n\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits)\n        qc = QuantumCircuit(q_reg, c_reg)\n        # Initialize State\n        if type(initial_state) == type(None):\n            qc.initialize(self.psio_op.full().flatten(), q_reg[:], normalize=True)\n        else:\n            qc.initialize(initial_state, q_reg[:], normalize=True)\n        qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n        psio_cirq = qc_result.result().get_statevector().data\n        psi_in = psio_cirq\n        new_qubit_dynamics_result = [psio_cirq]\n        for ii in trange(1, len(self.tlist)):\n            circuit = self._construct_pauli_cirq(psio=psi_in)\n            executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n            psi_out = executed_circuit.result().get_statevector().data\n            new_qubit_dynamics_result.append(psi_out)\n            psi_in = psi_out\n        self.dynamics_results_qubit = np.asarray(new_qubit_dynamics_result)\n        return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.QubitDynamicsCS.propagate_qSOFT","title":"<code>propagate_qSOFT(backend=None, n_shots=1024)</code>","text":"<p>Function to propagate dynamics object with the qubit SOFT method.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>qiskit backend object</p> <code>None</code> <code>n_shots</code> <code>int</code> <p>specifies the number of shots to use when executing the circuit</p> <code>1024</code> Example for using the Statevector Simulator backend <p>from qiskit_aer import Aer backend = Aer.get_backend('statevector_simulator') self.propagate_qSOFT(backend=backend)</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def propagate_qSOFT(self, backend=None, n_shots: int = 1024):\n    \"\"\"Function to propagate dynamics object with the qubit SOFT method.\n\n        Args:\n            backend (qiskit.Backend): qiskit backend object\n            n_shots (int): specifies the number of shots to use when\n                executing the circuit\n\n        Example for using the Statevector Simulator backend:\n            &gt;&gt;&gt; from qiskit_aer import Aer\n            &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n            &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n    \"\"\"\n    if backend is None:\n        print('A valid backend must be provided ')\n    backend_type = type(backend)\n    sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n    if backend_type != sv_type:\n        self._propagate_qSOFT_real(backend=backend, n_shots=n_shots)\n        return\n    else:\n\n        psi_in = self.psio_grid\n        # Get initial state from qiskit routine\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits)\n        qc = QuantumCircuit(q_reg, c_reg)\n        qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n        qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n        psio_cirq = qc_result.result().get_statevector().data\n        psi_in = psio_cirq\n        # Now do propagation loop\n        qubit_dynamics_results = [psio_cirq]\n        for ii in trange(1, len(self.tlist)):\n            circuit = self._create_QSOFT_Circuit(psio=psi_in)\n            executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n            psi_out = executed_circuit.result().get_statevector().data\n            qubit_dynamics_results.append(psi_out)\n            psi_in = psi_out\n\n        self.dynamics_results_qSOFT = np.asarray(qubit_dynamics_results)\n        return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.QubitDynamicsCS.propagate_qmatvec","title":"<code>propagate_qmatvec(backend=None, n_shots=1024, hamiltonian_matrix=None, initial_state=None)</code>","text":"<p>Function to propagate dynamics object with the qubit matvec method.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>qiskit backend object</p> <code>None</code> <code>n_shots</code> <code>int</code> <p>specifies the number of shots to use when executing the circuit</p> <code>1024</code> <code>hamiltonian_matrix</code> <code>ArrayLike</code> <p>array-like matrix representing the Hamiltonian Used to construct the propagator:</p> \\[ U(t) = e^{- i H t / \\hbar} \\] <p>By default, the operator representation of the hamiltonian <code>self.H_op</code> is used.</p> <code>None</code> <code>initial_state</code> <code>ArrayLike</code> <p>array-like vector representing the initial state</p> <code>None</code> <p>Example for using the Statevector Simulator backend:     &gt;&gt;&gt; from qiskit_aer import Aer     &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')     &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def propagate_qmatvec(self, backend=None, n_shots: int = 1024, hamiltonian_matrix=None, initial_state=None):\n    r\"\"\"\n        Function to propagate dynamics object with the qubit matvec method.\n\n        Args:\n            backend (qiskit.Backend): qiskit backend object\n            n_shots (int): specifies the number of shots to use when\n                executing the circuit\n            hamiltonian_matrix (npt.ArrayLike): array-like matrix representing the Hamiltonian\n                Used to construct the propagator:\n\n                $$ U(t) = e^{- i H t / \\hbar} $$ \n\n                By default, the operator representation of the hamiltonian `self.H_op` is used.\n            initial_state (npt.ArrayLike): array-like vector representing the initial state\n        Example for using the Statevector Simulator backend:\n            &gt;&gt;&gt; from qiskit_aer import Aer\n            &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n            &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n    \"\"\"\n\n    # Create the Pauli propagator:\n    self._construct_pauli_gate(hamiltonian_matrix=hamiltonian_matrix)\n\n    q_reg = QuantumRegister(self.n_qubits)\n    c_reg = ClassicalRegister(self.n_qubits)\n    qc = QuantumCircuit(q_reg, c_reg)\n    # Initialize State\n    if type(initial_state) == type(None):\n        qc.initialize(self.psio_op.full().flatten(), q_reg[:], normalize=True)\n    else:\n        qc.initialize(initial_state, q_reg[:], normalize=True)\n    qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n    psio_cirq = qc_result.result().get_statevector().data\n    psi_in = psio_cirq\n    new_qubit_dynamics_result = [psio_cirq]\n    for ii in trange(1, len(self.tlist)):\n        circuit = self._construct_pauli_cirq(psio=psi_in)\n        executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n        psi_out = executed_circuit.result().get_statevector().data\n        new_qubit_dynamics_result.append(psi_out)\n        psi_in = psi_out\n    self.dynamics_results_qubit = np.asarray(new_qubit_dynamics_result)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsS","title":"<code>SpinDynamicsS</code>","text":"<p>A class to simulate the dynamics of a quantum system using a statevector approach.</p> <p>Attributes:</p> Name Type Description <code>num_qubits</code> <code>int</code> <p>Number of qubits in the quantum system.</p> <code>evolution_timestep</code> <code>float</code> <p>Time step for the evolution.</p> <code>trotter_steps</code> <code>int</code> <p>Number of Trotter steps for the simulation.</p> <code>hamiltonian_coefficients</code> <code>list</code> <p>Hamiltonian coefficients for the system.</p> <code>initial_state</code> <code>str or list</code> <p>Initial state of the system, represented as a binary string or list.</p> <code>time_evo_op</code> <code>QuantumCircuit</code> <p>Time evolution operator for the system.</p> <code>psin0</code> <code>ndarray</code> <p>Initial state vector.</p> <code>psin_list</code> <code>list</code> <p>List of state vectors during the simulation.</p> <code>correlation_list</code> <code>list</code> <p>List of correlations calculated during the simulation.</p> <code>dpi</code> <code>int</code> <p>DPI setting for plot output.</p> Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>class SpinDynamicsS:\n    \"\"\"\n    A class to simulate the dynamics of a quantum system using a statevector approach.\n\n    Attributes:\n        num_qubits (int): Number of qubits in the quantum system.\n        evolution_timestep (float): Time step for the evolution.\n        trotter_steps (int): Number of Trotter steps for the simulation.\n        hamiltonian_coefficients (list): Hamiltonian coefficients for the system.\n        initial_state (str or list): Initial state of the system, represented as a binary string or list.\n        time_evo_op (QuantumCircuit): Time evolution operator for the system.\n        psin0 (ndarray): Initial state vector.\n        psin_list (list): List of state vectors during the simulation.\n        correlation_list (list): List of correlations calculated during the simulation.\n        dpi (int): DPI setting for plot output.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_qubits,\n        evolution_timestep,\n        trotter_steps,\n        hamiltonian_coefficients,\n    ):\n        \"\"\"\n        Initialize the QuantumDynamicsClassicalSimulation class.\n\n        Args:\n            num_qubits (int): Number of qubits in the quantum system.\n            evolution_timestep (float): Time step for the evolution.\n            trotter_steps (int): Number of Trotter steps for the simulation.\n            hamiltonian_coefficients (list): Hamiltonian coefficients for the system.\n        \"\"\"\n        self.num_qubits = num_qubits\n        self.evolution_timestep = evolution_timestep\n        self.trotter_steps = trotter_steps\n        self.hamiltonian_coefficients = hamiltonian_coefficients\n        self.time_evo_op = get_time_evolution_operator(\n            num_qubits=self.num_qubits,\n            tau=self.evolution_timestep,\n            trotter_steps=self.trotter_steps,\n            coeff=self.hamiltonian_coefficients,\n        )\n        self.initial_state = ''\n        self.psin_list = []\n        self.correlation_list = []\n\n        # Plot settings\n        self.dpi = 300\n        plt.rcParams[\"axes.linewidth\"] = 1.5\n        plt.rcParams[\"lines.markersize\"] = 11\n        plt.rcParams[\"figure.figsize\"] = (6.4, 3.6)\n\n    def prepare_initial_state(self, state_string):\n        \"\"\"\n        Prepare the initial state vector from the binary string or list.\n\n        Returns:\n            psin (npt.ArrayLike): Flattened initial state vector.\n        \"\"\"\n        zero_state = np.array([[1], [0]])\n        one_state = np.array([[0], [1]])\n\n        # Map binary string or list to quantum states\n        state_vectors = [\n            zero_state if str(bit) == \"0\" else one_state for bit in state_string\n        ]\n\n        # Perform Kronecker product to construct the full initial state\n        psin = state_vectors[0]\n        for state in state_vectors[1:]:\n            psin = np.kron(psin, state)\n        return psin.flatten()\n\n    def qsolve_statevector(self, psin):\n        \"\"\"\n        Perform statevector propagation for the quantum circuit.\n            initial_state (str or list): Initial state of the system, represented as a binary string or list.\n\n        Args:\n            psin (npt.ArrayLike): Input statevector.\n\n        Returns:\n            ndarray (npt.ArrayLike): Final statevector after execution.\n        \"\"\"\n        d = int(np.log2(np.size(psin)))\n        qre = QuantumRegister(d)\n        circ = QuantumCircuit(qre)\n        circ.initialize(psin, qre)\n        circ.barrier()\n        circ.append(self.time_evo_op, qre)\n        circ.barrier()\n\n        device = Aer.get_backend(\"statevector_simulator\")\n        result = execute(circ, backend=device).result()\n        return result.get_statevector()\n\n    def run_dynamics(self, nsteps, state_string):\n        \"\"\"\n        Simulate the dynamics of the quantum system over a number of steps.\n\n        Args:\n            nsteps (int): Number of time steps for the simulation.\n        \"\"\"\n        self.psin0 = self.prepare_initial_state(state_string)\n        self.psin_list = [self.psin0]\n        for k in range(nsteps):\n            print(f\"Running dynamics step {k}\")\n            if k &gt; 0:\n                psin = self.qsolve_statevector(self.psin_list[-1])\n                self.psin_list.pop()\n                self.psin_list.append(psin)\n\n            self.correlation_list.append(np.vdot(self.psin_list[-1], self.psin0))\n\n    def save_results(self, filename_prefix):\n        \"\"\"\n        Save the simulation results to files.\n\n        Args:\n            filename_prefix (str): Prefix for the output filenames.\n        \"\"\"\n        time = np.arange(\n            0,\n            self.evolution_timestep * len(self.correlation_list),\n            self.evolution_timestep,\n        )\n        np.save(f\"{filename_prefix}_time\", time)\n        sa_observable = np.abs(self.correlation_list)\n        np.save(f\"{filename_prefix}_SA_obs\", sa_observable)\n\n    def plot_results(self, filename_prefix):\n        \"\"\"\n        Plot the simulation results and save the plots as files.\n\n        Args:\n            filename_prefix (str): Prefix for the output filenames.\n        \"\"\"\n        time = np.arange(\n            0,\n            self.evolution_timestep * len(self.correlation_list),\n            self.evolution_timestep,\n        )\n        sa_observable = np.abs(self.correlation_list)\n\n        plt.plot(time, sa_observable, \"-o\")\n        plt.xlabel(\"Time\")\n        plt.ylabel(r\"$\\left|\\langle \\psi | \\psi (t)  \\rangle \\right|$\")\n        plt.xlim((min(time), max(time)))\n        plt.yscale(\"log\")\n        #plt.legend()\n        plt.tight_layout()\n        plt.savefig(f\"{filename_prefix}.pdf\", format=\"pdf\", dpi=self.dpi)\n        plt.savefig(f\"{filename_prefix}.png\", format=\"png\", dpi=self.dpi)\n        plt.show()\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsS.__init__","title":"<code>__init__(num_qubits, evolution_timestep, trotter_steps, hamiltonian_coefficients)</code>","text":"<p>Initialize the QuantumDynamicsClassicalSimulation class.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>int</code> <p>Number of qubits in the quantum system.</p> required <code>evolution_timestep</code> <code>float</code> <p>Time step for the evolution.</p> required <code>trotter_steps</code> <code>int</code> <p>Number of Trotter steps for the simulation.</p> required <code>hamiltonian_coefficients</code> <code>list</code> <p>Hamiltonian coefficients for the system.</p> required Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def __init__(\n    self,\n    num_qubits,\n    evolution_timestep,\n    trotter_steps,\n    hamiltonian_coefficients,\n):\n    \"\"\"\n    Initialize the QuantumDynamicsClassicalSimulation class.\n\n    Args:\n        num_qubits (int): Number of qubits in the quantum system.\n        evolution_timestep (float): Time step for the evolution.\n        trotter_steps (int): Number of Trotter steps for the simulation.\n        hamiltonian_coefficients (list): Hamiltonian coefficients for the system.\n    \"\"\"\n    self.num_qubits = num_qubits\n    self.evolution_timestep = evolution_timestep\n    self.trotter_steps = trotter_steps\n    self.hamiltonian_coefficients = hamiltonian_coefficients\n    self.time_evo_op = get_time_evolution_operator(\n        num_qubits=self.num_qubits,\n        tau=self.evolution_timestep,\n        trotter_steps=self.trotter_steps,\n        coeff=self.hamiltonian_coefficients,\n    )\n    self.initial_state = ''\n    self.psin_list = []\n    self.correlation_list = []\n\n    # Plot settings\n    self.dpi = 300\n    plt.rcParams[\"axes.linewidth\"] = 1.5\n    plt.rcParams[\"lines.markersize\"] = 11\n    plt.rcParams[\"figure.figsize\"] = (6.4, 3.6)\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsS.plot_results","title":"<code>plot_results(filename_prefix)</code>","text":"<p>Plot the simulation results and save the plots as files.</p> <p>Parameters:</p> Name Type Description Default <code>filename_prefix</code> <code>str</code> <p>Prefix for the output filenames.</p> required Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def plot_results(self, filename_prefix):\n    \"\"\"\n    Plot the simulation results and save the plots as files.\n\n    Args:\n        filename_prefix (str): Prefix for the output filenames.\n    \"\"\"\n    time = np.arange(\n        0,\n        self.evolution_timestep * len(self.correlation_list),\n        self.evolution_timestep,\n    )\n    sa_observable = np.abs(self.correlation_list)\n\n    plt.plot(time, sa_observable, \"-o\")\n    plt.xlabel(\"Time\")\n    plt.ylabel(r\"$\\left|\\langle \\psi | \\psi (t)  \\rangle \\right|$\")\n    plt.xlim((min(time), max(time)))\n    plt.yscale(\"log\")\n    #plt.legend()\n    plt.tight_layout()\n    plt.savefig(f\"{filename_prefix}.pdf\", format=\"pdf\", dpi=self.dpi)\n    plt.savefig(f\"{filename_prefix}.png\", format=\"png\", dpi=self.dpi)\n    plt.show()\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsS.prepare_initial_state","title":"<code>prepare_initial_state(state_string)</code>","text":"<p>Prepare the initial state vector from the binary string or list.</p> <p>Returns:</p> Name Type Description <code>psin</code> <code>ArrayLike</code> <p>Flattened initial state vector.</p> Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def prepare_initial_state(self, state_string):\n    \"\"\"\n    Prepare the initial state vector from the binary string or list.\n\n    Returns:\n        psin (npt.ArrayLike): Flattened initial state vector.\n    \"\"\"\n    zero_state = np.array([[1], [0]])\n    one_state = np.array([[0], [1]])\n\n    # Map binary string or list to quantum states\n    state_vectors = [\n        zero_state if str(bit) == \"0\" else one_state for bit in state_string\n    ]\n\n    # Perform Kronecker product to construct the full initial state\n    psin = state_vectors[0]\n    for state in state_vectors[1:]:\n        psin = np.kron(psin, state)\n    return psin.flatten()\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsS.qsolve_statevector","title":"<code>qsolve_statevector(psin)</code>","text":"<p>Perform statevector propagation for the quantum circuit.     initial_state (str or list): Initial state of the system, represented as a binary string or list.</p> <p>Parameters:</p> Name Type Description Default <code>psin</code> <code>ArrayLike</code> <p>Input statevector.</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ArrayLike</code> <p>Final statevector after execution.</p> Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def qsolve_statevector(self, psin):\n    \"\"\"\n    Perform statevector propagation for the quantum circuit.\n        initial_state (str or list): Initial state of the system, represented as a binary string or list.\n\n    Args:\n        psin (npt.ArrayLike): Input statevector.\n\n    Returns:\n        ndarray (npt.ArrayLike): Final statevector after execution.\n    \"\"\"\n    d = int(np.log2(np.size(psin)))\n    qre = QuantumRegister(d)\n    circ = QuantumCircuit(qre)\n    circ.initialize(psin, qre)\n    circ.barrier()\n    circ.append(self.time_evo_op, qre)\n    circ.barrier()\n\n    device = Aer.get_backend(\"statevector_simulator\")\n    result = execute(circ, backend=device).result()\n    return result.get_statevector()\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsS.run_dynamics","title":"<code>run_dynamics(nsteps, state_string)</code>","text":"<p>Simulate the dynamics of the quantum system over a number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>nsteps</code> <code>int</code> <p>Number of time steps for the simulation.</p> required Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def run_dynamics(self, nsteps, state_string):\n    \"\"\"\n    Simulate the dynamics of the quantum system over a number of steps.\n\n    Args:\n        nsteps (int): Number of time steps for the simulation.\n    \"\"\"\n    self.psin0 = self.prepare_initial_state(state_string)\n    self.psin_list = [self.psin0]\n    for k in range(nsteps):\n        print(f\"Running dynamics step {k}\")\n        if k &gt; 0:\n            psin = self.qsolve_statevector(self.psin_list[-1])\n            self.psin_list.pop()\n            self.psin_list.append(psin)\n\n        self.correlation_list.append(np.vdot(self.psin_list[-1], self.psin0))\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsS.save_results","title":"<code>save_results(filename_prefix)</code>","text":"<p>Save the simulation results to files.</p> <p>Parameters:</p> Name Type Description Default <code>filename_prefix</code> <code>str</code> <p>Prefix for the output filenames.</p> required Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def save_results(self, filename_prefix):\n    \"\"\"\n    Save the simulation results to files.\n\n    Args:\n        filename_prefix (str): Prefix for the output filenames.\n    \"\"\"\n    time = np.arange(\n        0,\n        self.evolution_timestep * len(self.correlation_list),\n        self.evolution_timestep,\n    )\n    np.save(f\"{filename_prefix}_time\", time)\n    sa_observable = np.abs(self.correlation_list)\n    np.save(f\"{filename_prefix}_SA_obs\", sa_observable)\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsH","title":"<code>SpinDynamicsH</code>","text":"<p>A class to simulate quantum dynamics using Hadamard tests and time evolution operators.</p> <p>This class performs quantum circuit construction, execution, and data processing to calculate survival amplitudes and probabilities for a spin chain system.</p> Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>class SpinDynamicsH:\n    \"\"\"\n    A class to simulate quantum dynamics using Hadamard tests and time evolution operators.\n\n    This class performs quantum circuit construction, execution, and data processing to calculate\n    survival amplitudes and probabilities for a spin chain system.\n    \"\"\"\n    def __init__(self, num_qubits, evolution_timestep, trotter_steps, hamiltonian_coefficients):\n        \"\"\"\n        Initializes the QuantumSimulation class with system parameters and sets up the simulator.\n\n        Parameters:\n            num_qubits (int): Number of qubits in the system.\n            hamiltonian_coefficients (list): Coefficients for the Hamiltonian terms.\n            evolution_timestep (float): Timestep for the time evolution operator.\n        \"\"\"\n        self.num_qubits = num_qubits\n        self.hamiltonian_coefficients = hamiltonian_coefficients\n        self.evolution_timestep = evolution_timestep\n        self.trotter_steps = trotter_steps,\n        self.simulator = Aer.get_backend('qasm_simulator')\n        self.real_amp_list = []\n        self.imag_amp_list = []\n\n        self.time_evo_op = get_time_evolution_operator(\n            num_qubits=num_qubits,\n            tau=evolution_timestep,\n            trotter_steps=trotter_steps,\n            coeff=hamiltonian_coefficients\n        )\n        self.controlled_time_evo_op = self.time_evo_op.control()\n\n    def get_hadamard_test(self, initial_state, control_repeats, imag_expectation=False):\n        \"\"\"\n        Constructs the Hadamard test circuit to evaluate the real or imaginary components of the operator.\n\n        Parameters:\n            initial_state (QuantumCircuit): Circuit for initializing the quantum state.\n            control_repeats (int): Number of times the controlled operation is applied.\n            imag_expectation (bool): Whether to evaluate the imaginary component (default: False).\n\n        Returns:\n            qc (QuantumCircuit): The constructed Hadamard test circuit.\n        \"\"\"\n        qr = QuantumRegister(self.num_qubits + 1)\n        cr = ClassicalRegister(1)\n        qc = QuantumCircuit(qr, cr)\n        qc.append(initial_state, qr[1:])\n        qc.barrier()\n\n        qc.h(0)\n        if imag_expectation:\n            qc.p(-np.pi / 2, 0)\n\n        for _ in range(control_repeats):\n            qc.append(self.controlled_time_evo_op, qr[:])\n\n        qc.h(0)\n        qc.barrier()\n        qc.measure(0, 0)\n        return qc\n\n    def execute_circuit(self, qc, num_shots=100):\n        \"\"\"\n        Executes a quantum circuit using the Qiskit simulator and retrieves measurement counts.\n\n        Parameters:\n            qc (QuantumCircuit): The quantum circuit to execute.\n            num_shots (int): Number of shots for circuit execution (default: 100).\n\n        Returns:\n            dict (dict): Measurement counts.\n        \"\"\"\n        job = execute(qc, self.simulator, shots=num_shots)\n        return job.result().get_counts()\n\n    @staticmethod\n    def calculate_spin_correlation(counts):\n        \"\"\"\n        Calculates the spin correlation based on measurement counts.\n\n        Parameters:\n            counts (dict): Measurement counts.\n\n        Returns:\n            results (float): Average spin correlation.\n        \"\"\"\n        qubit_to_spin_map = {'0': 1, '1': -1}\n        total_counts = sum(counts.values())\n        values = [qubit_to_spin_map[k] * v for k, v in counts.items()]\n        return sum(values) / total_counts\n\n    @staticmethod\n    def initialize_state(num_qubits, state_string):\n        \"\"\"\n        Creates a circuit to initialize the quantum state.\n\n        Parameters:\n            num_qubits (int): Number of qubits.\n            state_string (str): Binary string representing the initial state.\n\n        Returns:\n            qc (QuantumCircuit): Circuit for initializing the state.\n        \"\"\"\n        state_string = ''.join('1' if char == '0' else '0' for char in state_string)\n        qr = QuantumRegister(num_qubits)\n        qc = QuantumCircuit(qr)\n        qc.initialize(state_string, qr[:])\n        return qc\n\n    def run_simulation(self, state_string, total_time, num_shots=100):\n        \"\"\"\n        Runs the Hadamard test simulation for the given initial state.\n\n        Parameters:\n            state_string (str): Binary string representing the initial state.\n            total_time (float): Total simulation time.\n            num_shots (int): Number of shots for circuit execution (default: 100).\n        \"\"\"\n        init_circuit = self.initialize_state(self.num_qubits, state_string)\n        self.time_range = np.arange(0, total_time + self.evolution_timestep,\n                                    self.evolution_timestep)\n\n        for idx, _ in enumerate(self.time_range):\n            print(f'Running dynamics step {idx}')\n\n            # Real component\n            qc_real = self.get_hadamard_test(init_circuit, idx, imag_expectation=False)\n            real_counts = self.execute_circuit(qc_real, num_shots)\n            real_amp = self.calculate_spin_correlation(real_counts)\n            self.real_amp_list.append(real_amp)\n\n            # Imaginary component\n            qc_imag = self.get_hadamard_test(init_circuit, idx, imag_expectation=True)\n            imag_counts = self.execute_circuit(qc_imag, num_shots)\n            imag_amp = self.calculate_spin_correlation(imag_counts)\n            self.imag_amp_list.append(imag_amp)\n\n            print(f'Finished step {idx}: Re = {real_amp:.3f}, Im = {imag_amp:.3f}')\n\n    def save_results(self, prefix):\n        \"\"\"\n        Saves the real and imaginary amplitudes, survival amplitude, and survival probability to files.\n\n        Parameters:\n            prefix (str): Prefix for the output file names.\n        \"\"\"\n        real_amp_array = np.array(self.real_amp_list)\n        imag_amp_array = np.array(self.imag_amp_list)\n\n        np.savetxt(f'{prefix}_real_amp.csv', real_amp_array, fmt='%.18e', delimiter=';')\n        np.savetxt(f'{prefix}_imag_amp.csv', imag_amp_array, fmt='%.18e', delimiter=';')\n        np.savetxt(f'{prefix}_abs_correlation.csv', np.abs(real_amp_array + 1j * imag_amp_array), fmt='%.18e', delimiter=';')\n        np.savetxt(f'{prefix}_sqrt_sum_squares.csv', np.sqrt(real_amp_array**2 + imag_amp_array**2), fmt='%.18e', delimiter=';')\n\n    def plot_results(self, prefix):\n        \"\"\"\n        Plots the survival amplitude and compares it with a reference.\n\n        Parameters:\n            prefix (str): Prefix for loading precomputed reference data.\n        \"\"\"\n        abs_corr = np.abs(np.array(self.real_amp_list) + 1j * np.array(self.imag_amp_list))\n\n        plt.plot(self.time_range, abs_corr, '.', label='Hadamard Test')\n        reference_filename = f'data/{self.num_qubits}_spin_chain_SA_obs.npy'\n        if os.path.exists(reference_filename):\n            ref_sa = np.load(f'data/{self.num_qubits}_spin_chain_SA_obs.npy')\n            ref_time = np.load(f'data/{self.num_qubits}_spin_chain_time.npy')\n        else:\n            print('No reference data file found!')\n        plt.plot(ref_time, ref_sa, '-', label='Statevector')\n\n        plt.xlabel('Time')\n        plt.ylabel(r\"$\\left|\\langle \\psi | \\psi (t)  \\rangle \\right|$\")\n        plt.tight_layout()\n        #plt.legend()\n        plt.show()\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsH.__init__","title":"<code>__init__(num_qubits, evolution_timestep, trotter_steps, hamiltonian_coefficients)</code>","text":"<p>Initializes the QuantumSimulation class with system parameters and sets up the simulator.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>int</code> <p>Number of qubits in the system.</p> required <code>hamiltonian_coefficients</code> <code>list</code> <p>Coefficients for the Hamiltonian terms.</p> required <code>evolution_timestep</code> <code>float</code> <p>Timestep for the time evolution operator.</p> required Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def __init__(self, num_qubits, evolution_timestep, trotter_steps, hamiltonian_coefficients):\n    \"\"\"\n    Initializes the QuantumSimulation class with system parameters and sets up the simulator.\n\n    Parameters:\n        num_qubits (int): Number of qubits in the system.\n        hamiltonian_coefficients (list): Coefficients for the Hamiltonian terms.\n        evolution_timestep (float): Timestep for the time evolution operator.\n    \"\"\"\n    self.num_qubits = num_qubits\n    self.hamiltonian_coefficients = hamiltonian_coefficients\n    self.evolution_timestep = evolution_timestep\n    self.trotter_steps = trotter_steps,\n    self.simulator = Aer.get_backend('qasm_simulator')\n    self.real_amp_list = []\n    self.imag_amp_list = []\n\n    self.time_evo_op = get_time_evolution_operator(\n        num_qubits=num_qubits,\n        tau=evolution_timestep,\n        trotter_steps=trotter_steps,\n        coeff=hamiltonian_coefficients\n    )\n    self.controlled_time_evo_op = self.time_evo_op.control()\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsH.calculate_spin_correlation","title":"<code>calculate_spin_correlation(counts)</code>  <code>staticmethod</code>","text":"<p>Calculates the spin correlation based on measurement counts.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>dict</code> <p>Measurement counts.</p> required <p>Returns:</p> Name Type Description <code>results</code> <code>float</code> <p>Average spin correlation.</p> Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>@staticmethod\ndef calculate_spin_correlation(counts):\n    \"\"\"\n    Calculates the spin correlation based on measurement counts.\n\n    Parameters:\n        counts (dict): Measurement counts.\n\n    Returns:\n        results (float): Average spin correlation.\n    \"\"\"\n    qubit_to_spin_map = {'0': 1, '1': -1}\n    total_counts = sum(counts.values())\n    values = [qubit_to_spin_map[k] * v for k, v in counts.items()]\n    return sum(values) / total_counts\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsH.execute_circuit","title":"<code>execute_circuit(qc, num_shots=100)</code>","text":"<p>Executes a quantum circuit using the Qiskit simulator and retrieves measurement counts.</p> <p>Parameters:</p> Name Type Description Default <code>qc</code> <code>QuantumCircuit</code> <p>The quantum circuit to execute.</p> required <code>num_shots</code> <code>int</code> <p>Number of shots for circuit execution (default: 100).</p> <code>100</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Measurement counts.</p> Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def execute_circuit(self, qc, num_shots=100):\n    \"\"\"\n    Executes a quantum circuit using the Qiskit simulator and retrieves measurement counts.\n\n    Parameters:\n        qc (QuantumCircuit): The quantum circuit to execute.\n        num_shots (int): Number of shots for circuit execution (default: 100).\n\n    Returns:\n        dict (dict): Measurement counts.\n    \"\"\"\n    job = execute(qc, self.simulator, shots=num_shots)\n    return job.result().get_counts()\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsH.get_hadamard_test","title":"<code>get_hadamard_test(initial_state, control_repeats, imag_expectation=False)</code>","text":"<p>Constructs the Hadamard test circuit to evaluate the real or imaginary components of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>QuantumCircuit</code> <p>Circuit for initializing the quantum state.</p> required <code>control_repeats</code> <code>int</code> <p>Number of times the controlled operation is applied.</p> required <code>imag_expectation</code> <code>bool</code> <p>Whether to evaluate the imaginary component (default: False).</p> <code>False</code> <p>Returns:</p> Name Type Description <code>qc</code> <code>QuantumCircuit</code> <p>The constructed Hadamard test circuit.</p> Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def get_hadamard_test(self, initial_state, control_repeats, imag_expectation=False):\n    \"\"\"\n    Constructs the Hadamard test circuit to evaluate the real or imaginary components of the operator.\n\n    Parameters:\n        initial_state (QuantumCircuit): Circuit for initializing the quantum state.\n        control_repeats (int): Number of times the controlled operation is applied.\n        imag_expectation (bool): Whether to evaluate the imaginary component (default: False).\n\n    Returns:\n        qc (QuantumCircuit): The constructed Hadamard test circuit.\n    \"\"\"\n    qr = QuantumRegister(self.num_qubits + 1)\n    cr = ClassicalRegister(1)\n    qc = QuantumCircuit(qr, cr)\n    qc.append(initial_state, qr[1:])\n    qc.barrier()\n\n    qc.h(0)\n    if imag_expectation:\n        qc.p(-np.pi / 2, 0)\n\n    for _ in range(control_repeats):\n        qc.append(self.controlled_time_evo_op, qr[:])\n\n    qc.h(0)\n    qc.barrier()\n    qc.measure(0, 0)\n    return qc\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsH.initialize_state","title":"<code>initialize_state(num_qubits, state_string)</code>  <code>staticmethod</code>","text":"<p>Creates a circuit to initialize the quantum state.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>int</code> <p>Number of qubits.</p> required <code>state_string</code> <code>str</code> <p>Binary string representing the initial state.</p> required <p>Returns:</p> Name Type Description <code>qc</code> <code>QuantumCircuit</code> <p>Circuit for initializing the state.</p> Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>@staticmethod\ndef initialize_state(num_qubits, state_string):\n    \"\"\"\n    Creates a circuit to initialize the quantum state.\n\n    Parameters:\n        num_qubits (int): Number of qubits.\n        state_string (str): Binary string representing the initial state.\n\n    Returns:\n        qc (QuantumCircuit): Circuit for initializing the state.\n    \"\"\"\n    state_string = ''.join('1' if char == '0' else '0' for char in state_string)\n    qr = QuantumRegister(num_qubits)\n    qc = QuantumCircuit(qr)\n    qc.initialize(state_string, qr[:])\n    return qc\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsH.plot_results","title":"<code>plot_results(prefix)</code>","text":"<p>Plots the survival amplitude and compares it with a reference.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix for loading precomputed reference data.</p> required Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def plot_results(self, prefix):\n    \"\"\"\n    Plots the survival amplitude and compares it with a reference.\n\n    Parameters:\n        prefix (str): Prefix for loading precomputed reference data.\n    \"\"\"\n    abs_corr = np.abs(np.array(self.real_amp_list) + 1j * np.array(self.imag_amp_list))\n\n    plt.plot(self.time_range, abs_corr, '.', label='Hadamard Test')\n    reference_filename = f'data/{self.num_qubits}_spin_chain_SA_obs.npy'\n    if os.path.exists(reference_filename):\n        ref_sa = np.load(f'data/{self.num_qubits}_spin_chain_SA_obs.npy')\n        ref_time = np.load(f'data/{self.num_qubits}_spin_chain_time.npy')\n    else:\n        print('No reference data file found!')\n    plt.plot(ref_time, ref_sa, '-', label='Statevector')\n\n    plt.xlabel('Time')\n    plt.ylabel(r\"$\\left|\\langle \\psi | \\psi (t)  \\rangle \\right|$\")\n    plt.tight_layout()\n    #plt.legend()\n    plt.show()\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsH.run_simulation","title":"<code>run_simulation(state_string, total_time, num_shots=100)</code>","text":"<p>Runs the Hadamard test simulation for the given initial state.</p> <p>Parameters:</p> Name Type Description Default <code>state_string</code> <code>str</code> <p>Binary string representing the initial state.</p> required <code>total_time</code> <code>float</code> <p>Total simulation time.</p> required <code>num_shots</code> <code>int</code> <p>Number of shots for circuit execution (default: 100).</p> <code>100</code> Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def run_simulation(self, state_string, total_time, num_shots=100):\n    \"\"\"\n    Runs the Hadamard test simulation for the given initial state.\n\n    Parameters:\n        state_string (str): Binary string representing the initial state.\n        total_time (float): Total simulation time.\n        num_shots (int): Number of shots for circuit execution (default: 100).\n    \"\"\"\n    init_circuit = self.initialize_state(self.num_qubits, state_string)\n    self.time_range = np.arange(0, total_time + self.evolution_timestep,\n                                self.evolution_timestep)\n\n    for idx, _ in enumerate(self.time_range):\n        print(f'Running dynamics step {idx}')\n\n        # Real component\n        qc_real = self.get_hadamard_test(init_circuit, idx, imag_expectation=False)\n        real_counts = self.execute_circuit(qc_real, num_shots)\n        real_amp = self.calculate_spin_correlation(real_counts)\n        self.real_amp_list.append(real_amp)\n\n        # Imaginary component\n        qc_imag = self.get_hadamard_test(init_circuit, idx, imag_expectation=True)\n        imag_counts = self.execute_circuit(qc_imag, num_shots)\n        imag_amp = self.calculate_spin_correlation(imag_counts)\n        self.imag_amp_list.append(imag_amp)\n\n        print(f'Finished step {idx}: Re = {real_amp:.3f}, Im = {imag_amp:.3f}')\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.SpinDynamicsH.save_results","title":"<code>save_results(prefix)</code>","text":"<p>Saves the real and imaginary amplitudes, survival amplitude, and survival probability to files.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix for the output file names.</p> required Source code in <code>src/qflux/closed_systems/spin_dynamics_oo.py</code> <pre><code>def save_results(self, prefix):\n    \"\"\"\n    Saves the real and imaginary amplitudes, survival amplitude, and survival probability to files.\n\n    Parameters:\n        prefix (str): Prefix for the output file names.\n    \"\"\"\n    real_amp_array = np.array(self.real_amp_list)\n    imag_amp_array = np.array(self.imag_amp_list)\n\n    np.savetxt(f'{prefix}_real_amp.csv', real_amp_array, fmt='%.18e', delimiter=';')\n    np.savetxt(f'{prefix}_imag_amp.csv', imag_amp_array, fmt='%.18e', delimiter=';')\n    np.savetxt(f'{prefix}_abs_correlation.csv', np.abs(real_amp_array + 1j * imag_amp_array), fmt='%.18e', delimiter=';')\n    np.savetxt(f'{prefix}_sqrt_sum_squares.csv', np.sqrt(real_amp_array**2 + imag_amp_array**2), fmt='%.18e', delimiter=';')\n</code></pre>"},{"location":"qflux/Closed_Systems/qho_example/","title":"Your first simulation: The Quantum Harmonic Oscillator","text":"<p>In this guided tutorial, we will look at the closed-system quantum dynamics of a coherent state in a harmonic potential as implemented with <code>qflux</code>.</p> <p>We will first show how to compute the dynamics in the qubit-basis, illustrating the approach for running a quantum dynamics simulation on a qubit-based quantum device. Then, we will look at two classical implementations for computing the dynamics, as a means of validating our results.</p>"},{"location":"qflux/Closed_Systems/qho_example/#propagation-in-the-qubit-basis","title":"Propagation in the Qubit Basis","text":"<p>We begin by importing the necessary utilities from <code>qflux</code>:</p> <pre><code>import sys\nfrom qflux.closed_systems import DynamicsCS, QubitDynamicsCS\n</code></pre> <p>Now, we can instantiate our QubitDynamics object:</p> <pre><code>HO_dyn_obj = QubitDynamicsCS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)\n</code></pre> <p>Now that we have our dynamics object, we must define our discretized coordinate space and initialize our coordinate operators:</p> <pre><code>HO_dyn_obj.set_coordinate_operators(x_min=-7.0, x_max=7.0, reorder_p=True)\nHO_dyn_obj.initialize_operators()\n</code></pre> <p>Now that we've defined a grid for our simulation, we can construct our initial coherent state:</p> <pre><code>HO_dyn_obj.set_initial_state(wfn_omega=1.0)\n</code></pre> <p>And we can define our harmonic oscillator hamiltonian (built-in to <code>qflux</code>):</p> <pre><code>HO_dyn_obj.set_hamiltonian(potential_type='harmonic')\n</code></pre> <p>Now that we have defined our system parameters and initial state, we should define a propagation time. In the following, we propagate for a total time of 20.0 a.u., divided into 400 evenly spaced steps.</p> <pre><code>total_time = 20.0\nN_steps    = 400\nHO_dyn_obj.set_propagation_time(total_time, N_steps)\n</code></pre> <p>Now we are ready to propagate!</p>"},{"location":"qflux/Closed_Systems/qho_example/#propagation-with-statevector-simulator","title":"Propagation with Statevector Simulator","text":"<p>Here we demonstrate how to compute the dynamics according to the qubit-SOFT method with <code>qiskit</code>'s <code>statevector_simulator</code> backend:</p> <pre><code># Now we must set the backend prior to calling propagate qSOFT\nfrom qiskit_aer import Aer\nbackend = Aer.get_backend('statevector_simulator')\nHO_dyn_obj.propagate_qSOFT(backend=backend, n_shots=1024)\n</code></pre> <p>Note: the <code>propagate_qSOFT</code> method does the following things under the hood: - Construction of the quantum circuit - Arbitrary state initialization from our grid-based coherent state - Conversion of the unitary operators from the SOFT method (see the section below for details) into Pauli gates - Application of the Quantum Fourier Transform and inverse Quantum Fourier Transform for conversion between position and momentum space - Collection of the state at each time-step of the dynamics</p>"},{"location":"qflux/Closed_Systems/qho_example/#analyzing-the-results","title":"Analyzing the Results","text":"<p>The first thing we can do is to check the state initialization in the quantum circuit formalism. To do this, we can plot initial state in the qubit basis and compare to the state in the coordinate basis:</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.figure()\nplt.plot(HO_dyn_obj.x_grid, HO_dyn_obj._PE_grid)\nplt.plot(HO_dyn_obj.x_grid,\n         np.real(HO_dyn_obj.psio_grid.conj() * HO_dyn_obj.psio_grid),\n         color='k', label=r'$\\left| \\psi_{0} \\right|^{2}$ (Grid)')\nplt.plot(HO_dyn_obj.x_grid,\n         np.real(HO_dyn_obj.dynamics_results_qubit[0].conj() *\n                 HO_dyn_obj.dynamics_results_qubit[0].conj())/HO_dyn_obj.dx,\n         marker='x', lw=0, markevery=2, label=r'$\\left| \\psi_{0} \\right|^{2}$ (Qubit)')\nplt.ylim(-.05, 1.0)\nplt.legend()\nplt.xlim(-3.5, 3.5)\nplt.xlabel(r'$x$')\nplt.tight_layout()\n</code></pre> <p></p> <p>To compare the dynamics, we can calculate and plot the expectation value over time for the qSOFT and SOFT results with the analytical expressions:</p> <pre><code>import numpy as np\nfrom qflux.closed_systems.utils import calculate_expectation_values\n\nqubit_exp_x_soft = calculate_expectation_values(HO_dyn_obj.dynamics_results_qubit, HO_dyn_obj.x_grid, dx=1)\ngrid_exp_x_soft = calculate_expectation_values(HO_dyn_obj.dynamics_results_grid, HO_dyn_obj.x_grid)\n\nqubit_exp_p_soft = calculate_expectation_values(HO_dyn_obj.dynamics_results_qubit, HO_dyn_obj.p_grid, dx=1., do_FFT=True)\ngrid_exp_p_soft = calculate_expectation_values(HO_dyn_obj.dynamics_results_grid, HO_dyn_obj.p_grid, dx=HO_dyn_obj.dx, do_FFT=True)\n\nexp_x_ana = HO_dyn_obj.xo*np.cos(HO_dyn_obj.omega*HO_dyn_obj.tlist) + (HO_dyn_obj.po/HO_dyn_obj.mass/HO_dyn_obj.omega)*np.sin(HO_dyn_obj.omega*HO_dyn_obj.tlist)\nexp_p_ana = HO_dyn_obj.po*np.cos(HO_dyn_obj.omega*HO_dyn_obj.tlist) - HO_dyn_obj.xo*HO_dyn_obj.omega*HO_dyn_obj.mass*np.sin(HO_dyn_obj.omega*HO_dyn_obj.tlist)\n\n# Plot expectation value, compare to analytic expression\nplt.figure(figsize=(9, 6.5))\nplt.plot(HO_dyn_obj.tlist, grid_exp_x_soft, label=r'$\\left\\langle x \\right\\rangle$ (SOFT)', color='dodgerblue')\nplt.plot(HO_dyn_obj.tlist, qubit_exp_x_soft, label=r'$\\left\\langle x \\right\\rangle$ (qSOFT)',\n         lw=0, marker='x', markevery=10, color='dodgerblue', ms=8, zorder=1)\nplt.plot(HO_dyn_obj.tlist, exp_x_ana, label=r'$\\left\\langle x \\right\\rangle$ (Analytic)',\n         lw=0, marker='o', markevery=10, color='dodgerblue', ms=8, fillstyle='none')\nplt.plot(HO_dyn_obj.tlist, grid_exp_p_soft, label=r'$\\left\\langle p \\right\\rangle$ (SOFT)', color='crimson')\nplt.plot(HO_dyn_obj.tlist, qubit_exp_p_soft, label=r'$\\left\\langle p \\right\\rangle$ (qSOFT)',\n         lw=0, marker='x', markevery=10, color='crimson', ms=8, zorder=1)\nplt.plot(HO_dyn_obj.tlist, exp_p_ana, label=r'$\\left\\langle p \\right\\rangle$ (Analytic)',\n         lw=0, marker='o', markevery=10, color='crimson', ms=8, fillstyle='none')\nplt.ylim(-1.55, 1.55)\n\nplt.legend(ncols=2, loc='upper center', fontsize=14)\nplt.hlines([-1, 0, 1], min(HO_dyn_obj.tlist), max(HO_dyn_obj.tlist), ls='--', lw=0.85, color='tab:grey', zorder=2)\nplt.xlim(min(HO_dyn_obj.tlist), max(HO_dyn_obj.tlist))\nplt.ylabel('Expectation Value')\nplt.xlabel('Time')\nplt.tight_layout()\n</code></pre> <p></p>"},{"location":"qflux/Closed_Systems/qho_example/#propagation-with-a-real-backend","title":"Propagation with a Real Backend","text":"<p>You can repeat the previous section and run on a real quantum device by changing the specification of the backend! Recall that we instantiated a StatevectorSimulator backend before running the dynamics calculation above. To run on a real device, we must first instantiate a backend instance using a real device. This can be done with the following code:</p> <pre><code># To use a real backend:\nfrom qiskit_ibm_runtime import QiskitRuntimeService, fake_provider\n# # If you did not previously save your credentials, use the following line:\nMY_API_TOKEN = \"INSERT_IBMQ_API_TOKEN_HERE\"\nservice = QiskitRuntimeService(channel=\"ibm_quantum\", token=MY_API_TOKEN, instance='ibm-q/open/main')\n# Save your credentials:\nservice.save_account(name='b-ibmq', token=MY_API_TOKEN, channel='ibm_quantum', overwrite=True)\nbackend = service.least_busy(simulator=False, operational=True)\n</code></pre> <p>Now, we can run the following code to do the dynamics calculation with <code>qflux</code>:</p> <pre><code>HO_dyn_obj = QubitDynamicsCS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)\nHO_dyn_obj.set_coordinate_operators(x_min=-7.0, x_max=7.0, reorder_p=True)\nHO_dyn_obj.initialize_operators()\nHO_dyn_obj.set_initial_state(wfn_omega=1.0)\n\nHO_dyn_obj.set_hamiltonian(potential_type='harmonic')\n\ntotal_time = 20.0\nN_steps    = 400\nHO_dyn_obj.set_propagation_time(total_time, N_steps)\nHO_dyn_obj.propagate_qt()\nHO_dyn_obj.propagate_SOFT()\nHO_dyn_obj.propagate_qSOFT(backend=backend, n_shots=1024)\n</code></pre>"},{"location":"qflux/Closed_Systems/qho_example/#propagation-in-the-ladder-basis","title":"Propagation in the Ladder Basis","text":"<p>We'll now show how to validate the dynamics we calculated in the previous section with classical simulations.</p> <p>When we run dynamics, we must do the following:</p> <ol> <li> <p>Define the initial state \\(\\left| \\alpha \\right\\rangle\\). In this example, our initial state is defined as a coherent state with amplitude \\(\\alpha = x_{0} + i p_{0}\\), which can be expressed in the Fock Basis as:</p> \\[ \\left| \\alpha \\right\\rangle = \\frac{\\alpha^{n}}{\\sqrt{n!}} e^{-\\frac{1}{2}\\left| \\alpha \\right|^{2}} \\left| n \\right\\rangle \\] </li> <li> <p>Define the Hamiltonian \\(H\\). In this example, our Hamiltonian is the familiar quantum harmonic oscillator Hamiltonian, defined in terms of creation and annihilation operators as:</p> \\[ H =  \\hbar \\omega \\left( \\hat{a}^{\\dagger} \\hat{a} + \\frac{1}{2} \\right) \\] </li> <li> <p>Define the propagation time step \\(t\\) and the number of time steps \\(n\\) for which to compute the wavefunction.</p> </li> <li> <p>Compute the time-evolved wavefunction at each step as:</p> \\[ \\left| \\alpha (t_{i+1}) \\right\\rangle = e^{-\\frac{i}{\\hbar} H t} \\left| \\alpha(t_{i}) \\right\\rangle \\] </li> </ol> <p>All this can be done using QFlux as follows:</p> <pre><code># Import the package and relevant modules\nimport qflux\nfrom qflux.closed_systems import DynamicsCS\n# Instantiate our Closed-Systems Dynamics Class\nqho_dyn_obj = DynamicsCS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)\n# Define our coordinate x and p operators\nqho_dyn_obj.set_coordinate_operators()\n# Initialize the ladder operators\nqho_dyn_obj.initialize_operators()\n# Define the default initial state (note that custom initialization is also supported)\nqho_dyn_obj.set_initial_state()\n# Define some parameters for the time evolution\ntotal_time = 20.0\nN_steps = 400\nqho_dyn_obj.set_propagation_time(total_time, N_steps)\n# Set the Potential/Hamiltonian for our object, in this case using the pre-defined 'harmonic' oscillator potential\nqho_dyn_obj.set_hamiltonian(potential_type='harmonic')\n# Propagate using the QuTiP sesolve method\nqho_dyn_obj.propagate_qt()\n</code></pre> <p>We can validate our result by computing and plotting the expectation values of \\(x\\) and \\(p\\) as a function of time and comparing to the analytic results:</p> <pre><code>import qutip as qt\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Compute expectation values &lt;x&gt; and &lt;p&gt;\nexp_x_qt = qt.expect(qho_dyn_obj.x_op, qho_dyn_obj.dynamics_results_op.states)\nexp_p_qt = qt.expect(qho_dyn_obj.p_op, qho_dyn_obj.dynamics_results_op.states)\n\nexp_x_ana = [ qho_dyn_obj.xo*np.cos(qho_dyn_obj.omega*t) + (qho_dyn_obj.po/qho_dyn_obj.mass/qho_dyn_obj.omega)*np.sin(qho_dyn_obj.omega*t) for t in qho_dyn_obj.tlist]\nexp_p_ana = [ qho_dyn_obj.po*np.cos(qho_dyn_obj.omega*t) -qho_dyn_obj.xo*qho_dyn_obj.omega*qho_dyn_obj.mass*np.sin(qho_dyn_obj.omega*t)  for t in qho_dyn_obj.tlist]\n\n# Plot the final result\nplt.figure(figsize=(9, 6.5))\nplt.plot(qho_dyn_obj.tlist, exp_x_qt, label=r'$\\left\\langle x \\right\\rangle$ (QuTiP)', color='dodgerblue')\nplt.plot(qho_dyn_obj.tlist, exp_x_ana, label=r'$\\left\\langle x \\right\\rangle$ (Analytic)',\n         lw=0, marker='x', markevery=10, color='dodgerblue', ms=8)\nplt.plot(qho_dyn_obj.tlist, exp_p_qt, label=r'$\\left\\langle p \\right\\rangle$ (QuTiP)', color='crimson')\nplt.plot(qho_dyn_obj.tlist, exp_p_ana, label=r'$\\left\\langle p \\right\\rangle$ (Analytic)',\n         lw=0, marker='x', markevery=10, color='crimson', ms=8)\n\nplt.ylim(-1.55, 1.55)\n\nplt.legend(ncols=2, loc='upper center')\nplt.hlines([-1, 0, 1], min(qho_dyn_obj.tlist), max(qho_dyn_obj.tlist), ls='--', lw=0.85, color='tab:grey', zorder=2)\n</code></pre> <p></p> <p>Hopefully the agreement in this plot convinces you that we're doing something correct!</p>"},{"location":"qflux/Closed_Systems/qho_example/#propagation-in-the-coordinate-basis","title":"Propagation in the Coordinate Basis","text":"<p>We can also propagate a wavefunction in a coordinate-grid representation using the so-called Split-Operator Fourier Transform (SOFT) method.</p> <p>\\(\\renewcommand{\\intertext}[1]{\\\\\\ \\textrm{#1}\\\\}\\)</p> <p>Here, we compute the time-evolution of a wavepacket defined in the position basis (\\(\\psi(x)\\)) according to the Split-Operator Fourier Transform (SOFT) method. This differs slightly from the approach utilized in the last section in the following ways:</p> <ul> <li>As mentioned above, we will describe the wavefunction in terms of the position. To do this, we must define a closed range of positions \\(x\\) and momenta \\(p\\) and discretize over some finite number of points (analagous to the finite number of Fock states considered above).</li> <li>We will compute the time evolution as:</li> </ul> \\[ \\left| \\psi (t) \\right\\rangle =  e^{- \\frac{i}{\\hbar} {H} t} \\left| \\psi(0) \\right\\rangle \\] <p>Writing \\(H\\) in terms of Kinetic and Potential energy \\(H = T + V\\):</p> \\[\\begin{align*}         \\left| \\psi (t) \\right\\rangle &amp;\\approx \\lim\\limits_{N\\to\\infty} \\left[e^{\\frac{-ip^2t}{2m\\hbar N}}\\ e^{\\frac{-i{V}({x})t}{\\hbar N}}\\right]^N \\space |\\psi(0)\\rangle \\\\                                   &amp;\\approx\\lim\\limits_{N\\to\\infty} \\left[e^{\\frac{-i{V}({x})t}{2\\hbar N}}\\space e^{\\frac{-ip^2t}{2m\\hbar N}}\\space e^{\\frac{-i{V}({x})t}{2\\hbar N}}\\right]^N \\space |\\psi(0)\\rangle     \\intertext{Inserting closure and writing in the plane-wave basis: }      \\left| \\psi (x, t) \\right\\rangle &amp;= \\int d x_0 \\space \\langle x_t | e^{\\frac{-i\u0124t}{\\hbar}} | x_0 \\rangle \\space \\langle x_0 | \\psi(0) \\rangle \\end{align*}\\] <p>Propagation for a single timestep is then:</p> \\[\\psi(x,\\frac{t_{i+1}}{N}) = \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} e^{\\frac{-iV(x)t}{2\\hbar N}} }^\\textrm{P.E. Propagator} \\ \\cdot \\ \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} { \\int \\frac{dp}{\\sqrt{2\\pi\\hbar}}  \\   e^{\\frac{-ipx}{\\hbar}}} }^\\textrm{Inverse Fourier Transform} \\ \\cdot \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} \\ e^{\\frac{-ip^2t}{2m\\hbar N}}}^\\textrm{K.E. Propagator} \\ \\cdot \\ \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} {\\int \\frac{dx}{\\sqrt{2\\pi\\hbar}} \\  e^{\\frac{ipx}{\\hbar}} }}^\\textrm{Fourier Transform} \\ \\cdot \\ \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}}\\ e^{\\frac{-iV(x)t}{2\\hbar N}} }^\\textrm{P.E. Propagator} \\ \\cdot \\ \\psi(x,t_{i})\\] <p>The Fourier and inverse Fourier transforms are used to convert between the position and momentum basis. To translate the formula above, the algorithm will consist of 5 steps per iteration:</p> <ol> <li>Apply a half step of the potential energy propagator to the initial state.</li> <li>Fourier transform into the momentum basis.</li> <li>Apply a full step of the kinetic energy propagator on the momentum basis.</li> <li>Inverse Fourier transform back into the coordinate basis.</li> <li>Apply the second half step of the potential energy propagator.</li> </ol> <p>This is can be done in QFlux with the following code:</p> <pre><code># Instantiate our Closed-Systems Dynamics Class\nqho_dyn_obj = QFlux_CS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)\n# Define our coordinate x and p operators\nqho_dyn_obj.set_coordinate_operators()\n# Initialize the ladder operators\nqho_dyn_obj.initialize_operators()\n# Define the default initial state (note that custom initialization is also supported)\nqho_dyn_obj.set_initial_state()\n# Define some parameters for the time evolution\ntotal_time = 20.0\nN_steps = 400\nqho_dyn_obj.set_propagation_time(total_time, N_steps)\n# Set the Potential/Hamiltonian for our object, in this case using the pre-defined 'harmonic' oscillator potential\nqho_dyn_obj.set_hamiltonian(potential_type='harmonic')\n# Propagate using the QuTiP sesolve method\nqho_dyn_obj.propagate_qt()\n# Propagate with SOFT and QuTiP\nqho_dyn_obj.propagate_SOFT()\n</code></pre>"},{"location":"qflux/Closed_Systems/spinchain/","title":"Simulation of a Spin-Chain System","text":""},{"location":"qflux/Closed_Systems/spinchain/#motivation","title":"Motivation","text":"<p>This section demonstrates the practical considerations for perfoming dynamical evolution of an Hamiltonian written in the basis of Pauli matrices using a qubit-based quantum computer framework. The chosen Hamiltonian can be used to describe the chemical process of electron transfer across a chromophore chain, with the onsite parameters describing the strength of the electronic affinity at each chromophore and off-site couplings describing the barrier for transferring an electron between adjacent sites.</p> <p></p> <p>A problem of practical interest that could be modelled by this method would be a functionalized graphene nanoribbon, where alternating sites contain radical character (Nano Lett. 2022, 22, 1, 164\u2013171).</p> <p></p> <p>The stability of the radical character at each site can be described by the on-site parameter (\\(\\Omega _n\\)) and the coupling between sites (\\(J _{n,n+1}\\)) governed by the properties of the linker regions containing the diketone groups. These parameters can be tuned by synthetic design of each component part of the nanoribbon.</p> \\[\\begin{align} H=  \\sum_{n=0}^{N-1} \\hbar \\Omega _n \\sigma_n ^z - \\dfrac{1}{2} \\sum_{n=0}^{N-2} \\big(J_{n,n+1}^x \\hat{\\sigma}_{n}^x \\hat{\\sigma}_{n+1}^x + J_{n,n+1}^y \\hat{\\sigma}_{n}^y \\hat{\\sigma}_{n+1}^y + J_{n,n+1}^z \\hat{\\sigma}_{n}^z \\hat{\\sigma}_{n+1}^z \\big) \\end{align}\\] <p>Protocol for Hamiltonian evolution in a quantum computer framework:</p> <ol> <li>Construct Hamiltonian operator (sum of tensor product of Pauli matrices)</li> <li>Construct Trotter approximation of time-evolution operator (\\(e^{-i\\hat{H}t}\\))</li> <li>Construct circuit corresponding to time-evolution operator</li> <li>Construct circuit for initial state</li> <li>Combine the initial state and time-evolution circuits</li> <li>Execute combined circuit</li> <li>Measure final state</li> <li>Computing observables with Hadamard test (correlation function and observables)</li> </ol>"},{"location":"qflux/Closed_Systems/spinchain/#model-hamiltonian-and-parameters","title":"Model Hamiltonian and Parameters","text":"<p>Here we use as an example the Hamiltonian for the Heisenberg model, defined as follows:</p> \\[\\begin{align} H=  \\sum_{n=0}^{N-1} \\hbar \\Omega _n \\sigma_n ^z - \\dfrac{1}{2} \\sum_{n=0}^{N-2} \\big(J_{n,n+1}^x \\hat{\\sigma}_{n}^x \\hat{\\sigma}_{n+1}^x + J_{n,n+1}^y \\hat{\\sigma}_{n}^y \\hat{\\sigma}_{n+1}^y + J_{n,n+1}^z \\hat{\\sigma}_{n}^z \\hat{\\sigma}_{n+1}^z \\big) \\end{align}\\] <p>where the coupling elements are described in terms of the \\(\\sigma _x, \\sigma _y, \\sigma _z\\) (Pauli X, Y and Z) matrices with a coupling associated with each type of interaction term for each site/pair of sites. We consider the following parameters, as used in the publication Non-Markovian decay beyond the Fermi Golden Rule: Survival Collapse of the polarization in spin chains.(but with reduced number of spin sites):</p> \\[\\begin{align}     N &amp;= 3 \\\\     \\hbar \\Omega _0 &amp;= 0.65 \\\\     \\hbar \\Omega _n &amp;= 1.0, \\; n &gt; 0 \\\\     J_{0,1}^x = J_{1,0}^y &amp;= 0.75 \\\\     J_{n,n+1}^x = J_{n,n+1}^y &amp;= 1.0, \\; n &gt; 0  \\\\     J_{n,n+1}^z &amp;= 0, \\; \\forall n \\\\ \\end{align}\\] <p>for a chain of \\(N=3\\) spins and an initial state with the first spin up, \\(| \\uparrow \\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\), and the remaining spins down, \\(| \\downarrow \\rangle = \\begin{bmatrix} 0 \\\\ 1\\end{bmatrix}\\). Although the dynamics of this Hamiltonian can be simulated in a classical computer, we could also use quantum computer to simulate this same problem. One way to do so is by harnessing Qiskit, a python library containing functions that ease the simulation of the problem in quantum device framework.</p>"},{"location":"qflux/Closed_Systems/spinchain/#statevector-simulation","title":"Statevector Simulation","text":"<pre><code>from qflux.closed_systems.spin_propagators import * \nfrom qflux.closed_systems.hamiltonians import * \nfrom qflux.closed_systems.spin_dynamics_oo import * \n\nnum_q = 3\nevolution_timestep = 0.1\nn_trotter_steps = 1\nhamiltonian_coefficients = [[0.75 / 2, 0.75 / 2, 0.0, 0.65]] + [[0.5, 0.5, 0.0, 1.0]\n                            for _ in range(num_q - 1)]\ninitial_state = \"011\"  # Specify the initial state as a binary string\n\ncsimulation = SpinDynamicsS(\n                            num_q,\n                            evolution_timestep,\n                            n_trotter_steps,\n                            hamiltonian_coefficients\n                            )\ncsimulation.run_dynamics(nsteps=250, state_string=initial_state)\ncsimulation.save_results(f\"{num_q}_spin_chain\")\ncsimulation.plot_results(f\"{num_q}_spin_chain_statevector\")\n</code></pre>"},{"location":"qflux/Closed_Systems/spinchain/#quantum-circuit-simulation-with-hadamard-test","title":"Quantum Circuit Simulation with Hadamard Test","text":"<pre><code>num_q = 3\nevolution_timestep = 0.1\nn_trotter_steps = 1\nhamiltonian_coefficients = [[0.75 / 2, 0.75 / 2, 0.0, 0.65]] + [[0.5, 0.5, 0.0, 1.0]\n                            for _ in range(num_q - 1)]\ninitial_state = \"011\"  # Specify the initial state as a binary string\n\nqsimulation = SpinDynamicsH(\n                            num_q,\n                            evolution_timestep,\n                            n_trotter_steps,\n                            hamiltonian_coefficients\n                            )\nqsimulation.run_simulation(state_string=initial_state, total_time=25, num_shots=100)\nqsimulation.save_results('hadamard_test')\nqsimulation.plot_results('hadamard_test')\n</code></pre>"},{"location":"qflux/GQME/","title":"GQME Documentation and User Guide","text":"<p>This section includes documentation and tutorials focused on illustrating the usage and versatility of the <code>qflux.GQME</code> module. </p>"},{"location":"qflux/GQME/#overview","title":"Overview","text":"<p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the generalized quantum master equation (GQME). Then we provide some illustrative examples that demonstrate how the <code>qflux</code> can be used to solving the GQME. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/GQME/#examples-and-introductory-concepts","title":"Examples and Introductory Concepts","text":"<p>Our documentation includes the following sections:</p> <ul> <li>Introduction to GQME</li> <li>Introduction to TT-TFD</li> <li>GQME for Spin-Boson model</li> <li>Quantum Algorithms of GQME</li> </ul>"},{"location":"qflux/GQME/What_is_GQME/","title":"Introduction to GQME","text":"<p>In realistic physical and chemical processes, the system of interest is typically in contact with a thermal environment. This environment involves an enormous number of degrees of freedom\u2014for example, think of the countless solvent molecules in a solution, on the order of Avogadro\u2019s number\u2014making it infeasible to solve the full quantum dynamics directly. However, we are not interested in the environment for its own sake, but only insofar as it influences the dynamics of the system.</p> <p>One natural strategy is to derive an equation of motion for the system alone, by effectively tracing out the environmental degrees of freedom. Such closed-form equations of motion for the reduced system are known as quantum master equations.</p> <p>The Generalized Quantum Master Equation (GQME) is a formally exact framework for simulating reduced quantum dynamics by projecting the full Liouville-von Neumann equation onto a relevant subsystem.</p> <p>In this documentation, we focus on the well-known Nakajima-Zwanzig GQME (Nakajima, S. Prog. Theor. Phys. 1958, Zwanzig, R. J. Chem. Phys. 1960):</p> \\[ \\frac{d}{dt}\\hat{\\sigma}(t) = -\\frac{i}{\\hbar}\\langle \\mathcal{L}\\rangle_{n}^{0}\\hat{\\sigma}(t) - \\int_{0}^{t} d\\tau\\, \\mathcal{K}(\\tau)\\hat{\\sigma}(t - \\tau) + \\mathcal{I}(t) \\] <ul> <li>\\(\\hat{\\sigma}\\): reduced density matrix of the subsystem of interest.</li> <li>\\(\\langle \\mathcal{L}\\rangle_{n}^{0}\\): the projected Liouvillian.</li> <li>\\(\\mathcal{K}(t)\\): memory kernel, contains all the memory effects from the bath.</li> <li>\\(\\mathcal{I}(t)\\): inhomogeneous term (often vanishes for factorized initial states).</li> </ul> <p>In the following, we briefly outline its derivation and the meaning of each term. For a detailed derivation, see this paper.</p>"},{"location":"qflux/GQME/What_is_GQME/#derivation-of-the-nakajimazwanzig-equation","title":"Derivation of the Nakajima\u2013Zwanzig Equation","text":"<p>We begin with the quantum Liouville\u2013von Neumann equation, which governs the time evolution of the total system density operator:</p> \\[ \\frac{d}{dt} \\hat{\\rho}(t) = -\\frac{i}{\\hbar} [\\hat{H}, \\hat{\\rho}(t)] \\equiv -i \\mathcal{L} \\hat{\\rho}(t), \\] <p>where \\(\\mathcal{L} \\equiv \\hbar^{-1}[\\hat{H}, \\cdots]\\) is the Liouvillian superoperator.</p> <p>Now suppose we are only interested in a particular subsystem \\(S\\) while treating the rest of the system as the surrounding environment \\(B\\). The total Hamiltonian can then be partitioned as:</p> \\[ \\hat{H} = \\hat{H}_{S} + \\hat{H}_{B} + \\hat{H}_{I} \\] <p>where \\(\\hat{H}_{S}\\) and \\(\\hat{H}_{B}\\) are the system and bath Hamiltonians, respectively, and \\(\\hat{H}_{I}\\) denotes their interaction.</p> <p>To derive an equation of motion for the subsystem alone, we introduce a projection operator \\(\\mathcal{P}\\)  that projects any operator onto the relevant subspace (i.e., the part we care about). Its complement is given by \\(\\mathcal{Q} = 1 - \\mathcal{P}\\).</p> <p>Applying these projectors to both sides of the Liouville equation yields a pair of coupled equations:</p> \\[ \\frac{d}{dt} \\mathcal{P} \\hat{\\rho}(t) = -i \\mathcal{P} \\mathcal{L} \\mathcal{P} \\hat{\\rho}(t) - i \\mathcal{P} \\mathcal{L} \\mathcal{Q} \\hat{\\rho}(t), \\] \\[ \\frac{d}{dt} \\mathcal{Q} \\hat{\\rho}(t) = -i \\mathcal{Q} \\mathcal{L} \\mathcal{P} \\hat{\\rho}(t) - i \\mathcal{Q} \\mathcal{L} \\mathcal{Q} \\hat{\\rho}(t). \\] <p>These equations describe how the projected components \\(\\mathcal{P} \\hat{\\rho}(t)\\) and \\(\\mathcal{Q} \\hat{\\rho}(t)\\) evolve and interact over time.</p> <p>Formally solving the second equation gives:</p> \\[ \\mathcal{Q} \\hat{\\rho}(t) = e^{-i \\mathcal{Q} \\mathcal{L} (t - t_{0})} \\mathcal{Q} \\hat{\\rho}(t_{0}) - i \\int_{t_{0}}^{t} d\\tau\\, e^{-i \\mathcal{Q} \\mathcal{L} (t - \\tau)} \\mathcal{Q} \\mathcal{L} \\mathcal{P} \\hat{\\rho}(\\tau) \\] <p>Substituting this solution back into the first equation yields a formally closed equation for the relevant component \\(\\mathcal{P} \\hat{\\rho}(t)\\):</p> \\[ \\frac{d}{dt} \\mathcal{P} \\hat{\\rho}(t) = -i \\mathcal{P} \\mathcal{L}\\mathcal{P} \\hat{\\rho}(t) - \\int_{t_{0}}^{t} d\\tau\\, \\mathcal{P} \\mathcal{L} e^{-i \\mathcal{Q} \\mathcal{L}(t - \\tau)} \\mathcal{Q} \\mathcal{L} \\mathcal{P} \\hat{\\rho}(\\tau) - i \\mathcal{P} \\mathcal{L} e^{-i \\mathcal{Q} \\mathcal{L}(t - t_{0})} \\mathcal{Q} \\hat{\\rho}(t_{0}) \\] <p>This is the Nakajima-Zwanzig GQME with:</p> <ul> <li>\\(\\hat{\\sigma}(t) \\equiv \\mathcal{P} \\hat{\\rho}(t)\\)  the reduced density matrix,</li> <li>\\(\\mathcal{K}(t)\\equiv \\mathcal{P} \\mathcal{L} e^{-i \\mathcal{Q} \\mathcal{L}(t - \\tau)} \\mathcal{Q} \\mathcal{L} \\mathcal{P}\\) the memory kernel,</li> <li>\\(\\hbar^{-1}\\langle \\mathcal{L}\\rangle_{n}^{0}\\equiv \\mathcal{P} \\mathcal{L} \\mathcal{P}\\) the projected Liouvillian, which governs the system's unitary evolution in the absence of coupling to the bath,</li> <li>\\(\\mathcal{I}(t) \\equiv - i \\mathcal{P} \\mathcal{L} e^{-i \\mathcal{Q} \\mathcal{L}(t - t_{0})} \\mathcal{Q} \\hat{\\rho}(t_{0})\\) the inhomogeneous term.</li> </ul> <p>This equation serves as the formal foundation for computing reduced system dynamics with full inclusion of environment-induced memory effects.</p>"},{"location":"qflux/GQME/What_is_GQME/#gqme-for-molecular-systems","title":"GQME for molecular systems","text":"<p>For molecular systems with an overall Hamiltonian of the following form:</p> \\[ \\hat{H} = \\sum_{j=1}^{N_{e}} \\hat{H}_{j} (\\hat{\\mathbf{R}}, \\hat{\\mathbf{P}}) \\left| j\\right \\rangle \\left\\langle j \\right| + \\sum_{\\substack{j,k = 1 \\\\ k \\neq j}}^{N_{e}} \\hat{V}_{jk}(\\hat{\\mathbf{R}}) \\left| j \\right\\rangle\\left\\langle k \\right| \\] <p>Here, \\(\\hat{H}_{j} (\\hat{\\mathbf{R}},\\hat{\\mathbf{P}}) = \\hat{\\mathbf{P}}^2/2+ V_{j}(\\hat{\\mathbf{R}})\\) is the nuclear Hamiltonian when the system is in the electronic state \\(| j \\rangle\\), with the index \\(j\\) running over the \\(N_{e}\\) electronic states; \\(\\{ \\hat{V}_{jk} (\\hat{\\mathbf{R}})| j \\neq k \\}\\) are coupling terms between electronic states; and \\(\\hat{\\mathbf{R}} = \\{\\hat{R}_1,\\hat{R}_2,...,\\hat{R}_{N_{n}} \\}\\) and \\(\\hat{\\mathbf{P}} = \\{\\hat{P}_1,\\hat{P}_2,...,\\hat{P}_{N_{n}} \\}\\) are the mass-weighted position and momentum operators of the \\(N_{n}\\) nuclear degrees of freedom (DOFs).</p> <p>We choose the total initial state to be a product state:</p> \\[ \\hat{\\rho} (0) = \\hat{\\rho}_{n} (0) \\otimes \\hat{\\sigma} (0) \\] <p>Here, \\(\\hat{\\rho}_{n} (0)\\) is the initial density operator for the nuclear (bath) degrees of freedom, which is always taken to be in its own thermal equilibrium. Similarly, \\(\\hat{\\sigma} (0) = \\text{Tr}_n \\{ \\hat{\\rho} (0)\\}\\) is the reduced density operator that describes the initial state of the electronic DOFs. Here, \\({\\rm Tr}_n\\{\\cdot \\}\\) denotes the partial trace over nuclear (bath) degrees of freedom.</p> <p>Now define the projection operator as:</p> \\[\\mathcal{P} \\hat{\\rho}(t) = \\hat{\\rho}_n(0) \\otimes \\text{Tr}_n\\{\\hat{\\rho}(t)\\}\\] <p>This choice ensures that \\(\\mathcal{P} \\hat{\\rho}(0) = \\hat{\\rho}(0)\\), which means the inhomogeneous term \\(\\mathcal{I}(t)\\) in the GQME vanishes.</p> <p>With this projection operator, the definitions of the projected Liouvillian and the memory kernel become:</p> \\[ \\langle \\mathcal{L}\\rangle_{n}^{0} = \\text{Tr}_n \\left\\{ \\hat{\\rho}_n (0) {\\cal L} \\right\\} \\] \\[ \\mathcal{K}(t) = \\frac{1}{\\hbar^2}\\text{Tr}_n \\Big\\{ \\mathcal{L} e^{-i \\mathcal{QL} \\tau / \\hbar}\\mathcal{QL} \\hat{\\rho}_n (0) \\Big\\}  \\] <p>It is important to note that all effects of the environment are fully encoded in the memory kernel. In other words, the challenge of simulating an open quantum system is reduced to accurately computing the memory kernel. Once the memory kernel is known, the GQME can be directly solved to obtain the time evolution of the reduced density matrix.</p>"},{"location":"qflux/GQME/What_is_GQME/#numerical-calculation-of-the-memory-kernel","title":"Numerical calculation of the memory kernel","text":"<p>We now introduce a numerical approach for evaluating the memory kernel. Using the identity for the \\(e^{-i \\mathcal{QL} \\tau / \\hbar}\\) (Qiang Shi 2003),(Ming-Liang Zhang 2006),</p> \\[ e^{-i \\mathcal{Q}\\mathcal{L}t/\\hbar} = e^{-i \\mathcal{L}t/\\hbar} + \\frac{i}{\\hbar}\\int_{0}^{t} \\mathrm{d}\\tau \\, e^{-i \\mathcal{L}(t - \\tau)/\\hbar} \\mathcal{P}\\mathcal{L} e^{-i \\mathcal{Q}\\mathcal{L}\\tau/\\hbar} \\] <p>The memory kernel becomes</p> \\[ \\mathcal{K}(t) = i\\dot{\\mathcal{F}}(t) - \\frac{1}{\\hbar}\\mathcal{F}(t)\\langle \\mathcal{L}\\rangle_{n}^{0} + i\\int_{0}^{t} d\\tau \\, \\mathcal{F}(t - \\tau)\\mathcal{K}(\\tau) \\] <p>with the projection-free inputs (PFIs) \\(\\mathcal{F}(t)\\) and \\(\\dot{\\mathcal{F}}(t)\\) defined as</p> \\[ \\mathcal{F}(t) = \\frac{1}{\\hbar}\\mathrm{Tr}_n\\bigl[\\mathcal{L} e^{-i\\mathcal{L}t/\\hbar}\\hat{\\rho}_n(0)\\bigr] \\] \\[ \\dot{\\mathcal{F}}(t) = -\\frac{i}{\\hbar^2}\\mathrm{Tr}_n\\bigl[\\mathcal{L} e^{-i\\mathcal{L}t/\\hbar}\\mathcal{L}\\hat{\\rho}_n(0)\\bigr]. \\] <p>The projection-free inputs can be related to the dynamics of the reduced density operator. Note that the reduce density operator \\(\\hat{\\sigma}(t)\\) can be formally written as</p> \\[ \\hat{\\sigma}(t)  = \\mathcal{G}(t) \\hat{\\sigma}(0) = \\mathrm{Tr}_n [e^{-i\\mathcal{L}t/\\hbar}\\hat{\\rho}_n(0)] \\hat{\\sigma}(0) \\] <p>therefore, \\(\\mathcal{F}(t) = i\\dot{\\mathcal{G}}(t)\\). \\(\\mathcal{F}(t)\\) and \\(\\dot{\\mathcal{F}}(t)\\) can be obtained through taking time-derivatives of \\(\\mathcal{G}(t)\\).</p> <p>The propagator \\(\\mathcal{G}(t)\\), is a super-operator with the matrix element \\(\\mathcal{G}_{jk,lm}(t)\\), which can be defined by starting from initial state \\(|l\u27e9\u27e8m| \\otimes \\hat{\\rho}_n(0)\\), measure the \\(\\sigma_{jk}(t)\\) at time \\(t\\).</p> <p>These quantities can be computed using various existing numerical methods, such as the numerically exact tensor-train thermo-field dynamics (TT-TFD) approach introduced in  TT-TFD. We will demonstrate the practical solution of the GQME using <code>qflux</code> in GQME for Spin-Boson model.</p>"},{"location":"qflux/GQME/What_is_GQME/#summary","title":"Summary","text":"<p>This example introduces the Generalized Quantum Master Equation (GQME) framework, which is an important approach for simulating open quantum system dynamics:</p> <ul> <li> <p>The Nakajima\u2013Zwanzig formalism is introduced as the theoretical foundation for deriving the GQME.</p> </li> <li> <p>For chemically relevant molecular systems, we provide explicit definitions of each term in the GQME.</p> </li> <li> <p>The memory kernel expression is expanded, illustrating how it can be computed numerically using various methods.</p> </li> </ul> <p>The GQME framework thus provides a rigorous and versatile foundation for investigating quantum dynamics in systems coupled to realistic environments.</p>"},{"location":"qflux/GQME/What_is_TTTFD/","title":"Introduction to TT-TFD","text":"<p>In this section, we introduce the tensor-train thermo-field dynamics (TT-TFD) method. Using the spin-boson model as an example, we demonstrate how TT-TFD can be used to simulate its quantum dynamics and compute the corresponding memory kernel.</p> <p>The TT-TFD method has been fully integrated into the <code>qflux.GQME</code> module.</p>"},{"location":"qflux/GQME/What_is_TTTFD/#what-is-tt-tfd","title":"What is TT-TFD?","text":"<p>The thermo-field dynamics (TFD) method enables the simulation of thermal quantum systems by doubling the Hilbert space and purifying the thermal density matrix into a pure state. It transform solving the Liouville equation \\(\\frac{d}{dt} \\hat{\\rho}(t) = -\\frac{i}{\\hbar} [\\hat{H}, \\hat{\\rho}(t)]\\) into solving</p> \\[ \\frac{d}{dt} |\\psi(\\beta, t)\\rangle = -\\frac{i}{\\hbar} \\bar{H} |\\psi(\\beta, t)\\rangle \\] <p>with \\(\\bar{H} = \\hat{H}\\otimes \\tilde{I}\\). And \\(|\\psi(\\beta, t)\\rangle\\) is the thermal wave function from which the density operator \\(\\hat{\\rho}(t)\\) can be obtained as follows:</p> \\[ \\hat{\\rho}(t) = {\\rm Tr}_f \\{ |\\psi(\\beta, t)\\rangle\\langle \\psi(\\beta, t)|\\} \\] <p>Next, we consider the spin-boson model as an example and provide the explicit form of the effective Hamiltonian \\(\\bar{H}\\) and initial state |\\(\\psi(\\beta, 0)\\rangle\\) used in the thermo-field dynamics framework.</p>"},{"location":"qflux/GQME/What_is_TTTFD/#the-spin-boson-model","title":"The spin-boson model","text":"<p>The spin-boson model is a convenient and widely used framework for simulating electronic energy and charge transfer dynamics in chemical systems. This model comprises two electronic states, representing a diabatic donor state \\(\\lvert D \\rangle\\) and an acceptor state \\(\\lvert A \\rangle\\), coupled to a harmonic bath that interacts with the electronic degrees of freedom.</p> <p>The total Hamiltonian can be written as:</p> \\[ \\hat{H} = \\epsilon \\hat{\\sigma}_z + \\Gamma \\hat{\\sigma}_x +\\sum_{i = 1}^{N_{n}} \\Bigg[\\frac{\\hat{P}_i^2}{2} + \\frac{1}{2} \\omega_i^2 \\hat{R}_i^2 - c_i\\hat{R}_i \\hat{\\sigma}_z\\Bigg]  \\] <p>where \\(\\hat{\\sigma}_z = |D\\rangle\\langle D| - |A\\rangle\\langle A|\\) and \\(\\hat{\\sigma}_x = |D\\rangle \\langle A| + |A\\rangle\\langle D|\\) are the Pauli matrices for the electronic DOF (with \\(D\\) standing for Donor and \\(A\\) for acceptor), \\(2\\epsilon\\) is the energy gap between the electronic states, \\(\\Gamma\\) is the coupling between them, and \\(\\hat R_i\\) and \\(\\hat P_i\\) are the mass-weighted position and momentum operators of the \\(i\\)-th nuclear DOF.</p> <p>The general discretized form of the nuclear modes frequencies and coupling coefficients, \\(\\{\\omega_{k} , c_{k}\\}\\), is given by</p> \\[ J (\\omega) = \\frac{\\pi}{2} \\sum_{k=1}^{N_{n}} \\frac{c_{k}^2}{\\omega_{k}} \\delta(\\omega-\\omega_{k}) \\] <p>We sample the \\(\\{\\omega_{k} , c_{k}\\}\\) from an Ohmic spectral density with exponential cutoff:</p> \\[ J (\\omega) =  \\frac{\\pi\\hbar}{2}\\xi \\omega e^{-\\omega/\\omega_{c}} \\] <p>Here, \\(\\xi\\) is the Kondo parameter and \\(\\omega_{c}\\) is the cutoff frequency.</p> <p>The initial state is assumed to be of the form</p> \\[ \\hat \\rho(0) = \\hat \\sigma(0) \\otimes \\hat \\rho_{n}(0) \\] <p>with \\(\\hat{\\sigma} (0) = |\\gamma\\rangle \\langle \\gamma |\\) is the initial electronic density operator, where \\(|\\gamma\\rangle\\) is one of the electronic basis states. The initial nuclear density operator given by</p> \\[ \\hat{\\rho}_{n} (0) = \\frac{\\exp\\bigg[\\displaystyle -\\beta \\sum_{i = 1}^{N_{n}} \\frac{\\hat{P}_{i}^{2}}{2} + \\frac{1}{2} \\omega_{i}^{2} \\hat{R}_{i}^{2}\\bigg]}{\\text{Tr}_{n} \\Bigg\\{ \\exp\\bigg[\\displaystyle -\\beta\\sum_{i = 1}^{N_{n}} \\frac{\\hat{P}_{i}^{2}}{2} + \\frac{1}{2} \\omega_{i}^{2} \\hat{R}_{i}^{2}\\bigg] \\Bigg\\}} \\] <p>We set the parameters as:</p> <pre><code>GAMMA_DA = 1 # diabatic coupling\nEPSILON = 1\nBETA = 5 # inverse finite temperature beta = 1 / (k_B * T)\nXI = 0.1\nOMEGA_C = 2\n</code></pre> <p>which are defined in <code>qflux.GQME.params</code>.</p>"},{"location":"qflux/GQME/What_is_TTTFD/#tt-tfd-for-spin-boson-model","title":"TT-TFD for spin-boson model","text":"<p>The TT-TFD method evolves the spin-boson model in an extended Hilbert space, which is defined as the tensor product of the electronic subsystem, the physical nuclear degrees of freedom, and their thermal-field replicas:</p> \\[ \\mathcal{H}_{\\text{total}} = \\mathcal{H}_e \\otimes \\mathcal{H}_n \\otimes \\tilde{\\mathcal{H}}_n \\] <p>Here:</p> <ul> <li>\\(\\mathcal{H}_e\\): Hilbert space of the two-level electronic system (donor/acceptor),</li> <li>\\(\\mathcal{H}_n\\): Hilbert space of the nuclear (bath) degrees of freedom,</li> <li>\\(\\tilde{\\mathcal{H}}_n\\):  a fictitious copy of \\(\\mathcal{H}_n\\) introduced via the TFD formalism.</li> </ul> <p>The initial thermal wave function</p> \\[ |\\psi(\\beta, 0)\\rangle = |\\gamma\\rangle \\otimes \\frac{e^{-\\beta \\hat{H}_n/2}}{\\sqrt{Z(\\beta)}}\\sum_{k=\\tilde{k}}|k\\rangle\\otimes |\\tilde{k}\\rangle \\] <p>where \\(\\hat{H}_{n} = \\sum_{i = 1}^{N_{n}} \\frac{\\hat{P}_{i}^{2}}{2} + \\frac{1}{2} \\omega_{i}^{2} \\hat{R}_{i}^{2}\\) is the nuclear bath, and \\(|k\\rangle\\) is the bath state.</p> <p>The preparation of the initial thermal wavepacket requires the evaluation of the quantum Boltzmann operator, which can be computationally challenging for systems with high dimensionality. However, when the initial nuclear Hamiltonian is harmonic, the initial thermal wavepacket can be obtained by taking advantage of the thermal Bogoliubov transformation. The transformation is defined by \\(e^{-i\\hat{G}}\\) with</p> \\[ \\hat{G} = -i \\sum_{j} \\theta_{j} (\\hat{a}_j \\tilde{a}_{j} - \\hat{a}^{\\dagger}_{j} \\tilde{a}^{ \\dagger }_{j}) \\] <p>with \\(\\theta_{j} = {\\rm arctanh}(e^{-\\beta \\omega_{j} / 2})\\), where \\(\\{ \\hat{a}_{j}, \\hat{a}_{j}^{\\dagger} \\}\\) and \\(\\{ \\tilde{a}_j, \\tilde{a}_j^\\dagger \\}\\) are the creation and annihilation operators associated with the \\(j\\)-th nuclear degree of freedom in the physical and tilde Hilbert spaces, respectively.</p> <p>After the transformation, the TT-TFD equation becomes</p> \\[ \\frac{d}{dt} |\\psi_{\\theta}(\\beta, t)\\rangle = -\\frac{i}{\\hbar} \\bar{H}_\\theta |\\psi_{\\theta}(\\beta, t)\\rangle \\] <p>with</p> \\[ \\bar{H}_\\theta = e^{i\\hat{G}} \\bar{H} e^{-i\\hat{G}} = \\epsilon \\hat{\\sigma}_z + \\Gamma \\hat{\\sigma}_x + \\sum_{i = 1}^{N_n} \\left[ \\omega_i \\hat{a}_i^\\dagger \\hat{a}_i - \\omega_i \\tilde{a}_i^\\dagger \\tilde{a}_i + c_i {\\rm cosh}\\theta_i  \\hat{\\sigma}_z (\\hat{a}_i^\\dagger + \\hat{a}_i) + c_i {\\rm sinh}\\theta_i  \\hat{\\sigma}_z (\\tilde{a}_i^\\dagger + \\tilde{a}_i) \\right] \\] <p>and the initial thermal wave function becomes</p> \\[ |\\psi(\\beta, 0)\\rangle = |\\gamma\\rangle \\otimes |0, \\tilde{0}\\rangle  \\] <p>In practice, the \\(N_n\\) pairs of \\(\\{\\omega_i , c_i\\}\\) are sampled from an Ohmic spectral density, and the TFD equations are solved in the tensor-train (TT) representation (more details can refer to \"Tensor-Train Thermo-Field Memory Kernels for Generalized Quantum Master Equations\").</p>"},{"location":"qflux/GQME/What_is_TTTFD/#tt-tfd-implementation-in-qflux","title":"TT-TFD Implementation in qflux","text":"<p>The TT-TFD approach has been integrated into the <code>qflux</code> package. The time-dependent variational principle (TDVP) method is employed to propagate the TT-TFD. With the help of the <code>mpsqd</code> package developed by Guan et al., tensor-train (TT) operations can be conveniently performed.</p> <pre><code>!pip install mpsqd\n</code></pre> <pre><code>import qflux.GQME.tt_tfd as tfd\n\n#RDO: reduced density operator, contain the information of population and coherence\n#initial_state=0: initial at Donor state\nt, RDO_arr = tfd.tt_tfd(initial_state=0, show_steptime=True, update_type='rk4')\n</code></pre> <p>The result of the TT\u2011TFD simulation is shown in the figure below. Where we plot the donor-state population \\(|D\\rangle\\) over time in the spin\u2011boson model.</p> <pre><code>plt.figure(figsize=(6,2))\nplt.plot(t, RDO_arr[:,0].real,'b-', label='TT-TFD')\nplt.xlabel('$\\Gamma t$',fontsize=15)\nplt.ylabel('$\\sigma_{DD}$(t)',fontsize=15)\nplt.legend()\n</code></pre> <p></p>"},{"location":"qflux/GQME/What_is_TTTFD/#summary","title":"Summary","text":"<p>In this documentation, we introduce the tensor-train thermo-field dynamics (TT-TFD) method, a numerically exact approach for solving open quantum system dynamics:</p> <ul> <li> <p>The definition of the spin-boson model is presented.</p> </li> <li> <p>The TT-TFD formulation for the spin-boson model is detailed, including discretization of the environment and the use of the thermal Bogoliubov transformation.</p> </li> <li> <p>The specific implementation of TT-TFD using <code>qflux</code> is described.</p> </li> </ul> <p>The TT-TFD approach provides an accurate and efficient framework for studying strongly coupled system\u2013bath dynamics, and its integration in <code>qflux</code> offers a practical tool for real applications.</p>"},{"location":"qflux/GQME/gqme_api/","title":"GQME Module API Documentation","text":""},{"location":"qflux/GQME/gqme_api/#source-code","title":"Source Code","text":""},{"location":"qflux/GQME/gqme_api/#qflux.GQME","title":"<code>qflux.GQME</code>","text":""},{"location":"qflux/GQME/quantum_GQME_dilation/","title":"Quantum Algorithms of GQME based on Dilation","text":"<p>In this section, we introduce the quantum simulation of the Generalized Quantum Master Equation (GQME).</p> <p>Due to the interaction of the system with its surrounding environment, the dynamics of the reduced density operator are non-unitary. We express the formal solution of the reduced density operator as:</p> \\[ \\hat{\\sigma} (t) = {\\cal G} (t) \\hat{\\sigma} (0)~~.  \\] <p>where \\({\\cal G} (t)\\) is the propagator. A key feature for open systems is that this propagator is generally a non-unitary matrix. Since quantum gates are inherently unitary, this poses a fundamental challenge for quantum computation.</p> <p>In the following, we describe how to calculate the propagator using the GQME, and how to construct quantum circuits to simulate the dynamics by employing the dilation method introduced in open system overview.</p> <p>Consistent with GQME for Spin-Boson model, we continue to use the spin-boson model as an illustrative example.</p>"},{"location":"qflux/GQME/quantum_GQME_dilation/#solving-the-gqme-to-get-the-propagator","title":"Solving the GQME to get the propagator","text":"<p>The propagator, similar to the reduced density operator, satisfies the same GQME governing its time evolution:</p> \\[ \\frac{d}{dt} {\\cal G}(t) = -\\frac{i}{\\hbar} \\langle \\mathcal{L} \\rangle_n^0 {\\cal G}(t)- \\int_0^t d\\tau\\ \\mathcal{K}(\\tau){\\cal G}(t - \\tau)~~. \\] <p>Therefore, starting from the identity superoperator \\({\\cal{G}}(0)= I\\), one can solve the above GQME to obtain \\({\\cal{G}}(t)\\). The definitions of \\(\\langle \\mathcal{L} \\rangle_n^0\\), \\(\\mathcal{K}(\\tau)\\), and the procedure for solving the GQME have already been introduced in section GQME for Spin-Boson model.</p> <p>Below is an example code snippet showing how to solve for \\({\\cal{G}}(t)\\) using <code>qflux</code>:</p> <pre><code>from qflux.GQME.dynamics_GQME import DynamicsGQME\n\n#============setup the Hamiltonian and initial state for Spin-Boson Model\nHsys = pa.EPSILON*pa.Z + pa.GAMMA_DA*pa.X\nrho0 = np.zeros((pa.DOF_E,pa.DOF_E),dtype=np.complex128)\nrho0[0,0] = 1.0\n\n#Create the Spin-Boson model (SBM)\nSBM = DynamicsGQME(pa.DOF_E,Hsys,rho0)\nSBM.setup_timestep(pa.DT, pa.TIME_STEPS)\n\n#read the precalculated kernel\ntimeVec, kernel = wr.read_superoper_array(pa.TIME_STEPS,\"qflux/data/GQME_Example/K_Output/K_\")\n\n#solve the GQME for propagator\nG_prop = SBM.solve_gqme(kernel, pa.MEM_TIME, dtype='Propagator')\n</code></pre> <p>Here, we first initialize the <code>DynamicsGQME</code> class with the parameters of the spin-boson model and load the precomputed memory kernel \\(\\mathcal{K}(\\tau)\\). By setting <code>dtype='Propagator'</code> in the <code>solve_gqme</code> method, the GQME for the propagator can then be solved directly.</p>"},{"location":"qflux/GQME/quantum_GQME_dilation/#dilation-of-the-non-unitary-propagator","title":"Dilation of the non-unitary propagator","text":"<p>Next, we introduce the Sz.-Nagy dilation method (Levy 2010, wang 2023)\uff0cThis technique enables us to transform the non-unitary propagator \\({\\cal G}(t)\\) into a unitary propagator that inhabits an extended Hilbert space.</p> <p>We begin by evaluating the operator norm of \\(\\mathcal{G}(t)\\) to determine whether it qualifies as a contraction, which requires</p> \\[ ||\\mathcal{G}(t)||_O = \\sup \\frac{||\\mathcal{G}(t)\\mathbf{v}||}{||\\mathbf{v}||} \\leq 1. \\] <p>If \\(\\mathcal{G}(t)\\) does not satisfy this condition, we introduce a scaling factor \\(n_c\\) (chosen to be larger than \\(||\\mathcal{G}(t)||_O\\)) to normalize it into a contraction form:</p> \\[ \\mathcal{G}'(t) = \\frac{\\mathcal{G}(t)}{n_c}. \\] <p>Once \\(\\mathcal{G}'(t)\\) is a contraction, we define its corresponding unitary dilation operator \\(\\mathcal{U}_{\\mathcal{G}'}(t)\\) as</p> \\[ \\mathcal{U}_{\\mathcal{G}'}(t) = \\begin{pmatrix} \\mathcal{G}'(t) &amp; \\mathcal{D}_{\\mathcal{G}'^\\dagger}(t) \\\\ \\mathcal{D}_{\\mathcal{G}'}(t) &amp; -\\mathcal{G}'^\\dagger(t) \\end{pmatrix}, \\] <p>where the so-called defect operators are given by</p> \\[ \\mathcal{D}_{\\mathcal{G}'}(t) = \\sqrt{I - \\mathcal{G}'^\\dagger(t)\\mathcal{G}'(t)} \\] <p>and</p> \\[ \\mathcal{D}_{\\mathcal{G}'^\\dagger}(t) = \\sqrt{I - \\mathcal{G}'(t)\\mathcal{G}'^\\dagger(t)}. \\] <p>The resulting \\(\\mathcal{U}_{\\mathcal{G}'}(t)\\) is a unitary superoperator defined on an enlarged Hilbert space of double the original dimension, and it effectively reproduces the action of \\(\\mathcal{G}'(t)\\) when restricted to the original system subspace.</p> <p>As described in open system overview, these steps have been fully integrated into the <code>qflux.open_systems.quantum_simulation</code> module. The <code>set_dilation_method</code> function in the <code>QubitDynamicsOS</code> class supports several different dilation methods, with <code>'Sz-Nagy'</code> set as the default option.</p>"},{"location":"qflux/GQME/quantum_GQME_dilation/#quantum-simulation-of-gqme","title":"Quantum Simulation of GQME","text":"<p>The following code implements the quantum simulation of the GQME using Qiskit\u2019s QASM simulator.</p> <pre><code>from qflux.open_systems.quantum_simulation import QubitDynamicsOS\n\nqSBM = QubitDynamicsOS(rep='Density', Nsys = pa.DOF_E, Hsys = Hsys, rho0 = rho0)\nqSBM.set_count_str(['000','011'])\nqSBM.set_dilation_method('Sz-Nagy')\n\nres_qc = qSBM.qc_simulation_vecdens(timeVec,Gprop=G_prop)\npop_qc = res_qc['data']\n</code></pre> <p>Here, we instantiate the <code>QubitDynamicsOS</code> class with the parameters of the spin-boson model, set the final measurement states, and specify the dilation method. The <code>qc_simulation_vecdens</code> method supports quantum simulation with the propagator as input.</p> <p>The population results are shown in the figure below.</p> <p></p> <p>One can also visualize an example quantum circuit from the result output of the <code>qc_simulation_vecdens</code> method: <pre><code>res_qc['circuits'][200].draw('mpl')\n</code></pre> </p> <p>Here, we use the circuit at the 200th time step as an example.</p> <p>Furthermore, the circuit complexity can be further illustrated by transpiling it into a specific basis gate set.: <pre><code>from qiskit import transpile\n\nbasis_gates = ['cz', 'id', 'rx', 'rz', 'rzz', 'sx', 'x']\ncompiled_circuit = transpile(res_qc['circuits'][200], basis_gates=basis_gates, optimization_level=1)\ncompiled_circuit.draw('mpl')\n</code></pre> </p>"},{"location":"qflux/GQME/quantum_GQME_dilation/#summary","title":"Summary","text":"<p>This example demonstrates a modular quantum simulation of the Generalized Quantum Master Equation (GQME) using the spin-boson model as an illustrative example:</p> <ul> <li> <p>The propagator of the reduced density operator satisfies the GQME. By utilizing a precomputed memory kernel, the GQME is solved to obtain the propagator.</p> </li> <li> <p>The Sz.-Nagy dilation method is employed to transform the non-unitary propagator of the open system into a unitary operator in an extended Hilbert space.</p> </li> <li> <p>Quantum circuits are constructed and executed, and the simulation results are benchmarked against exact GQME calculations.</p> </li> </ul>"},{"location":"qflux/GQME/spin_boson_GQME/","title":"GQME for Spin-Boson model","text":"<p>This documentation describes how to simulate the dynamics of a spin-boson system using the generalized quantum master equation (GQME). This simulation also includes comparison plots to the numerically exact results obtained via tensor-train thermo-field dyanmics (TT-TFD).</p> <p>The following modules will be used throughout the documentation: <pre><code>import numpy as np\nimport time\nimport matplotlib.pyplot as plt\n\nimport qflux.GQME.params as pa\nimport qflux.GQME.readwrite as wr\n</code></pre></p>"},{"location":"qflux/GQME/spin_boson_GQME/#spin-boson-model-hamiltonian","title":"Spin Boson Model Hamiltonian","text":"<p>The total Hamiltonian for the spin-boson model can be written as:</p> \\[ \\hat{H} = \\epsilon \\hat{\\sigma}_z + \\Gamma \\hat{\\sigma}_x + \\sum_{i=1}^{N_n} \\left[ \\frac{\\hat{P}_i^2}{2} + \\frac{1}{2} \\omega_i^2 \\hat{R}_i^2 - c_i \\hat{R}_i^2 - c_i \\hat{R}_i \\hat{\\sigma}_z \\right] \\] <p>where \\(\\lvert D \\rangle\\) and \\(\\lvert A \\rangle\\) are the electronic donor state and acceptor state, respectively.  \\(\\hat{\\sigma}_z = \\lvert D \\rangle \\langle D \\rvert  - \\lvert A \\rangle \\langle A \\rvert\\), \\(\\hat{\\sigma}_x = \\lvert D \\rangle \\langle A \\rvert + \\lvert A \\rangle \\langle D \\rvert\\), \\(2\\epsilon\\) is the reaction energy and \\(\\Gamma = V_{DA}\\) is the electronic coupling between the donor and acceptor states. More details about the model can be found in Introduction to TT-TFD page. </p> <p>The initial state is assumed to be of the form</p> \\[ \\hat \\rho(0) = \\hat \\sigma(0) \\otimes \\hat \\rho_n(0) \\] <p>With</p> \\[ \\hat{\\sigma}(0) = \\lvert D \\rangle\\langle D \\rvert \\] <p>and </p> \\[\\hat{\\rho}_n (0) = \\frac{\\exp\\bigg[\\displaystyle -\\beta \\sum_{i = 1}^{N_n} \\frac{\\hat{P}_i^2}{2} + \\frac{1}{2} \\omega_i^2 \\hat{R}_i^2\\bigg]}{\\text{Tr}_n \\Bigg\\{ \\exp\\bigg[\\displaystyle -\\beta\\sum_{i = 1}^{N_n} \\frac{\\hat{P}_i^2}{2} + \\frac{1}{2} \\omega_i^2 \\hat{R}_i^2\\bigg] \\Bigg\\}}\\] <p>By treating all nuclear degrees of freedom as the environment, the GQME for the spin-boson model can be written as follows: </p> \\[ \\frac{d}{dt}\\hat{\\sigma}(t) = -\\frac{i}{\\hbar}\\langle \\mathcal{L}\\rangle_n^0\\hat{\\sigma}(t) - \\int_0^t d\\tau\\, \\mathcal{K}(\\tau)\\hat{\\sigma}(t - \\tau) \\tag{1} \\] <p>Here, \\(\\hat{\\sigma}(t)\\) denotes the reduced density operator, which only includes the system degrees of freedom and is a \\(2\u00d72\\) matrix. </p> <p>To propagate the GQME, two quantities are required: the projected Liouvillian \\(\\langle {\\cal L} \\rangle_n^0\\) and the memory kernel \\(\\mathcal{K}(t)\\). Their computation is described below.</p>"},{"location":"qflux/GQME/spin_boson_GQME/#the-projected-liouvillian","title":"The projected Liouvillian","text":"<p>When the memory kernel is absent, the system dynamics are governed solely by the projected Liouvillian \\(\\langle {\\cal L} \\rangle_n^0\\). Therefore, \\(\\langle {\\cal L} \\rangle_n^0\\) represents the unitary dynamics of the isolated system without environmental effects.</p> <p>The pure system Hamiltonian is given by \\(H_S = \\epsilon \\hat{\\sigma}_z + \\Gamma \\hat{\\sigma}_x\\), and \\(\\langle {\\cal L} \\rangle_n^0\\) is defined through its action on an arbitrary electronic operator \\(\\hat{A}\\):</p> \\[ \\langle {\\cal L} \\rangle_n^0 \\hat{A} = \\left[H_S,\\hat{A} \\right] . \\] <p>The <code>DynamicsGQME</code> class in the <code>qflux.GQME</code> module provides methods for performing GQME calculations. The following code snippet shows how to initialize a <code>DynamicsGQME</code> object and define the initial reduced density operator and \\(H_S\\). Then the method <code>DynamicsGQME.prop_puresystem()</code> allows for time evolution of the isolated system:</p> <pre><code>from qflux.GQME.dynamics_GQME import DynamicsGQME\nimport scipy.linalg as LA\n\n#============setup the Hamiltonian and initial state for Spin-Boson Model\nHsys = pa.EPSILON*pa.Z + pa.GAMMA_DA*pa.X\nrho0 = np.zeros((pa.DOF_E,pa.DOF_E),dtype=np.complex128)\nrho0[0,0] = 1.0\n\n#Create the Spin-Boson model (SBM)\nSBM = DynamicsGQME(pa.DOF_E,Hsys,rho0)\nSBM.setup_timestep(pa.DT, pa.TIME_STEPS)\n\n#=========== Propagate the density matrix under the pure system Liouvillian\nsigma_liou = SBM.prop_puresystem()\n</code></pre> <p>The results are shown in the figure below, along with the numerically exact TT-TFD results for comparison. As expected, the evolution of the isolated system exhibits no decay and no energy dissipation.</p> <p></p>"},{"location":"qflux/GQME/spin_boson_GQME/#the-memory-kernel","title":"The Memory Kernel","text":"<p>According to Introduction to GQME, the memory kernel can be obtained through the projection-free inputs (PFIs) \\(\\mathcal{F}(t)\\) and \\(\\dot{\\mathcal{F}}(t)\\): </p> \\[ \\mathcal{K}(t)  = i\\dot{\\mathcal{F}}(t)  - \\frac{1}{\\hbar}\\mathcal{F}(t)\\langle \\mathcal{L}\\rangle_n^0  + i\\int_{0}^{t} d\\tau \\, \\mathcal{F}(t - \\tau)\\mathcal{K}(\\tau) \\] <p>with \\(\\mathcal{F}(t) = i\\dot{\\mathcal{G}}(t)\\) is the time-derivative of the propagator \\(\\mathcal{G}(t)\\). </p> <p>The propagator is a super-operator with the matrix element \\(\\mathcal{G}_{jk,lm}(t)\\) (\\(j, k, l, m \\in \\{D, A\\}\\)) can be calculated by starting from initial state \\(|l\u27e9\u27e8m| \u2297 \\hat{\\rho}_n(0)\\), measure the \\(\\sigma_{jk}(t)\\) at time \\(t\\). </p> <p>Here, we compute the propagator using the Tensor-Train Thermo-Field Dynamics (TT-TFD) approach, which in our <code>qflux.GQME</code> implementation is integrated into the <code>cal_propagator_tttfd()</code> method of the <code>DynamicsGQME</code> class.</p> <pre><code># Compute the full system propagator using TT-TFD\ntimeVec, Gt = SBM.cal_propagator_tttfd()\nprint('End of calculate propagator')\n\n# Save the computed propagator for future use\nwr.output_superoper_array(timeVec, Gt, \"qflux/data/GQME_Example/U_Output/U_\")\n</code></pre> <p>Because this step can be computationally costly, the results are precomputed and saved. Alternatively, one can directly load the propagator data and set it in the <code>DynamicsGQME</code> class.</p> <pre><code># Load precomputed propagator from file\ntimeVec, Gt = wr.read_superoper_array(pa.TIME_STEPS, \"qflux/data/GQME_Example/U_Output/U_\")\n\n# Set the propagator in the SBM object for later use\nSBM.setup_propagator(Gt)\n</code></pre> <p>Once the propagator \\({\\cal G}(t)\\) is calculated, the memory kernel \\({\\cal K}(t)\\) can be obtained by solving the above Volterra integral equation. In <code>qflux</code>, this equation is solved using an iterative algorithm, which has been integrated into the <code>get_memory_kernel</code> method of the <code>DynamicsGQME</code> class.</p> <p><pre><code>#=========== Solve Volterra equation to obtain the memory kernel\nkernel = SBM.get_memory_kernel()\n</code></pre> A representative result of the memory kernel is shown in the figure below. It captures the influence of the environment on the system dynamics, leading to non-Markovian behavior. The nonzero \\(\\mathcal{K}_{DA,DD}(t)\\) component in the figure indicates that the bath-induced population \\(\\sigma_{DD}\\) at an earlier time can influence the coherence dynamics of \\(\\sigma_{DA}\\) at a later time.</p> <p></p>"},{"location":"qflux/GQME/spin_boson_GQME/#propagating-system-dynamics-using-gqme","title":"Propagating System Dynamics using GQME","text":"<p>With both the projected Liouvillian and the memory kernel available, Eq. (1) can be directly solved. The <code>solve_gqme</code> method in the <code>DynamicsGQME</code> class employs the fourth-order Runge-Kutta (RK4) method to solve the GQME. By providing the memory kernel and specifying a cutoff memory time, the <code>solve_gqme</code> method directly integrates the GQME and returns the reduced density operator \\(\\hat{\\sigma}(t)\\).</p> <pre><code>#=========== Propagate system dynamics using the GQME\nsigma = SBM.solve_gqme(kernel, pa.MEM_TIME)\n</code></pre> <p>We visualize the simulations by plotting the observable \\(\\sigma(t)\\). The comparison between the GQME and exact results obtained via TT-TFD offers a benchmark for accuracy.</p> <p><pre><code>## Plotting Results\n#=========== Plot the 0th state population from both methods\nplt.figure(figsize=(6,2))\nplt.plot(timeVec, sigma[:, 0].real, 'b-', label='GQME')\nplt.plot(timeVec, sigma_tt_tfd[:, 0].real, 'ko', markersize=4, markevery=15, label='benchmark_TT-TFD')\nplt.xlabel('', fontsize=15)\nplt.ylabel(r'$\\sigma_{00}(t)$', fontsize=15)\nplt.legend()\n</code></pre> </p>"},{"location":"qflux/GQME/spin_boson_GQME/#summary","title":"Summary","text":"<p>This example demonstrates a modular simulation of an open quantum system using the Generalized Quantum Master Equation (GQME) framework:</p> <ul> <li>The spin-boson model is used as an illustrative example, and its corresponding GQME is presented.</li> <li>A numerically exact approach based on Tensor-Train Thermo-Field Dynamics (TT-TFD) is provided to compute the memory kernel.</li> <li>The GQME is explicitly solved and benchmarked against exact TT-TFD calculations.</li> </ul> <p>The combination of TT-TFD for accurate short-time dynamics and the GQME for efficient long-time propagation offers a powerful framework for studying open quantum systems with realistic environmental couplings.</p>"},{"location":"qflux/Open_Systems/","title":"Open Systems Documentation and User Guide","text":"<p>This section includes documentation and tutorials focused on illustrating the usage and versatility of the <code>qflux.open_systems</code> module. </p>"},{"location":"qflux/Open_Systems/#overview","title":"Overview","text":"<p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/Open_Systems/#examples-and-introductory-concepts","title":"Examples and Introductory Concepts","text":"<p>Before we look at doing Quantum Dynamics on a quantum computer, we'll start out by looking at some ways that we can do quantum dynamics on a classical computer! This is an important step as it will familiarize you with the general ingredients of a quantum dynamics simulation and will also provide us with a means of validating the results obtained from a quantum computer.</p> <ul> <li>Open System Dynamics Overview</li> <li>Spin Chain Demo</li> <li>Spin 1/2 Demo</li> <li>Double Well Demo</li> <li>API Documentation</li> </ul>"},{"location":"qflux/Open_Systems/DoubleWellOpen/","title":"The Double-Well System","text":"<p>This documentation describes how to simulate the open quantum dynamics of a double-well potential system, which is more familiar to those with a background in chemistry. In particular, we use the potential energy surface corresponding to the hydrogen bond within the adenine\u2013thymine (A\u2013T) base pair in DNA, and simulate the proton transfer process at the interface of an individual A\u2013T pair. Due to the large Hilbert space involved in such systems, we introduce more advanced techniques, including how <code>qflux</code> utilizes the Kraus operator representation to construct quantum circuits and perform quantum simulations. The framework supports both classical and quantum computational backends and includes comparison plots to evaluate different solver strategies.</p> <p>The adenine\u2013thymine base pair model follows the description in this paper. For a schematic illustration of the model, see the Adenine-Thymine Base Pair section.</p> <p>The following modules will be used throughout the documentation: <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n</code></pre></p> <pre><code>import qflux.open_systems.params as pa\nfrom qflux.open_systems.numerical_methods import DynamicsOS\nfrom qflux.open_systems.quantum_simulation import QubitDynamicsOS\nimport qflux.open_systems.trans_basis as tb\n</code></pre> <p>In this documentation, solving the double-well system amounts to solving the following Lindblad equation:</p> \\[ \\dot{\\rho}(t) = -i[\\hat{H}, \\rho(t)] + \\kappa(1 + n_{\\mathrm{th}}) \\left( \\hat{a} \\rho(t) \\hat{a}^{\\dagger} - \\frac{1}{2} \\left\\{ \\hat{a}^{\\dagger} \\hat{a}, \\rho(t) \\right\\} \\right) + \\kappa n_{\\mathrm{th}} \\left( \\hat{a}^{\\dagger} \\rho(t) \\hat{a} - \\frac{1}{2} \\left\\{ \\hat{a} \\hat{a}^{\\dagger}, \\rho(t) \\right\\} \\right) \\] <p>The double well system's Hamiltonian \\(H\\) is given by:</p> \\[ H = \\frac{p^2}{2m} + V(x)   \\] <p>where \\(p\\) is the proton's momentum, \\(m=1836.15\\) a.u. is the mass of the proton, and the double well potential is defined by setting \\(V(x)\\).</p> <p>The effect of the environment is incorporated through the jump operators \\(\\hat{a}\\) and \\(\\hat{a}^\\dagger\\), correspond to this paper. Here, \\(\\hat{a}\\) and \\(\\hat{a}^\\dagger\\) are the annihilation and creation operators, defined as:</p> \\[ \\hat{a} = \\sqrt{\\frac{m\\omega}{2\\hbar}}\\,\\hat{x} + \\frac{i}{\\sqrt{2\\hbar m \\omega}}\\,\\hat{p} \\] \\[ \\hat{a}^\\dagger = \\sqrt{\\frac{m\\omega}{2\\hbar}}\\,\\hat{x} - \\frac{i}{\\sqrt{2\\hbar m \\omega}}\\,\\hat{p} \\] <p>The parameter \\(\\kappa\\) characterizes the coupling strength between the system and the environment, while \\(n_{\\mathrm{th}} = 1/(\\exp(\\hbar \\omega/k_B T)-1)\\) is the thermally averaged occupation number of the environmental harmonic oscillator at temperature \\(T\\). We choose \\(\\kappa = 1/10\\, {\\rm fs}^{-1}\\) and \\(T=300 \\, {\\rm K}\\)  (corresponding to \\(n_{th} = 0.01\\) a.u.).</p>"},{"location":"qflux/Open_Systems/DoubleWellOpen/#set-up-the-double-well-potential","title":"Set Up the Double Well Potential","text":"<p>We begin by defining the double-well potential \\(V(x)\\). To simulate the system on a computer, the spatial coordinate \\(x\\) is discretized onto a finite grid. The <code>DVR_grid</code> class in the <code>numerical_methods</code> module enables the discretization of continuous functions onto a discrete variable representation (DVR).</p> <p>The following code defines the double-well potential function <code>pot_doublewell</code> for a proton, and discretizes the potential onto \\(1024\\) DVR grid points over the range from \\(-4.0\\) to \\(4.0\\):</p> <pre><code>from qflux.open_systems.numerical_methods import DVR_grid\n\n#=============set up the double well in the grid point representation\ndef pot_doublewell(x, f=0.0367493, a0=0.0, a1=0.429, a2=-1.126, a3=-0.143, a4=0.563):\n    # A-T pair double-well potential in Hartrees (x is in Bohr)\n    xi = x/1.9592\n    return f*(a0 + a1*xi + a2*xi**2 + a3*xi**3 + a4*xi**4)\n\nmass0 = 1836.15\nbeta = pa.au2joule/(pa.bolz*300) #1/(kT) in a.u. units\nomega = 0.00436 #the frequency associate with the right well\nkappa = 1/(10/pa.au2fs)\nnth = 1/(np.exp(beta*omega)-1)\n\ndw_grid = DVR_grid(xmin = -4.0, xmax = 4.0, Ngrid = 1024, mass = mass0)\n\ndw_grid.set_potential(pot_doublewell)\n</code></pre> <p>The plot of the potential \\(V(x)\\) is shown here:</p> <p></p> <p>The population of the proton in the left (L) and right (R) wells can be characterized by the following expectation values:</p> \\[ P_R = \\langle \\Theta(x - x^*) \\rangle \\] \\[ P_L = \\langle 1 - \\Theta(x - x^*) \\rangle \\] <p>where \\(\\langle A \\rangle = {\\rm Tr}[A \\rho]\\) for a given operator \\(A\\), \\(\\Theta (x)\\) is the Heaviside function and \\(x^*\\) defines the dividing surface between the left and right wells. Here, \\(x^* =0.37321768\\) a.u. corresponds to the position at the top of the barrier.</p>"},{"location":"qflux/Open_Systems/DoubleWellOpen/#visualize-the-eigenstates-of-the-potential","title":"Visualize the Eigenstates of the Potential","text":"<p>We can diagonalize the double-well system Hamiltonian \\(H\\) to obtain its eigenstates:</p> \\[ H|\\phi_i\\rangle = E_i |\\phi_i\\rangle \\] <p>Once the potential is defined, the <code>get_eig_state</code> method of the <code>DVR_grid</code> class can be used to solve for the eigenstates of \\(H\\). By specifying the <code>Neig</code> parameter, one can compute the lowest <code>Neig</code> eigenstates of the system.</p> <pre><code>#=============The eigen_state\nNeig = 32\neneg_DW,psi_DW = dw_grid.get_eig_state(Neig)\n</code></pre> <p>We can visualize the potential energy surface along with the energy levels and spatial distributions of the lowest 12 eigenstates.</p> <p></p>"},{"location":"qflux/Open_Systems/DoubleWellOpen/#express-the-double-well-in-the-basis-of-eigenstates","title":"Express the Double Well in the Basis of Eigenstates","text":"<p>Due to the large size of the density matrix in the DVR representation, we perform a basis transformation. Specifically, we use the previously computed eigenstates as a reduced basis set for subsequent calculations and express all operators and observables in this eigenstate basis.</p> <pre><code>#==================Express the operators in terms of eigenstate basis===========\npsik_DW = np.zeros((dw_grid.Ngrid,Neig),dtype=np.complex128)\nfor i in range(Neig):\n    psik_DW[:,i] = dw_grid.x2k_wave(psi_DW[:,i])\n\n#hamiltonian\nH_dw = np.diag(eneg_DW)\n\n#The operator in the eigenstate\nxmat_eig = tb.trans_basis_diag(dw_grid.xgrid, Neig, psi_DW)*dw_grid.dx\npmat_eig = tb.trans_basis_diag(dw_grid.kgrid, Neig, psik_DW)*dw_grid.dk\n\n#creation/annihilation operator\namat_eig = xmat_eig.copy()*np.sqrt(mass0*omega/2)+1j*pmat_eig.copy()/np.sqrt(mass0*omega*2)\nadegmat_eig = xmat_eig.copy()*np.sqrt(mass0*omega/2)-1j*pmat_eig.copy()/np.sqrt(mass0*omega*2)\n\n#define the population on the left/right well and transform to eigen state basis\nx_barrier = 0.37321768\nP_R = np.heaviside(xgrid-x_barrier,1)\nP_L = 1 - np.heaviside(xgrid-x_barrier,1)\n\nP_R_eig = tb.trans_basis_diag(P_R, Neig, psi_DW)*dw_grid.dx\nP_L_eig = tb.trans_basis_diag(P_L, Neig, psi_DW)*dw_grid.dx\n</code></pre>"},{"location":"qflux/Open_Systems/DoubleWellOpen/#set-up-the-initial-state","title":"Set Up the Initial State","text":"<p>We set the initial state to the eigenstate \\(|\\phi_6\\rangle\\), which is the first eigenstate localized in the right well:</p> \\[ |\\psi(0)\\rangle = |\\phi_6\\rangle; \\quad \\rho(0) = |\\psi(0)\\rangle \\langle \\psi(0)| \\] <pre><code>#initial density matrix\nini_occu = np.zeros(Neig,dtype=np.complex128)\nini_occu[5] = 1.0\nrho0 = np.outer(ini_occu,ini_occu.conj())\n</code></pre>"},{"location":"qflux/Open_Systems/DoubleWellOpen/#classical-simulation","title":"Classical Simulation","text":"<p>Following a similar procedure as outlined in Basics of open system simulation, we use the predefined initial state, system Hamiltonian, collapse operators, and observables to instantiate the <code>DynamicsOS</code> class. We then perform long-time evolution using the <code>propagate_matrix_exp</code> method.</p> <pre><code>gamma1 = np.sqrt(kappa*(nth+1))\ngamma2 = np.sqrt(kappa*(nth))\nc_ops = [gamma1*amat_eig, gamma2*adegmat_eig]\n\n#instantiate the DynamicsOS class\ndw_eig = DynamicsOS(Nsys = Neig, Hsys = H_dw, rho0 = rho0, c_ops = c_ops)\n\n#the observable\nobservable = P_R_eig\n\n#propagate to long time\ntime_long = np.linspace(0,20000/pa.au2fs,60)\n\n#propagate using matrix exponential propagation\nresult_dw_l = dw_eig.propagate_matrix_exp(time_long, observable, Is_store_state = True, Is_show_step=True, Is_Gt=True)\n</code></pre> <p>We can visualize the population in the right well as a function of time:</p> <p></p> <p>We can also visualize the time evolution of the proton's probability distribution over the double-well potential:</p>"},{"location":"qflux/Open_Systems/DoubleWellOpen/#quantum-simulation","title":"Quantum Simulation","text":"<p>Using the <code>QubitDynamicsOS</code> class from the <code>qflux.open_systems.quantum_simulation</code> module, <code>qflux</code> enables quantum simulation of the Lindblad equation. When the system has a Hilbert space dimension of \\(N=32\\), the vectorized density matrix becomes a state vector of dimension \\(N^2\\), and the corresponding propagator is of size \\(N^2 \\times N^2\\). For such large-dimensional systems, we can utilize the Kraus operator representation to evolve the system dynamics.</p> <p>Therefore, compared to the approach used in the Basic of open system simulation example\u2014where quantum circuits are constructed based on the full propagator\u2014the Kraus operator representation reduces the number of required qubits from \\(log_{2}N^2\\) to \\(log_2 N\\). However, the trade-off is that multiple circuits (corresponding to multiple Kraus operators) must be executed.</p> <p>The Kraus operator representation is defined as:</p> \\[     \\rho(t) = \\sum_i M_i(t) \\rho(0) M_i^\\dagger (t) \\] <p>where \\(M_i(t)\\) are the Kraus operators (\\(N\\times N\\) matrix) that describe the evolution of the system. These Kraus operators define a mapping from \\(\\rho(0)\\) to \\(\\rho(t)\\). This approach avoids the need to vectorize the density matrix and instead evolves a state vector directly in the system's original \\(N\\)-dimensional Hilbert space.</p> <p>With the initial density matrix written as \\(\\rho(0)  = \\sum_n p_n(0) |\\psi_n (0)\\rangle \\langle \\psi_n (0)|\\) (in our example, \\(\\rho (0) = | \\phi_{6} \\rangle \\langle \\phi_{6} |\\) ), we have</p> \\[     \\rho(t) = \\sum_{in} p_n(0) |\\psi_n (0)\\rangle \\langle \\psi_n (0)| \\;\\; \\] <p>where</p> \\[     |\\psi^i_n(t)\\rangle =  M_i(t) |\\psi_n (0)\\rangle \\] <p>is the state obtained by applying the Kraus operator \\(M_i(t)\\) to the initial state \\(|\\psi_n (0)\\rangle\\).</p> <p>Quantum simulation can be carried out through the following steps:</p> <ul> <li> <p>Initialize the qubit statevector to \\(|\\psi_n (0)\\rangle\\).</p> </li> <li> <p>Construct Kraus operators \\(M_i(t)\\) and the corresponding quantum gates \\(\\mathbf{U}_{M_i}(t)\\). For non-unitary \\(M_i(t)\\), <code>qflux</code> provides a dilation method (default: <code>'Sz.-Nagy'</code>) to implement the operation within an enlarged Hilbert space.</p> </li> <li> <p>Execute the quantum circuits to obtain \\(|\\psi^i_n(t)\\rangle\\) for each Kraus path, and reconstruct the density matrix from all resulting trajectories \\(|\\psi^i_n(t)\\rangle\\).</p> </li> </ul> <p>For the observable \\(P_R (t)\\), we have:</p> \\[ \\begin{aligned}     P_R(t) &amp;= \\mathrm{Tr}[\\rho(t) \\hat{P}_R] \\\\            &amp;= \\sum_i \\mathrm{Tr}\\left[ M_i(t) |\\psi(0)\\rangle\\langle \\psi(0)| M_i^\\dagger(t) \\, \\hat{P}_R \\right] \\\\            &amp;= \\sum_i \\langle \\psi_i(t) | \\hat{P}_R | \\psi_i(t) \\rangle, \\end{aligned} \\] <p>which means that in quantum simulation, one simply needs to measure the expectation value of \\(\\hat{P}_R\\)  with respect to each \\(|\\psi^i_n(t)\\rangle\\), and then sum over all results to obtain \\(P_R (t)\\).</p> <p><code>qflux</code> provides quantum circuit simulation based on the Kraus operator representation. To enable this, one simply needs to set <code>rep='Kraus'</code> when instantiating the <code>QubitDynamicsOS</code> class.</p> <p>The <code>qc_simulation_kraus</code> function can then be used to simulate the Lindblad dynamics using the Kraus operator representation. </p> <p>This function first computes the propagator (unless it is provided as input), and then calls the <code>gen_Kraus_list</code> method to construct the corresponding set of Kraus operators from the propagator, using methods described in this paper and this paper, with a specified tolerance parameter <code>tolk</code>.</p> <p>Once the Kraus operators are obtained, <code>qc_simulation_kraus</code> performs the quantum simulation and evaluates the observable of interest \u2014 in this case,  \\(\\hat{P}_R\\):</p> <pre><code>#extract the propagator from result of classical simulation,\n#and expand to match the dimension of qubit space\n#For saving calculation, only choose some time points\nilarge = 5\nnsteps = int(len(time_long)/ilarge)\ntime_qdw = np.zeros(nsteps)\nGprop_dw = []\n\nfor i0 in range(nsteps):\n    i = i0*ilarge\n    org_dim = result_dw_l.density_matrix[i].shape[0]\n    Gprop_dw.append(result_dw_l.Gprop[i])\n\n    time_qdw[i0] = time_long[i]\n\n#double well instance\ndw_quantum = QubitDynamicsOS(rep='Kraus', Nsys=Neig, Hsys=H_dw, rho0=rho0, c_ops = c_ops)\ndw_quantum.set_observable(P_R_eig)\n\n#running the quantum simulation\nP_dw_qc = dw_quantum.qc_simulation_kraus(time_qdw, Gprop = Gprop_dw, tolk = 1E-2, tolo = 5E-3)\n</code></pre> <p>One can visualize \\(P_R(t)\\) after the simulation is complete:</p> <p></p>"},{"location":"qflux/Open_Systems/basics/","title":"Tutorial on Simulating Open Quantum System Dynamics","text":"<p>Here, we present the general procedure for simulating open quantum system dynamics using <code>qflux</code>.</p>"},{"location":"qflux/Open_Systems/basics/#what-is-an-open-quantum-system","title":"What is an Open Quantum System?","text":"<p>An open system represents a system that interacts with its surrounding environment, and these interactions fundamentally affect the dynamics of the system. Due to the presence of the environment, the system\u2019s evolution can no longer be described by the Schr\u00f6dinger equation. For instance, while the Schr\u00f6dinger equation describes unitary evolution with conserved system energy, open systems exhibit energy exchange with the environment, which can lead to gradual energy dissipation.</p> <p>Due to the large number of degrees of freedom in the environment, it is generally impractical to directly solve the Schr\u00f6dinger equation for the combined system and environment. As a result, many equations of motion have been developed to describe the dynamics of open quantum systems under various approximations. One of the most popular forms of a trace-preserving evolution equation is the Lindblad master equation, given by</p> \\[ \\frac{d\\rho{(t)}}{dt} = - \\frac{i}{\\hbar}[H,\\rho(t)] + \\frac{1}{2}\\sum_n\\gamma_n\\left[2L_n \\rho(t)L_n^\\dagger - \\rho(t) L_n^\\dagger L_n - L_n^\\dagger L_n \\rho(t)\\right] \\] <p>In this equation, here \\(\\rho(t)\\) is the reduced density matrix of the system, and \\(H\\) represents the Hamiltonian of the system. The jump operators \\(L_n\\) represent the environmental effects on the dynamics, with the rates \\(\\gamma_n\\) quantifying these effects.</p> <p>The purpose of this tutorial is to demonstrate how to solve the Lindblad equation described above using <code>qflux</code>, both on classical and quantum computing platforms. To that end, we first introduce the general procedure for solving the equation, and then illustrate it with a spin-1/2 example to familiarize the reader with the basic usage of <code>qflux</code>.</p> <p>To numerically solve the Lindblad equation, <code>qflux</code> adopts a matrix\u2013vector multiplication approach. This method leverages commonly used Python packages such as <code>NumPy</code> and <code>SciPy</code>, and consists of three main steps:</p> <ul> <li> <p>vectorizing the density matrix,</p> </li> <li> <p>converting the Lindblad equation into a matrix\u2013vector form</p> </li> <li> <p>integrating the resulting equation to obtain the time evolution of the system.</p> </li> </ul>"},{"location":"qflux/Open_Systems/basics/#vectorizing-the-density-matrix","title":"Vectorizing the density matrix:","text":"<p>The density matrix \\(\\rho(t)\\) of a system with an N-dimensional Hilbert space is an \\(N\\times N\\) matrix. For numerical purposes, it is reshaped into a vector of dimension \\(N^2\\).</p> \\[\\rho \\to |\\nu_{\\rho} \\rangle= \\left[ \\rho_{11}, \\ldots, \\rho_{1N}, \\rho_{21}, \\ldots, \\rho_{2N}, \\ldots, \\rho_{N1}, \\ldots, \\rho_{NN} \\right]^\\top\\] <p>Here the superscript \"\\(\\top\\)\" represents a transpose operation. This is equivalent to working in Liouville space, where operators are represented as vectors and superoperators act as matrices.</p>"},{"location":"qflux/Open_Systems/basics/#converting-the-lindblad-equation-into-a-matrixvector-form","title":"Converting the Lindblad equation into a matrix\u2013vector form","text":"<p>The Lindblad equation can be recast into the equivalent matrix-vector form:</p> \\[\\frac{\\mathrm{d}|\\nu_{\\rho}(t) \\rangle}{\\mathrm{d}t} = -i H_{\\mathrm{eff}} |\\nu_{\\rho}(t) \\rangle\\;\\;\\] <p>Where the effective Hamiltonian is \\(H_{\\mathrm{eff}} = H_C + i H_D\\), with \\(H_C\\) and \\(H_D\\) representing the \\(N^2 \\times N^2\\) matrix forms of the commutator and the Lindbladian dissipator, respectively:</p> \\[ H_C = H \\otimes \\mathbb{I}-\\mathbb{I} \\otimes H^T ~~ \\] \\[ H_D = \\sum_{n} \\frac{1}{2} \\gamma_{n} \\left[ 2L_{n}\\otimes L^*_{n} - \\mathbb{I}\\otimes L^T_{n} L^*_{n} - L^\\dagger_{n} L_{n} \\otimes \\mathbb{I}     \\right] ~~ \\] <p>Here, \\(L^*_{n}\\) is the complex conjugate of \\(L_{n}\\) and \\(\\mathbb{I}\\) is the identity matrix in the Hilbert space of the Hamiltonian \\(H\\).</p>"},{"location":"qflux/Open_Systems/basics/#integrating-the-lindblad-equation","title":"Integrating the Lindblad equation","text":"<p>The density matrix at time \\(t\\) can be expressed as the action of the exponential of the matrix \\(-i H_{\\mathrm{eff}}\\) on the vectorized density matrix at \\(t=0\\),</p> \\[ | \\nu_{\\rho}(t)\\rangle = \\mathbf{G}(t)       | \\nu_{\\rho}(0)\\rangle \\] <p>where \\(\\mathbf{G}(t)\\) is called the propagator, and is defined as \\(\\mathbf{G}(t)=e^{-i H_{\\mathrm{eff}}t}\\).</p>"},{"location":"qflux/Open_Systems/basics/#solve-the-lindblad-equation","title":"Solve the Lindblad equation","text":"<p>As a reminder, the task at hand is compute the time evolution of the density matrix according to the Lindblad equation:</p> \\[     | \\nu_{\\rho}(t)\\rangle = \\mathbf{G}(t)       | \\nu_{\\rho}(0)\\rangle ~~ \\] <p>To do this, we must:</p> <ul> <li> <p>Define the initial state \\(| \\nu_{\\rho}(0)\\rangle\\)</p> </li> <li> <p>Define the propagator \\(\\mathbf{G}(t)\\) describing the time-evolution.</p> </li> <li> <p>Define a propagation time-step and the number of time steps for which we want to compute the evolved density matrix.</p> </li> </ul> <p>We now describe in detail how to solve the Lindblad equation using the <code>DynamicsOS</code> class from the <code>qflux.open_systems</code> module.</p>"},{"location":"qflux/Open_Systems/basics/#definition-of-the-initial-state","title":"Definition of the Initial State","text":"<p>The initial state is the vectorized density matrix \\(| \\nu_{\\rho}(0)\\rangle\\). However, the <code>DynamicsOS</code> class in <code>qflux.open_system</code> automatically performs the vectorization, so the user only needs to define the initial density matrix \\(\\rho(0)\\) as an \\(N\\times N\\) array and pass it to the <code>DynamicsOS</code> class.</p> <p>As an example, consider a single spin-1/2 system. We define the spin-up and spin-down states as</p> \\[   |\\uparrow\\rangle = |0\\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\qquad     |\\downarrow\\rangle = |1\\rangle = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} ~~ \\] <p>This Hilbert space dimension of spin-1/2 is 2, so the initial density matrix \\(\\rho(0)\\) is a \\(2\\times 2\\) array. If the system is initially in the spin-up state, then</p> \\[ \\rho(0) = |0\\rangle\\langle 0| \\] <p>This can be defined in Python as:</p> <pre><code>import numpy as np\n# Initial density matrix\nspin_up = np.array([1.0, 0.0], dtype=np.float64)\nspin_down = np.array([0.0, 1.0], dtype=np.float64)\nrho0_1spin = np.outer(spin_up, spin_up.conj())\n</code></pre>"},{"location":"qflux/Open_Systems/basics/#definition-of-the-propagator","title":"Definition of the propagator","text":"<p>The propagator \\(\\mathbf{G}(t)\\) is defined as \\(\\mathbf{G}(t)=e^{-i H_{\\mathrm{eff}}t}\\). Where the effective Hamiltonian is \\(H_{\\mathrm{eff}} = H_C + i H_D\\), with</p> \\[     H_C = H \\otimes \\mathbb{I}-\\mathbb{I} \\otimes H^T ~~, \\] \\[     H_D = \\sum_{n} \\frac{1}{2} \\gamma_{n} \\left[ 2L_{n}\\otimes L^*_{n} - \\mathbb{I}\\otimes L^T_{n} L^*_{n} - L^\\dagger_{n} L_{n} \\otimes \\mathbb{I}     \\right] ~~ \\] <p>Given the system Hamiltonian \\(H\\), the jump operators \\(L_n\\), and their corresponding rates \\(\\gamma_n\\), the propagator \\(\\mathbf{G}(t)\\) is fully specified.</p> <p>The computation of \\(\\mathbf{G}(t)\\) is encapsulated within the <code>Gt_matrix_expo</code> function of the <code>DynamicsOS</code> class. The user only needs to provide \\(H\\), \\(L_n\\), and \\(\\gamma_n\\) during the initialization of the <code>DynamicsOS</code> class.</p> <p>Continuing with the spin-1/2 system as an example, we define the Hamiltonian as</p> \\[ H = E_0 \\sigma^z + \\Delta \\sigma^x \\] <p>where \\(\\sigma^z\\) and \\(\\sigma^x\\) are Pauli matrices.</p> <pre><code>X = np.array([[0, 1], [1, 0]], dtype=np.complex128)\nY = np.array([[0, -1j], [1j, 0]], dtype=np.complex128)\nZ = np.array([[1, 0], [0, -1]], dtype=np.complex128)\n\nE0 = 0.0\nDelta = 0.1 * np.pi * 2\n\n# The Spin-1/2 system Hamiltonian\nH_1spin = E0*Z + Delta*X\n</code></pre> <p>Here we set \\(E_0 = 0\\), \\(\u2206 = 0.1 \\times 2\u03c0\\). In <code>qflux</code>, the jump operator \\(L_n\\) and the damping rate \\(\\gamma_n\\) are combined into a collapse operator, defined as \\(C_n = \\sqrt{\\gamma_n}L_n\\). This collapse operator is then passed to the <code>DynamicsOS</code>. For example, if only a single jump operator exist with \\(L = \\sigma^x\\) and \\(\\gamma=0.05\\), we have:</p> <pre><code># The jump operator and damping rate of Spin-1/2 system\ngamma_1spin = 0.05\nL_1spin = np.sqrt(gamma_1spin)*X\n</code></pre> <p>With these definitions in place, the <code>DynamicsOS</code> class can be initialized as follows:</p> <pre><code>from qflux.open_systems.numerical_methods import DynamicsOS\nspin1_dissipative = DynamicsOS(Nsys=2, Hsys=H_1spin, rho0=rho0_1spin, c_ops = [L_1spin])\n</code></pre> <p>Note that the <code>c_ops</code> argument in <code>DynamicsOS</code> is a list. For example, setting <code>c_ops = [L_1spin]</code> specifies that the Lindblad equation involves only a single collapse operator <code>L_1spin</code>. If multiple collapse operators are present, they can be simulated by simply including all of them in the list.</p> <p>If no collapse operators are specified, <code>c_ops</code> defaults to an empty list. In this case, the code will still run, corresponding to the solution of the Liouville\u2013von Neumann equation for a closed system (i.e., unitary evolution without environmental effects).</p>"},{"location":"qflux/Open_Systems/basics/#define-simulation-time-and-run-the-dynamics","title":"Define Simulation Time and Run the Dynamics","text":"<p>Given a time array for the simulation, the <code>propagate_matrix_exp</code> method in the <code>DynamicsOS</code> class computes the time evolution operator \\(\\mathbf{G}(t)\\), and subsequently solves the Lindblad equation to obtain the density matrix \\(\\rho(t)\\). If an observable is specified, the method also returns the time-dependent expectation values of that observable.</p> <pre><code>time_arr = np.linspace(0, (250 - 1) * 0.1, 250)\n#matrix exponential propagation\nresult_matrix_exp = spin1_dissipative.propagate_matrix_exp(time_arr=time_arr, observable=Z, Is_store_state=True, Is_Gt = True)\n</code></pre> <p>After execution, <code>result_matrix_exp</code> is an object that contains the following information evaluated at each time in <code>time_arr</code>:</p> <ul> <li> <p>A list of expectation values of the observable</p> </li> <li> <p>A list of density matrices (if <code>Is_store_state=True</code>), and</p> </li> <li> <p>A list of propagators (if <code>Is_Gt=True</code>).</p> </li> </ul> <p>Note that in most cases, only the observable is of interest. Therefore, both <code>Is_store_state</code> and <code>Is_Gt</code> are set to <code>False</code> by default.</p> <p><code>qflux</code> also provides an interface to the <code>mesolve</code> function from <code>QuTiP</code> as an alternative method for propagating the Lindblad equation, which facilitates direct comparison between different approaches. It is integrated into the <code>propagate_qt</code> method of the <code>DynamicsOS</code> class.</p> <pre><code>expec_vals_qutip_Lindblad = spin1_dissipative.propagate_qt(time_arr=time_arr, observable=Z)\n</code></pre>"},{"location":"qflux/Open_Systems/basics/#quantum-simulation-of-the-lindblad-equation","title":"Quantum Simulation of the Lindblad Equation","text":"<p>Using the <code>QubitDynamicsOS</code> class from the <code>qflux.open_systems.quantum_simulation</code> module, <code>qflux</code> enables quantum simulation of the Lindblad equation. The procedure closely parallels the classical simulation workflow: first, define the initial state, system Hamiltonian, and collapse operators, and then instantiate a <code>QubitDynamicsOS</code> object accordingly.</p> <pre><code>from qflux.open_systems.quantum_simulation import QubitDynamicsOS\n\nspin1_quantum = QubitDynamicsOS(rep='Density', Nsys=2, Hsys=H_1spin, rho0=rho0_1spin, c_ops = [L_1spin])\n</code></pre> <p>The <code>QubitDynamicsOS</code> class in <code>qflux</code> performs quantum simulation of the Lindblad equation using <code>Qiskit</code> backends and interfaces. It provides a simplified interface for executing quantum simulations via <code>Qiskit</code>.</p> <p>By default, the backend is set to <code>Qiskit Aer</code>'s <code>AerSimulator</code>. The parameter <code>rep</code> can be either <code>'Density'</code> or <code>'Kraus'</code>, which determines how the density matrix is encoded into a quantum state vector. In this tutorial, we use the default option <code>'Density'</code>, which corresponds to vectorizing the density matrix.</p> <p>Since open system dynamics are intrinsically non-unitary, and quantum circuits are built from unitary gates, a dilation approach is employed to represent non-unitary propagators within an enlarged Hilbert space using extra qubits. Various dilation methods have been developed, and the default method used here is <code>'Sz-Nagy'</code>.</p> <p>For more detailed explanations of these parameters, please refer to the source code documentation.</p> <pre><code>spin1_quantum.set_dilation_method('Sz-Nagy')\n</code></pre> <p>In quantum simulation, the final measurement requires specifying the target basis states. For a spin-1/2 system, the \\(2\\times 2\\) density matrix \\(\\rho(t)\\) is encoded into two qubits. With one additional qubit used for dilation, a total of three qubits are involved.</p> <p>Here, we measure the quantum states \\(|000\\rangle\\) and \\(|011\\rangle\\), which correspond to extracting the populations \\(\\langle 0|\\rho|0\\rangle\\) and \\(\\langle 1|\\rho|1\\rangle\\), respectively.</p> <p>Once the time array <code>time_arr</code> is defined, the method <code>qc_simulation_vecdens</code> can be used to perform the quantum simulation.</p> <pre><code>#set qubit state to measurement\nspin1_quantum.set_count_str(['000','011'])\n#run the quantum simulation\nPop_qc = spin1_quantum.qc_simulation_vecdens(time_arr)\n</code></pre> <p>One can verify that the quantum simulation results are consistent with the corresponding classical results.</p> <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(6,2))\nplt.plot(time_arr,Pop_qc[:,0]-Pop_qc[:,1],'r-',label=\"quantum\")\nplt.plot(time_arr,result_matrix_exp.expect,'k--',label=\"classical\")\nplt.xlabel('time (ps)',fontsize=15)\nplt.ylabel('$P(t)$',fontsize=15)\nplt.legend(fontsize=10)\n</code></pre> <p></p> <p>One can also visualize an example quantum circuit from the result output of the <code>qc_simulation_vecdens</code> method (here, we use the circuit at the 100th time step as an example): <pre><code>res_qc['circuits'][100].draw('mpl')\n</code></pre> </p> <p>The circuit complexity can be further illustrated by transpiling it into a specific basis gate set. Here, we adopt the basis gates used for the <code>ibm_kingston</code> backend:</p> <p><pre><code>from qiskit import transpile\n\nbasis_gates = ['cz', 'id', 'rx', 'rz', 'rzz', 'sx', 'x']\ncompiled_circuit = transpile(result_qc['circuits'][100], basis_gates=basis_gates, optimization_level=1)\ncompiled_circuit.draw('mpl')\n</code></pre> </p>"},{"location":"qflux/Open_Systems/os_api/","title":"Open Systems Module","text":""},{"location":"qflux/Open_Systems/os_api/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>open_systems</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/Open_Systems/os_api/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/Open_Systems/os_api/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/Open_Systems/os_api/#source-code","title":"Source Code","text":""},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems","title":"<code>qflux.open_systems</code>","text":""},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DynamicsOS","title":"<code>DynamicsOS</code>","text":"<p>Class for open-system dynamics (Lindblad equation).</p> <p>This class provides methods to simulate open-system dynamics described by the Lindblad equation.</p> <p>Attributes:</p> Name Type Description <code>Nsys</code> <code>int</code> <p>System Hilbert Space Dimension.</p> <code>Hsys</code> <code>ndarray</code> <p>Hamiltonian of the system (shape (N, N)).</p> <code>rho0</code> <code>ndarray</code> <p>Initial density matrix (shape (N, N)).</p> <code>c_ops</code> <code>List[ndarray]</code> <p>List of collapse operators (each of shape (N, N)).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>class DynamicsOS:\n    \"\"\"Class for open-system dynamics (Lindblad equation).\n\n    This class provides methods to simulate open-system dynamics described by the Lindblad equation.\n\n    Attributes:\n        Nsys (int): System Hilbert Space Dimension.\n        Hsys (np.ndarray): Hamiltonian of the system (shape (N, N)).\n        rho0 (np.ndarray): Initial density matrix (shape (N, N)).\n        c_ops (List[np.ndarray]): List of collapse operators (each of shape (N, N)).\n    \"\"\"\n\n    def __init__(\n        self,\n        Nsys: int,\n        Hsys: np.ndarray,\n        rho0: np.ndarray,\n        c_ops: Optional[List[np.ndarray]] = None\n    ) -&gt; None:\n        \"\"\"\n        Initialize the DynamicsOS instance.\n\n        Args:\n            Nsys (int): System Hilbert Space Dimension.\n            Hsys (np.ndarray): Hamiltonian of the system.\n            rho0 (np.ndarray): Initial density matrix.\n            c_ops (Optional[List[np.ndarray]]): List of collapse operators. Defaults to an empty list.\n        \"\"\"\n        if c_ops is None:\n            c_ops = []\n        self.Nsys: int = Nsys\n        self.Hsys: np.ndarray = Hsys\n        self.rho0: np.ndarray = rho0\n        self.c_ops: List[np.ndarray] = c_ops\n\n    def Gt_matrix_expo(self, time_arr: List[float], Is_show_step: bool = False) -&gt; List[np.ndarray]:\n        \"\"\"\n        Compute the propagator of the Lindblad equation using the matrix exponential.\n\n        The propagator is computed by exponentiating the Liouvillian operator defined by the\n        system Hamiltonian and collapse operators.\n\n        Args:\n            time_arr (List[float]): Array of time values for the simulation.\n            Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n\n        Returns:\n            List[np.ndarray]: List of propagators corresponding to each time in `time_arr`.\n        \"\"\"\n        ident_h: np.ndarray = np.eye(self.Nsys, dtype=np.complex128)\n\n        # Build the A matrix for time-derivation of the vectorized density matrix.\n        Amat: np.ndarray = -1j * (np.kron(self.Hsys, ident_h) - np.kron(ident_h, self.Hsys.T))\n        for i in range(len(self.c_ops)):\n            Amat += 0.5 * (\n                2.0 * np.kron(self.c_ops[i], self.c_ops[i].conj())\n                - np.kron(ident_h, (self.c_ops[i].T @ self.c_ops[i].conj()))\n                - np.kron((self.c_ops[i].T.conj() @ self.c_ops[i]), ident_h)\n            )\n\n        G_prop: List[np.ndarray] = []\n        for i, t in enumerate(time_arr):\n            if Is_show_step:\n                print(\"step\", i, \"time\", t)\n            Gt: np.ndarray = LA.expm(Amat * t)\n            G_prop.append(Gt)\n        return G_prop\n\n    def propagate_matrix_exp(\n        self,\n        time_arr: List[float],\n        observable: np.ndarray,\n        Is_store_state: bool = False,\n        Is_show_step: bool = False,\n        Is_Gt: bool = False,\n    ) -&gt; Any:\n        \"\"\"\n        Solve the Lindblad equation using matrix exponential.\n\n        This method computes the propagator, evolves the initial density matrix, and calculates\n        the expectation value of the observable over time. Optionally, it stores the evolved density matrices.\n\n        Args:\n            time_arr (List[float]): Time array for dynamic simulation.\n            observable (np.ndarray): Observable matrix for which the expectation value is computed.\n            Is_store_state (bool, optional): If True, stores the density matrices at each time step.\n                                             Defaults to False.\n            Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n            Is_Gt (bool, optional): If True, includes the propagators in the result. Defaults to False.\n\n        Returns:\n            Result: An object with the following attributes:\n                - expect (List[float]): List of expectation values over time.\n                - density_matrix (List[np.ndarray], optional): List of density matrices (if `Is_store_state` is True).\n                - Gprop (List[np.ndarray], optional): List of propagators (if `Is_Gt` is True).\n        \"\"\"\n\n        class Result:\n            \"\"\"Class for storing propagation results.\"\"\"\n            def __init__(self, store_state: bool, include_Gt: bool) -&gt; None:\n                self.expect: List[float] = []\n                if store_state:\n                    self.density_matrix: List[np.ndarray] = []\n                if include_Gt:\n                    self.Gprop: Optional[List[np.ndarray]] = None\n\n        result = Result(Is_store_state, Is_Gt)\n\n        # Compute the propagator of the Lindblad equation.\n        G_prop: List[np.ndarray] = self.Gt_matrix_expo(time_arr, Is_show_step)\n        if Is_Gt:\n            result.Gprop = G_prop\n\n        # Initialize the vectorized density matrix.\n        vec_rho0: np.ndarray = self.rho0.reshape(self.Nsys**2)\n\n        for i, _ in enumerate(time_arr):\n            vec_rhot: np.ndarray = G_prop[i] @ vec_rho0\n            # Reshape back to density matrix form.\n            rhot: np.ndarray = vec_rhot.reshape(self.Nsys, self.Nsys)\n\n            if Is_store_state:\n                result.density_matrix.append(rhot)\n            result.expect.append(np.trace(rhot @ observable).real)\n\n        return result\n\n    def propagate_qt(self, time_arr: List[float], observable: Any, **kwargs: Any) -&gt; List[float]:\n        \"\"\"\n        Propagate the system using QuTiP's `mesolve` function.\n\n        This method solves the Lindblad master equation using QuTiP's `mesolve` to compute the expectation\n        values of the observable over time.\n\n        Args:\n            time_arr (List[float]): Time array for dynamic simulation.\n            observable (Any): Observable operator(s) for which the expectation value is computed.\n                              Can be a single operator or a list of operators.\n            **kwargs: Additional keyword arguments to pass to `mesolve`.\n\n        Returns:\n            List[float]: List of expectation values of the observable over time.\n        \"\"\"\n        c_ops: List[Qobj] = [Qobj(c_op) for c_op in self.c_ops]\n\n        if isinstance(observable, list):\n            obs = [Qobj(op) for op in observable]\n        else:\n            obs = Qobj(observable)\n\n        result = mesolve(Qobj(self.Hsys), Qobj(self.rho0), time_arr, c_ops, obs, **kwargs)\n        return result.expect\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DynamicsOS.Gt_matrix_expo","title":"<code>Gt_matrix_expo(time_arr, Is_show_step=False)</code>","text":"<p>Compute the propagator of the Lindblad equation using the matrix exponential.</p> <p>The propagator is computed by exponentiating the Liouvillian operator defined by the system Hamiltonian and collapse operators.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Array of time values for the simulation.</p> required <code>Is_show_step</code> <code>bool</code> <p>If True, prints the current simulation step. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List[np.ndarray]: List of propagators corresponding to each time in <code>time_arr</code>.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def Gt_matrix_expo(self, time_arr: List[float], Is_show_step: bool = False) -&gt; List[np.ndarray]:\n    \"\"\"\n    Compute the propagator of the Lindblad equation using the matrix exponential.\n\n    The propagator is computed by exponentiating the Liouvillian operator defined by the\n    system Hamiltonian and collapse operators.\n\n    Args:\n        time_arr (List[float]): Array of time values for the simulation.\n        Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n\n    Returns:\n        List[np.ndarray]: List of propagators corresponding to each time in `time_arr`.\n    \"\"\"\n    ident_h: np.ndarray = np.eye(self.Nsys, dtype=np.complex128)\n\n    # Build the A matrix for time-derivation of the vectorized density matrix.\n    Amat: np.ndarray = -1j * (np.kron(self.Hsys, ident_h) - np.kron(ident_h, self.Hsys.T))\n    for i in range(len(self.c_ops)):\n        Amat += 0.5 * (\n            2.0 * np.kron(self.c_ops[i], self.c_ops[i].conj())\n            - np.kron(ident_h, (self.c_ops[i].T @ self.c_ops[i].conj()))\n            - np.kron((self.c_ops[i].T.conj() @ self.c_ops[i]), ident_h)\n        )\n\n    G_prop: List[np.ndarray] = []\n    for i, t in enumerate(time_arr):\n        if Is_show_step:\n            print(\"step\", i, \"time\", t)\n        Gt: np.ndarray = LA.expm(Amat * t)\n        G_prop.append(Gt)\n    return G_prop\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DynamicsOS.__init__","title":"<code>__init__(Nsys, Hsys, rho0, c_ops=None)</code>","text":"<p>Initialize the DynamicsOS instance.</p> <p>Parameters:</p> Name Type Description Default <code>Nsys</code> <code>int</code> <p>System Hilbert Space Dimension.</p> required <code>Hsys</code> <code>ndarray</code> <p>Hamiltonian of the system.</p> required <code>rho0</code> <code>ndarray</code> <p>Initial density matrix.</p> required <code>c_ops</code> <code>Optional[List[ndarray]]</code> <p>List of collapse operators. Defaults to an empty list.</p> <code>None</code> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def __init__(\n    self,\n    Nsys: int,\n    Hsys: np.ndarray,\n    rho0: np.ndarray,\n    c_ops: Optional[List[np.ndarray]] = None\n) -&gt; None:\n    \"\"\"\n    Initialize the DynamicsOS instance.\n\n    Args:\n        Nsys (int): System Hilbert Space Dimension.\n        Hsys (np.ndarray): Hamiltonian of the system.\n        rho0 (np.ndarray): Initial density matrix.\n        c_ops (Optional[List[np.ndarray]]): List of collapse operators. Defaults to an empty list.\n    \"\"\"\n    if c_ops is None:\n        c_ops = []\n    self.Nsys: int = Nsys\n    self.Hsys: np.ndarray = Hsys\n    self.rho0: np.ndarray = rho0\n    self.c_ops: List[np.ndarray] = c_ops\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DynamicsOS.propagate_matrix_exp","title":"<code>propagate_matrix_exp(time_arr, observable, Is_store_state=False, Is_show_step=False, Is_Gt=False)</code>","text":"<p>Solve the Lindblad equation using matrix exponential.</p> <p>This method computes the propagator, evolves the initial density matrix, and calculates the expectation value of the observable over time. Optionally, it stores the evolved density matrices.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Time array for dynamic simulation.</p> required <code>observable</code> <code>ndarray</code> <p>Observable matrix for which the expectation value is computed.</p> required <code>Is_store_state</code> <code>bool</code> <p>If True, stores the density matrices at each time step.                              Defaults to False.</p> <code>False</code> <code>Is_show_step</code> <code>bool</code> <p>If True, prints the current simulation step. Defaults to False.</p> <code>False</code> <code>Is_Gt</code> <code>bool</code> <p>If True, includes the propagators in the result. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Any</code> <p>An object with the following attributes: - expect (List[float]): List of expectation values over time. - density_matrix (List[np.ndarray], optional): List of density matrices (if <code>Is_store_state</code> is True). - Gprop (List[np.ndarray], optional): List of propagators (if <code>Is_Gt</code> is True).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def propagate_matrix_exp(\n    self,\n    time_arr: List[float],\n    observable: np.ndarray,\n    Is_store_state: bool = False,\n    Is_show_step: bool = False,\n    Is_Gt: bool = False,\n) -&gt; Any:\n    \"\"\"\n    Solve the Lindblad equation using matrix exponential.\n\n    This method computes the propagator, evolves the initial density matrix, and calculates\n    the expectation value of the observable over time. Optionally, it stores the evolved density matrices.\n\n    Args:\n        time_arr (List[float]): Time array for dynamic simulation.\n        observable (np.ndarray): Observable matrix for which the expectation value is computed.\n        Is_store_state (bool, optional): If True, stores the density matrices at each time step.\n                                         Defaults to False.\n        Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n        Is_Gt (bool, optional): If True, includes the propagators in the result. Defaults to False.\n\n    Returns:\n        Result: An object with the following attributes:\n            - expect (List[float]): List of expectation values over time.\n            - density_matrix (List[np.ndarray], optional): List of density matrices (if `Is_store_state` is True).\n            - Gprop (List[np.ndarray], optional): List of propagators (if `Is_Gt` is True).\n    \"\"\"\n\n    class Result:\n        \"\"\"Class for storing propagation results.\"\"\"\n        def __init__(self, store_state: bool, include_Gt: bool) -&gt; None:\n            self.expect: List[float] = []\n            if store_state:\n                self.density_matrix: List[np.ndarray] = []\n            if include_Gt:\n                self.Gprop: Optional[List[np.ndarray]] = None\n\n    result = Result(Is_store_state, Is_Gt)\n\n    # Compute the propagator of the Lindblad equation.\n    G_prop: List[np.ndarray] = self.Gt_matrix_expo(time_arr, Is_show_step)\n    if Is_Gt:\n        result.Gprop = G_prop\n\n    # Initialize the vectorized density matrix.\n    vec_rho0: np.ndarray = self.rho0.reshape(self.Nsys**2)\n\n    for i, _ in enumerate(time_arr):\n        vec_rhot: np.ndarray = G_prop[i] @ vec_rho0\n        # Reshape back to density matrix form.\n        rhot: np.ndarray = vec_rhot.reshape(self.Nsys, self.Nsys)\n\n        if Is_store_state:\n            result.density_matrix.append(rhot)\n        result.expect.append(np.trace(rhot @ observable).real)\n\n    return result\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DynamicsOS.propagate_qt","title":"<code>propagate_qt(time_arr, observable, **kwargs)</code>","text":"<p>Propagate the system using QuTiP's <code>mesolve</code> function.</p> <p>This method solves the Lindblad master equation using QuTiP's <code>mesolve</code> to compute the expectation values of the observable over time.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Time array for dynamic simulation.</p> required <code>observable</code> <code>Any</code> <p>Observable operator(s) for which the expectation value is computed.               Can be a single operator or a list of operators.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to <code>mesolve</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: List of expectation values of the observable over time.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def propagate_qt(self, time_arr: List[float], observable: Any, **kwargs: Any) -&gt; List[float]:\n    \"\"\"\n    Propagate the system using QuTiP's `mesolve` function.\n\n    This method solves the Lindblad master equation using QuTiP's `mesolve` to compute the expectation\n    values of the observable over time.\n\n    Args:\n        time_arr (List[float]): Time array for dynamic simulation.\n        observable (Any): Observable operator(s) for which the expectation value is computed.\n                          Can be a single operator or a list of operators.\n        **kwargs: Additional keyword arguments to pass to `mesolve`.\n\n    Returns:\n        List[float]: List of expectation values of the observable over time.\n    \"\"\"\n    c_ops: List[Qobj] = [Qobj(c_op) for c_op in self.c_ops]\n\n    if isinstance(observable, list):\n        obs = [Qobj(op) for op in observable]\n    else:\n        obs = Qobj(observable)\n\n    result = mesolve(Qobj(self.Hsys), Qobj(self.rho0), time_arr, c_ops, obs, **kwargs)\n    return result.expect\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS","title":"<code>QubitDynamicsOS</code>","text":"<p>               Bases: <code>DynamicsOS</code></p> <p>Class for simulating quantum dynamics using either vectorized density matrix or Kraus operator representations.</p> <p>This class provides methods to initialize state vectors, construct quantum circuits, and perform quantum simulations using Qiskit backends.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>class QubitDynamicsOS(DynamicsOS):\n    \"\"\"\n    Class for simulating quantum dynamics using either vectorized density matrix or Kraus operator representations.\n\n    This class provides methods to initialize state vectors, construct quantum circuits,\n    and perform quantum simulations using Qiskit backends.\n    \"\"\"\n\n    def __init__(self, rep: str = 'Density', **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize a QubitDynamicsOS instance.\n\n        Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed.\n        Additional keyword arguments are passed to the base DynamicsOS class.\n\n        Args:\n            rep (str, optional): Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.\n            **kwargs: Additional keyword arguments for the DynamicsOS initializer.\n        \"\"\"\n        super().__init__(**kwargs)\n\n        if rep == 'Density':\n            # Vectorized density matrix representation\n            self.rep: str = 'Density'\n            self.Nqb: int = int(np.log2(self.Nsys**2))\n        elif rep == 'Kraus':\n            # Kraus operator representation\n            self.rep = 'Kraus'\n            self.Nqb = int(np.log2(self.Nsys))\n\n        # The counting qubits bit string and observable matrix are initialized to None.\n        self.count_str: Optional[List[str]] = None\n        self.observable: Optional[np.ndarray] = None\n\n        # Default dilation method for quantum simulation.\n        self.dilation_method: str = 'Sz-Nagy'\n\n    def set_dilation_method(self, method: str) -&gt; None:\n        \"\"\"\n        Set the dilation method for quantum simulation.\n\n        Args:\n            method (str): The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.\n        \"\"\"\n        self.dilation_method = method\n\n    def set_count_str(self, count_str: List[str]) -&gt; None:\n        \"\"\"\n        Set the counting bit string for measurement.\n\n        Args:\n            count_str (List[str]): The counting bit string.\n        \"\"\"\n        self.count_str = count_str\n\n    def set_observable(self, observable: np.ndarray) -&gt; None:\n        \"\"\"\n        Set the observable for the quantum simulation.\n\n        Args:\n            observable (np.ndarray): The observable matrix.\n        \"\"\"\n        self.observable = observable\n\n    def init_statevec_vecdens(self) -&gt; Tuple[np.ndarray, float]:\n        \"\"\"\n        Initialize the state vector from the initial density operator using vectorized representation.\n\n        The initial density matrix is reshaped into a vector and normalized.\n\n        Returns:\n            Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm\n            of the original vectorized density matrix.\n        \"\"\"\n        vec_rho0 = self.rho0.reshape(self.Nsys**2)\n        norm0 = LA.norm(vec_rho0, 2)\n        statevec = vec_rho0 / norm0\n        return statevec, norm0\n\n    def init_statevec_Kraus(self, tol: float = 1e-6) -&gt; Tuple[List[np.ndarray], List[float]]:\n        \"\"\"\n        Initialize state vectors from the initial density operator using the Kraus operator representation.\n\n        The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues\n        below the specified tolerance are ignored.\n\n        Args:\n            tol (float, optional): Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.\n\n        Returns:\n            Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of\n            corresponding probabilities.\n        \"\"\"\n        eigenvalues, eigenvectors = LA.eigh(self.rho0)\n        statevec: List[np.ndarray] = []\n        prob: List[float] = []\n        for i in range(len(eigenvalues) - 1, -1, -1):\n            if abs(eigenvalues[i]) &lt; tol:\n                break\n            prob.append(eigenvalues[i])\n            statevec.append(eigenvectors[:, i])\n        return statevec, prob\n\n    def _get_qiskit_observable(self, Isdilate: bool = False, tol: float = 5e-3) -&gt; SparsePauliOp:\n        \"\"\"\n        Prepare and return the Qiskit observable operator.\n\n        Converts the observable matrix to its Pauli representation and returns a SparsePauliOp.\n\n        Args:\n            Isdilate (bool, optional): Flag indicating whether to use the dilated observable.\n                Defaults to False.\n            tol (float, optional): Tolerance for the Pauli decomposition. Defaults to 5e-3.\n\n        Returns:\n            SparsePauliOp: The Qiskit representation of the observable.\n        \"\"\"\n        if self.observable is None:\n            print('Error: observable is None')\n\n        if Isdilate:\n            num_qubits = self.Nqb + 1\n            Obs_mat = np.zeros((2 * self.Nsys, 2 * self.Nsys), dtype=np.complex128)\n            Obs_mat[:self.Nsys, :self.Nsys] = self.observable[:self.Nsys, :self.Nsys]\n        else:\n            num_qubits = self.Nqb\n            Obs_mat = self.observable\n\n        Obs_paulis_dic = tb.ham_to_pauli(Obs_mat, num_qubits, tol=tol)\n\n        # Prepare the Qiskit observable from the Pauli strings of the observable matrix.\n        data: List[str] = []\n        coef: List[float] = []\n        for key in Obs_paulis_dic:\n            data.append(key)\n            coef.append(Obs_paulis_dic[key])\n        obs_q = SparsePauliOp(data, coef)\n        return obs_q\n\n    def qc_simulation_kraus(\n        self,\n        time_arr: List[float],\n        Kraus: Optional[Dict[int, List[np.ndarray]]] = None,\n        backend: Any = AerSimulator(), \n        Gprop: Optional[List[np.ndarray]] = None,\n        tolk: float = 1e-5,\n        tolo: float = 1e-5,\n        Is_store_circuit = False,\n        **kwargs: Any\n        ) -&gt; np.ndarray:\n        \"\"\"\n        Perform quantum simulation using the Kraus operator representation.\n\n        This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach.\n        It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator,\n        and accumulates the measurement results.\n\n        Args:\n            time_arr (List[float]): List of time steps for simulation.\n\n            Kraus (Optional[Dict[int, List[np.ndarray]]], optional): Dictionary mapping time step index to a list of Kraus operators.\n                If None, Kraus operators are generated from the propagator. Defaults to None.\n            backend (Any, optional): Quantum simulation backend. Defaults to AerSimulator().\n            Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n                If None, it will be calculated. Defaults to None.\n            tolk (float, optional): Tolerance for generating Kraus operators. Defaults to 1e-5.\n            tolo (float, optional): Tolerance for observable decomposition. Defaults to 1e-5.\n            Is_store_circuit (bool, optional): If True, store the generated quantum circuits at each time step. Defaults to False.\n            **kwargs: Additional keyword arguments for propagator calculation.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing quantum simulation results, including:\n                - 'data' (np.ndarray): Array of shape (nsteps,), containing the accumulated observable expectation values at each time step.\n                - 'circuits' (List[List[QuantumCircuit]], optional): If `Is_store_circuit` is True, this field contains a list of lists of quantum circuits.\n                  Each outer list corresponds to a time step, and each inner list contains all circuits used for that step (across different Kraus operators and initial states).\n        \"\"\"\n        nsteps = len(time_arr)\n\n        # Generate Kraus operators if not provided.\n        if Kraus is None:\n            Kraus = {}\n            if Gprop is None:\n                print('Calculating the propagator')\n                Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n            print('Generating the Kraus operators')\n            for i in range(nsteps):\n                print('At step', i, 'of', nsteps)\n                Kraus[i] = gen_Kraus_list(Gprop[i], self.Nsys, tol=tolk)\n        print('Kraus operator generation complete')\n\n        # Perform Qiskit simulation using the Estimator.\n        estimator = Estimator(mode=backend)\n\n        statevec, prob = self.init_statevec_Kraus()\n        n_inistate = len(statevec)\n        print('Number of initial states in the density matrix:', n_inistate)\n        print('Probabilities:', prob)\n\n        # Obtain the Qiskit observable.\n        obs_q = self._get_qiskit_observable(Isdilate=True, tol=tolo)\n\n        print('Starting quantum simulation')\n\n        result_simu = {}\n        result_simu['data'] = np.zeros(nsteps, dtype=np.float64)\n        if(Is_store_circuit):  result_simu['circuits'] = [ [] for _ in range(nsteps) ]\n\n        for i in range(nsteps):\n            print('Simulation step', i, 'of', nsteps)\n            current_kraus_list = Kraus[i]\n            print('Number of Kraus operators:', len(current_kraus_list))\n            for kraus_op in current_kraus_list:\n                for istate in range(n_inistate):\n                    qc = self._create_circuit(kraus_op, statevec[istate], Isscale=False)\n                    result = estimator.run([(qc, obs_q)]).result()\n\n                    if(Is_store_circuit):  result_simu['circuits'][i].append(qc)\n                    result_simu['data'][i] += result[0].data.evs * prob[istate]\n\n        return result_simu\n\n    def qc_simulation_vecdens(\n        self,\n        time_arr: List[float],\n        shots: int = 1024,\n        backend: Any = AerSimulator(),\n        Gprop: Optional[List[np.ndarray]] = None,\n        **kwargs: Any\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform quantum simulation using the vectorized density matrix representation.\n\n        This method simulates the quantum system dynamics over a series of time steps by constructing circuits\n        based on the vectorized density matrix representation, performing measurements, and processing the results.\n\n        Args:\n            time_arr (List[float]): List of time steps for simulation.\n            shots (int, optional): Number of measurement shots. Defaults to 1024.\n            backend (Any, optional): Quantum simulation backend. Defaults to AerSimulator().\n            Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n                If None, it will be calculated. Defaults to None.\n            **kwargs: Additional keyword arguments for propagator calculation.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing the quantum simulation results, including:\n                - 'data' (np.ndarray): Array of shape (nsteps, n_bitstr), storing the processed probability amplitudes \n                (i.e., normalized square root of the measured probabilities, scaled by norm factors) at each time step.\n                - 'circuits' (List[QuantumCircuit]): List of generated quantum circuits for each time step.\n                - 'norm' (List[float]): List of norm correction factors used in post-processing at each time step.\n        \"\"\"\n        if Gprop is None:\n            Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n\n        nsteps = len(time_arr)\n\n        if self.count_str is None:\n            print(\"Error: count_str is not assigned\")\n\n        n_bitstr = len(self.count_str)\n        statevec, norm0 = self.init_statevec_vecdens()\n\n        result = {}\n        result['data'] = np.zeros((nsteps, n_bitstr), dtype=np.float64)\n        result['circuits'] = []\n        result['norm'] = []\n\n        for i in range(nsteps):\n            if i % 100 == 0:\n                print('Quantum simulation step', i)\n            Gt = Gprop[i]\n\n            #create the circuit\n            circuit, norm = self._create_circuit(Gt, statevec, Isscale=True)\n            circuit.measure(range(self.Nqb + 1), range(self.Nqb + 1))\n            if self.dilation_method == 'SVD-Walsh':\n                circuit = transpile(circuit, backend)\n\n            #store the circuits and norm to the result\n            result['circuits'].append(circuit)\n            result['norm'].append(norm)\n\n            counts = backend.run(circuit, shots=shots).result().get_counts()\n            for j in range(n_bitstr):\n                bitstr = self.count_str[j]\n                if bitstr in counts:\n                    result['data'][i, j] = np.sqrt(counts[bitstr] / shots) * norm * norm0\n                else:\n                    print('At time', i, 'with shots =', shots, \"no counts for\", bitstr)\n\n        return result\n\n    def _create_circuit(\n        self,\n        array: np.ndarray,\n        statevec: Union[np.ndarray, List[np.ndarray]],\n        Isscale: bool = True\n    ) -&gt; QuantumCircuit:\n        \"\"\"\n        Construct and return the quantum circuit.\n\n        This method wraps the call to the dilation circuit construction function.\n\n        Args:\n            array (np.ndarray): Array used for circuit construction (e.g., propagator or Kraus operator).\n            statevec (Union[np.ndarray, List[np.ndarray]]): State vector(s) to be used in the circuit.\n            Isscale (bool, optional): Flag indicating whether scaling should be applied. Defaults to True.\n\n        Returns:\n            QuantumCircuit: The constructed quantum circuit.\n        \"\"\"\n        return dc.construct_circuit(self.Nqb, array, statevec, method=self.dilation_method, Isscale=Isscale)\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.__init__","title":"<code>__init__(rep='Density', **kwargs)</code>","text":"<p>Initialize a QubitDynamicsOS instance.</p> <p>Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed. Additional keyword arguments are passed to the base DynamicsOS class.</p> <p>Parameters:</p> Name Type Description Default <code>rep</code> <code>str</code> <p>Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.</p> <code>'Density'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the DynamicsOS initializer.</p> <code>{}</code> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def __init__(self, rep: str = 'Density', **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize a QubitDynamicsOS instance.\n\n    Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed.\n    Additional keyword arguments are passed to the base DynamicsOS class.\n\n    Args:\n        rep (str, optional): Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.\n        **kwargs: Additional keyword arguments for the DynamicsOS initializer.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    if rep == 'Density':\n        # Vectorized density matrix representation\n        self.rep: str = 'Density'\n        self.Nqb: int = int(np.log2(self.Nsys**2))\n    elif rep == 'Kraus':\n        # Kraus operator representation\n        self.rep = 'Kraus'\n        self.Nqb = int(np.log2(self.Nsys))\n\n    # The counting qubits bit string and observable matrix are initialized to None.\n    self.count_str: Optional[List[str]] = None\n    self.observable: Optional[np.ndarray] = None\n\n    # Default dilation method for quantum simulation.\n    self.dilation_method: str = 'Sz-Nagy'\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.init_statevec_Kraus","title":"<code>init_statevec_Kraus(tol=1e-06)</code>","text":"<p>Initialize state vectors from the initial density operator using the Kraus operator representation.</p> <p>The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues below the specified tolerance are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of</p> <code>List[float]</code> <p>corresponding probabilities.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def init_statevec_Kraus(self, tol: float = 1e-6) -&gt; Tuple[List[np.ndarray], List[float]]:\n    \"\"\"\n    Initialize state vectors from the initial density operator using the Kraus operator representation.\n\n    The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues\n    below the specified tolerance are ignored.\n\n    Args:\n        tol (float, optional): Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.\n\n    Returns:\n        Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of\n        corresponding probabilities.\n    \"\"\"\n    eigenvalues, eigenvectors = LA.eigh(self.rho0)\n    statevec: List[np.ndarray] = []\n    prob: List[float] = []\n    for i in range(len(eigenvalues) - 1, -1, -1):\n        if abs(eigenvalues[i]) &lt; tol:\n            break\n        prob.append(eigenvalues[i])\n        statevec.append(eigenvectors[:, i])\n    return statevec, prob\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.init_statevec_vecdens","title":"<code>init_statevec_vecdens()</code>","text":"<p>Initialize the state vector from the initial density operator using vectorized representation.</p> <p>The initial density matrix is reshaped into a vector and normalized.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm</p> <code>float</code> <p>of the original vectorized density matrix.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def init_statevec_vecdens(self) -&gt; Tuple[np.ndarray, float]:\n    \"\"\"\n    Initialize the state vector from the initial density operator using vectorized representation.\n\n    The initial density matrix is reshaped into a vector and normalized.\n\n    Returns:\n        Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm\n        of the original vectorized density matrix.\n    \"\"\"\n    vec_rho0 = self.rho0.reshape(self.Nsys**2)\n    norm0 = LA.norm(vec_rho0, 2)\n    statevec = vec_rho0 / norm0\n    return statevec, norm0\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.qc_simulation_kraus","title":"<code>qc_simulation_kraus(time_arr, Kraus=None, backend=AerSimulator(), Gprop=None, tolk=1e-05, tolo=1e-05, Is_store_circuit=False, **kwargs)</code>","text":"<p>Perform quantum simulation using the Kraus operator representation.</p> <p>This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach. It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator, and accumulates the measurement results.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>List of time steps for simulation.</p> required <code>Kraus</code> <code>Optional[Dict[int, List[ndarray]]]</code> <p>Dictionary mapping time step index to a list of Kraus operators. If None, Kraus operators are generated from the propagator. Defaults to None.</p> <code>None</code> <code>backend</code> <code>Any</code> <p>Quantum simulation backend. Defaults to AerSimulator().</p> <code>AerSimulator()</code> <code>Gprop</code> <code>Optional[List[ndarray]]</code> <p>Propagator matrix (or list of matrices) for simulation. If None, it will be calculated. Defaults to None.</p> <code>None</code> <code>tolk</code> <code>float</code> <p>Tolerance for generating Kraus operators. Defaults to 1e-5.</p> <code>1e-05</code> <code>tolo</code> <code>float</code> <p>Tolerance for observable decomposition. Defaults to 1e-5.</p> <code>1e-05</code> <code>Is_store_circuit</code> <code>bool</code> <p>If True, store the generated quantum circuits at each time step. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for propagator calculation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Dict[str, Any]: A dictionary containing quantum simulation results, including: - 'data' (np.ndarray): Array of shape (nsteps,), containing the accumulated observable expectation values at each time step. - 'circuits' (List[List[QuantumCircuit]], optional): If <code>Is_store_circuit</code> is True, this field contains a list of lists of quantum circuits.   Each outer list corresponds to a time step, and each inner list contains all circuits used for that step (across different Kraus operators and initial states).</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def qc_simulation_kraus(\n    self,\n    time_arr: List[float],\n    Kraus: Optional[Dict[int, List[np.ndarray]]] = None,\n    backend: Any = AerSimulator(), \n    Gprop: Optional[List[np.ndarray]] = None,\n    tolk: float = 1e-5,\n    tolo: float = 1e-5,\n    Is_store_circuit = False,\n    **kwargs: Any\n    ) -&gt; np.ndarray:\n    \"\"\"\n    Perform quantum simulation using the Kraus operator representation.\n\n    This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach.\n    It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator,\n    and accumulates the measurement results.\n\n    Args:\n        time_arr (List[float]): List of time steps for simulation.\n\n        Kraus (Optional[Dict[int, List[np.ndarray]]], optional): Dictionary mapping time step index to a list of Kraus operators.\n            If None, Kraus operators are generated from the propagator. Defaults to None.\n        backend (Any, optional): Quantum simulation backend. Defaults to AerSimulator().\n        Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n            If None, it will be calculated. Defaults to None.\n        tolk (float, optional): Tolerance for generating Kraus operators. Defaults to 1e-5.\n        tolo (float, optional): Tolerance for observable decomposition. Defaults to 1e-5.\n        Is_store_circuit (bool, optional): If True, store the generated quantum circuits at each time step. Defaults to False.\n        **kwargs: Additional keyword arguments for propagator calculation.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing quantum simulation results, including:\n            - 'data' (np.ndarray): Array of shape (nsteps,), containing the accumulated observable expectation values at each time step.\n            - 'circuits' (List[List[QuantumCircuit]], optional): If `Is_store_circuit` is True, this field contains a list of lists of quantum circuits.\n              Each outer list corresponds to a time step, and each inner list contains all circuits used for that step (across different Kraus operators and initial states).\n    \"\"\"\n    nsteps = len(time_arr)\n\n    # Generate Kraus operators if not provided.\n    if Kraus is None:\n        Kraus = {}\n        if Gprop is None:\n            print('Calculating the propagator')\n            Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n        print('Generating the Kraus operators')\n        for i in range(nsteps):\n            print('At step', i, 'of', nsteps)\n            Kraus[i] = gen_Kraus_list(Gprop[i], self.Nsys, tol=tolk)\n    print('Kraus operator generation complete')\n\n    # Perform Qiskit simulation using the Estimator.\n    estimator = Estimator(mode=backend)\n\n    statevec, prob = self.init_statevec_Kraus()\n    n_inistate = len(statevec)\n    print('Number of initial states in the density matrix:', n_inistate)\n    print('Probabilities:', prob)\n\n    # Obtain the Qiskit observable.\n    obs_q = self._get_qiskit_observable(Isdilate=True, tol=tolo)\n\n    print('Starting quantum simulation')\n\n    result_simu = {}\n    result_simu['data'] = np.zeros(nsteps, dtype=np.float64)\n    if(Is_store_circuit):  result_simu['circuits'] = [ [] for _ in range(nsteps) ]\n\n    for i in range(nsteps):\n        print('Simulation step', i, 'of', nsteps)\n        current_kraus_list = Kraus[i]\n        print('Number of Kraus operators:', len(current_kraus_list))\n        for kraus_op in current_kraus_list:\n            for istate in range(n_inistate):\n                qc = self._create_circuit(kraus_op, statevec[istate], Isscale=False)\n                result = estimator.run([(qc, obs_q)]).result()\n\n                if(Is_store_circuit):  result_simu['circuits'][i].append(qc)\n                result_simu['data'][i] += result[0].data.evs * prob[istate]\n\n    return result_simu\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.qc_simulation_vecdens","title":"<code>qc_simulation_vecdens(time_arr, shots=1024, backend=AerSimulator(), Gprop=None, **kwargs)</code>","text":"<p>Perform quantum simulation using the vectorized density matrix representation.</p> <p>This method simulates the quantum system dynamics over a series of time steps by constructing circuits based on the vectorized density matrix representation, performing measurements, and processing the results.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>List of time steps for simulation.</p> required <code>shots</code> <code>int</code> <p>Number of measurement shots. Defaults to 1024.</p> <code>1024</code> <code>backend</code> <code>Any</code> <p>Quantum simulation backend. Defaults to AerSimulator().</p> <code>AerSimulator()</code> <code>Gprop</code> <code>Optional[List[ndarray]]</code> <p>Propagator matrix (or list of matrices) for simulation. If None, it will be calculated. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for propagator calculation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Dict[str, Any]: A dictionary containing the quantum simulation results, including: - 'data' (np.ndarray): Array of shape (nsteps, n_bitstr), storing the processed probability amplitudes  (i.e., normalized square root of the measured probabilities, scaled by norm factors) at each time step. - 'circuits' (List[QuantumCircuit]): List of generated quantum circuits for each time step. - 'norm' (List[float]): List of norm correction factors used in post-processing at each time step.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def qc_simulation_vecdens(\n    self,\n    time_arr: List[float],\n    shots: int = 1024,\n    backend: Any = AerSimulator(),\n    Gprop: Optional[List[np.ndarray]] = None,\n    **kwargs: Any\n) -&gt; np.ndarray:\n    \"\"\"\n    Perform quantum simulation using the vectorized density matrix representation.\n\n    This method simulates the quantum system dynamics over a series of time steps by constructing circuits\n    based on the vectorized density matrix representation, performing measurements, and processing the results.\n\n    Args:\n        time_arr (List[float]): List of time steps for simulation.\n        shots (int, optional): Number of measurement shots. Defaults to 1024.\n        backend (Any, optional): Quantum simulation backend. Defaults to AerSimulator().\n        Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n            If None, it will be calculated. Defaults to None.\n        **kwargs: Additional keyword arguments for propagator calculation.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing the quantum simulation results, including:\n            - 'data' (np.ndarray): Array of shape (nsteps, n_bitstr), storing the processed probability amplitudes \n            (i.e., normalized square root of the measured probabilities, scaled by norm factors) at each time step.\n            - 'circuits' (List[QuantumCircuit]): List of generated quantum circuits for each time step.\n            - 'norm' (List[float]): List of norm correction factors used in post-processing at each time step.\n    \"\"\"\n    if Gprop is None:\n        Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n\n    nsteps = len(time_arr)\n\n    if self.count_str is None:\n        print(\"Error: count_str is not assigned\")\n\n    n_bitstr = len(self.count_str)\n    statevec, norm0 = self.init_statevec_vecdens()\n\n    result = {}\n    result['data'] = np.zeros((nsteps, n_bitstr), dtype=np.float64)\n    result['circuits'] = []\n    result['norm'] = []\n\n    for i in range(nsteps):\n        if i % 100 == 0:\n            print('Quantum simulation step', i)\n        Gt = Gprop[i]\n\n        #create the circuit\n        circuit, norm = self._create_circuit(Gt, statevec, Isscale=True)\n        circuit.measure(range(self.Nqb + 1), range(self.Nqb + 1))\n        if self.dilation_method == 'SVD-Walsh':\n            circuit = transpile(circuit, backend)\n\n        #store the circuits and norm to the result\n        result['circuits'].append(circuit)\n        result['norm'].append(norm)\n\n        counts = backend.run(circuit, shots=shots).result().get_counts()\n        for j in range(n_bitstr):\n            bitstr = self.count_str[j]\n            if bitstr in counts:\n                result['data'][i, j] = np.sqrt(counts[bitstr] / shots) * norm * norm0\n            else:\n                print('At time', i, 'with shots =', shots, \"no counts for\", bitstr)\n\n    return result\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.set_count_str","title":"<code>set_count_str(count_str)</code>","text":"<p>Set the counting bit string for measurement.</p> <p>Parameters:</p> Name Type Description Default <code>count_str</code> <code>List[str]</code> <p>The counting bit string.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_count_str(self, count_str: List[str]) -&gt; None:\n    \"\"\"\n    Set the counting bit string for measurement.\n\n    Args:\n        count_str (List[str]): The counting bit string.\n    \"\"\"\n    self.count_str = count_str\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.set_dilation_method","title":"<code>set_dilation_method(method)</code>","text":"<p>Set the dilation method for quantum simulation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_dilation_method(self, method: str) -&gt; None:\n    \"\"\"\n    Set the dilation method for quantum simulation.\n\n    Args:\n        method (str): The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.\n    \"\"\"\n    self.dilation_method = method\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.set_observable","title":"<code>set_observable(observable)</code>","text":"<p>Set the observable for the quantum simulation.</p> <p>Parameters:</p> Name Type Description Default <code>observable</code> <code>ndarray</code> <p>The observable matrix.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_observable(self, observable: np.ndarray) -&gt; None:\n    \"\"\"\n    Set the observable for the quantum simulation.\n\n    Args:\n        observable (np.ndarray): The observable matrix.\n    \"\"\"\n    self.observable = observable\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid","title":"<code>DVR_grid</code>","text":"<p>Class for Discrete Variable Representation (DVR) grid methods.</p> <p>This class handles grid-based representations for systems where the potential is expressed on grid points.</p> <p>Attributes:</p> Name Type Description <code>Ngrid</code> <code>int</code> <p>Number of grid points.</p> <code>xmin</code> <code>float</code> <p>Minimum value of the grid.</p> <code>xmax</code> <code>float</code> <p>Maximum value of the grid.</p> <code>mass</code> <code>float</code> <p>Mass of the particle.</p> <code>xgrid</code> <code>ndarray</code> <p>Array of grid points in position space.</p> <code>dx</code> <code>float</code> <p>Spacing between grid points.</p> <code>dk</code> <code>float</code> <p>Spacing in momentum space.</p> <code>kgrid</code> <code>ndarray</code> <p>Array of grid points in momentum space.</p> <code>ak2</code> <code>ndarray</code> <p>Kinetic energy array in momentum space.</p> <code>hamk</code> <code>ndarray</code> <p>Kinetic Hamiltonian matrix in position space.</p> <code>potential</code> <code>Optional[ndarray]</code> <p>Potential energy array on the grid.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>class DVR_grid:\n    \"\"\"Class for Discrete Variable Representation (DVR) grid methods.\n\n    This class handles grid-based representations for systems where the potential is expressed on grid points.\n\n    Attributes:\n        Ngrid (int): Number of grid points.\n        xmin (float): Minimum value of the grid.\n        xmax (float): Maximum value of the grid.\n        mass (float): Mass of the particle.\n        xgrid (np.ndarray): Array of grid points in position space.\n        dx (float): Spacing between grid points.\n        dk (float): Spacing in momentum space.\n        kgrid (np.ndarray): Array of grid points in momentum space.\n        ak2 (np.ndarray): Kinetic energy array in momentum space.\n        hamk (np.ndarray): Kinetic Hamiltonian matrix in position space.\n        potential (Optional[np.ndarray]): Potential energy array on the grid.\n    \"\"\"\n\n    def __init__(self, xmin: float, xmax: float, Ngrid: int, mass: float) -&gt; None:\n        \"\"\"\n        Initialize the DVR_grid instance.\n\n        Args:\n            xmin (float): Minimum x-value.\n            xmax (float): Maximum x-value.\n            Ngrid (int): Number of grid points.\n            mass (float): Mass of the particle.\n        \"\"\"\n        self.Ngrid: int = Ngrid\n        self.xmin: float = xmin\n        self.xmax: float = xmax\n        self.mass: float = mass\n\n        # Set up the position grid.\n        self.xgrid: np.ndarray = np.array([])\n        self._set_xgrid()\n        self.dx: float = self.xgrid[1] - self.xgrid[0]\n\n        # Set up the momentum grid.\n        self.dk: float = 2.0 * np.pi / (self.Ngrid * self.dx)\n        self.kgrid: np.ndarray = np.array([])\n        self.ak2: np.ndarray = np.array([])  # Kinetic energy array.\n        self.hamk: np.ndarray = np.array([])  # Kinetic Hamiltonian matrix.\n        self._set_kinet_ham()\n\n        # Potential energy array (to be set later).\n        self.potential: Optional[np.ndarray] = None\n\n    def _set_xgrid(self) -&gt; None:\n        \"\"\"\n        Set up the position space grid.\n\n        Initializes the `xgrid` attribute using a linear space between `xmin` and `xmax`.\n        \"\"\"\n        self.xgrid = np.linspace(self.xmin, self.xmax, self.Ngrid)\n\n    def set_potential(self, func_pot: Callable[[float], float]) -&gt; None:\n        \"\"\"\n        Set up the potential energy array on the grid.\n\n        Args:\n            func_pot (Callable[[float], float]): Function that returns the potential value at a given x.\n        \"\"\"\n        self.potential = np.zeros_like(self.xgrid)\n        for i in range(self.Ngrid):\n            self.potential[i] = func_pot(self.xgrid[i])\n\n    def _set_kinet_ham(self) -&gt; None:\n        \"\"\"\n        Set up the kinetic Hamiltonian matrix in position space.\n\n        This method computes the momentum grid and the corresponding kinetic energy values,\n        and constructs the kinetic Hamiltonian matrix in position space using a Fourier transform.\n        \"\"\"\n        self.kgrid = np.zeros(self.Ngrid, dtype=np.float64)\n        self.ak2 = np.zeros(self.Ngrid, dtype=np.float64)\n\n        coef_k: float = pa.hbar**2 / (2.0 * self.mass)\n\n        for i in range(self.Ngrid):\n            if i &lt; self.Ngrid // 2:\n                self.kgrid[i] = i * self.dk\n            else:\n                self.kgrid[i] = -(self.Ngrid - i) * self.dk\n            self.ak2[i] = coef_k * self.kgrid[i]**2\n\n        akx0: np.ndarray = sfft.ifft(self.ak2)\n        self.hamk = np.zeros((self.Ngrid, self.Ngrid), dtype=np.complex128)\n\n        for i in range(self.Ngrid):\n            for j in range(self.Ngrid):\n                if i &lt; j:\n                    self.hamk[i, j] = akx0[i - j].conj()\n                else:\n                    self.hamk[i, j] = akx0[i - j]\n\n    def get_eig_state(self, Nstate: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Get the eigenstates for the potential in x-space.\n\n        Args:\n            Nstate (int): Number of eigenstates to output.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: A tuple containing:\n                - Eigenvalues (np.ndarray) for the first `Nstate` states.\n                - Eigenvectors (np.ndarray) for the first `Nstate` states, normalized by sqrt(dx).\n        \"\"\"\n        Mata: np.ndarray = self.hamk.copy()\n        for i in range(self.Ngrid):\n            Mata[i, i] += self.potential[i]\n\n        val, arr = LA.eigh(Mata)\n        return val[:Nstate], arr[:, :Nstate] / np.sqrt(self.dx)\n\n    def x2k_wave(self, psi: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform the wavefunction from position space to momentum space.\n\n        Args:\n            psi (np.ndarray): Wavefunction in position space.\n\n        Returns:\n            np.ndarray: Wavefunction in momentum space.\n        \"\"\"\n        return tb.x2k_wave(self.dx, psi)\n\n    def k2x_wave(self, psik: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform the wavefunction from momentum space to position space.\n\n        Args:\n            psik (np.ndarray): Wavefunction in momentum space.\n\n        Returns:\n            np.ndarray: Wavefunction in position space.\n        \"\"\"\n        return tb.k2x_wave(self.dx, psik)\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid.__init__","title":"<code>__init__(xmin, xmax, Ngrid, mass)</code>","text":"<p>Initialize the DVR_grid instance.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>Minimum x-value.</p> required <code>xmax</code> <code>float</code> <p>Maximum x-value.</p> required <code>Ngrid</code> <code>int</code> <p>Number of grid points.</p> required <code>mass</code> <code>float</code> <p>Mass of the particle.</p> required Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def __init__(self, xmin: float, xmax: float, Ngrid: int, mass: float) -&gt; None:\n    \"\"\"\n    Initialize the DVR_grid instance.\n\n    Args:\n        xmin (float): Minimum x-value.\n        xmax (float): Maximum x-value.\n        Ngrid (int): Number of grid points.\n        mass (float): Mass of the particle.\n    \"\"\"\n    self.Ngrid: int = Ngrid\n    self.xmin: float = xmin\n    self.xmax: float = xmax\n    self.mass: float = mass\n\n    # Set up the position grid.\n    self.xgrid: np.ndarray = np.array([])\n    self._set_xgrid()\n    self.dx: float = self.xgrid[1] - self.xgrid[0]\n\n    # Set up the momentum grid.\n    self.dk: float = 2.0 * np.pi / (self.Ngrid * self.dx)\n    self.kgrid: np.ndarray = np.array([])\n    self.ak2: np.ndarray = np.array([])  # Kinetic energy array.\n    self.hamk: np.ndarray = np.array([])  # Kinetic Hamiltonian matrix.\n    self._set_kinet_ham()\n\n    # Potential energy array (to be set later).\n    self.potential: Optional[np.ndarray] = None\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid.get_eig_state","title":"<code>get_eig_state(Nstate)</code>","text":"<p>Get the eigenstates for the potential in x-space.</p> <p>Parameters:</p> Name Type Description Default <code>Nstate</code> <code>int</code> <p>Number of eigenstates to output.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: A tuple containing: - Eigenvalues (np.ndarray) for the first <code>Nstate</code> states. - Eigenvectors (np.ndarray) for the first <code>Nstate</code> states, normalized by sqrt(dx).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def get_eig_state(self, Nstate: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Get the eigenstates for the potential in x-space.\n\n    Args:\n        Nstate (int): Number of eigenstates to output.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: A tuple containing:\n            - Eigenvalues (np.ndarray) for the first `Nstate` states.\n            - Eigenvectors (np.ndarray) for the first `Nstate` states, normalized by sqrt(dx).\n    \"\"\"\n    Mata: np.ndarray = self.hamk.copy()\n    for i in range(self.Ngrid):\n        Mata[i, i] += self.potential[i]\n\n    val, arr = LA.eigh(Mata)\n    return val[:Nstate], arr[:, :Nstate] / np.sqrt(self.dx)\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid.k2x_wave","title":"<code>k2x_wave(psik)</code>","text":"<p>Transform the wavefunction from momentum space to position space.</p> <p>Parameters:</p> Name Type Description Default <code>psik</code> <code>ndarray</code> <p>Wavefunction in momentum space.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Wavefunction in position space.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def k2x_wave(self, psik: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform the wavefunction from momentum space to position space.\n\n    Args:\n        psik (np.ndarray): Wavefunction in momentum space.\n\n    Returns:\n        np.ndarray: Wavefunction in position space.\n    \"\"\"\n    return tb.k2x_wave(self.dx, psik)\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid.set_potential","title":"<code>set_potential(func_pot)</code>","text":"<p>Set up the potential energy array on the grid.</p> <p>Parameters:</p> Name Type Description Default <code>func_pot</code> <code>Callable[[float], float]</code> <p>Function that returns the potential value at a given x.</p> required Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def set_potential(self, func_pot: Callable[[float], float]) -&gt; None:\n    \"\"\"\n    Set up the potential energy array on the grid.\n\n    Args:\n        func_pot (Callable[[float], float]): Function that returns the potential value at a given x.\n    \"\"\"\n    self.potential = np.zeros_like(self.xgrid)\n    for i in range(self.Ngrid):\n        self.potential[i] = func_pot(self.xgrid[i])\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid.x2k_wave","title":"<code>x2k_wave(psi)</code>","text":"<p>Transform the wavefunction from position space to momentum space.</p> <p>Parameters:</p> Name Type Description Default <code>psi</code> <code>ndarray</code> <p>Wavefunction in position space.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Wavefunction in momentum space.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def x2k_wave(self, psi: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform the wavefunction from position space to momentum space.\n\n    Args:\n        psi (np.ndarray): Wavefunction in position space.\n\n    Returns:\n        np.ndarray: Wavefunction in momentum space.\n    \"\"\"\n    return tb.x2k_wave(self.dx, psi)\n</code></pre>"},{"location":"qflux/Open_Systems/spinchainOpen/","title":"Open Quantum Dynamics of a Spin Chain","text":"<p>This documentation describes how to simulate the open quantum dynamics of a spin chain using the Lindbladian formalism. The simulation supports both classical and quantum computation backends and showcases comparison plots between different solver strategies.</p>"},{"location":"qflux/Open_Systems/spinchainOpen/#system-setup","title":"System Setup","text":"<p>We begin by specifying the system Hamiltonian and initial state for a chain of \\(n = 3\\) spins, with the form</p> \\[  H = \\sum_{n=0}^{N-1} \\Omega_{n} \\sigma_{n}^{z} - \\frac{1}{2} \\sum_{n=0}^{N-2} ( J_{n,n+1}^{x} \\sigma_{n}^{x} \\sigma_{n+1}^{x} + J_{n,n+1}^{y} \\sigma_{n}^{y} \\sigma_{n+1}^{y} + J_{n,n+1}^{z} \\sigma_{n}^{z} \\sigma_{n+1}^{z} ) \\] <p>The Hamiltonian is defined using a Pauli string representation and includes local \\(Z\\)-field terms and \\(XX\\), \\(YY\\), and \\(ZZ\\) couplings, with cofficients given according to the table:</p> Parameter \\(n = 0\\) \\(n \\neq 0\\) \\(\\Omega_n\\) 0.65 1.0 \\(J_{n,n+1}^{x}\\) 0.75 1.0 \\(J_{n,n+1}^{y}\\) 0.75 1.0 \\(J_{n,n+1}^{z}\\) 0.0 0.0 <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nimport qflux.open_systems.params as pa\nfrom qflux.open_systems.numerical_methods import DynamicsOS\nfrom qflux.open_systems.quantum_simulation import QubitDynamicsOS\nimport qflux.open_systems.trans_basis as tb\n\n\n#============set the Hamiltonian and initial state\n#the system Hamiltonian parameter\nnsite = 3 #this states how many spins in the simulation\nNsys_sc = 2**nsite #this is the dimension of the Hilbert space\nOmegai_list = [0.65, 1.0, 1.0]\nJix_list = [0.75, 1.0]\nJiy_list = [0.75, 1.0]\nJiz_list = [0.0, 0.0]\n\n#Hamiltonian in pauli string basis\nH_pauli_str = {'ZII':Omegai_list[0], 'IZI':Omegai_list[1], 'IIZ':Omegai_list[2], \\\n               'XXI':-0.5*Jix_list[0], 'IXX':-0.5*Jix_list[1], \\\n               'YYI':-0.5*Jiy_list[0], 'IYY':-0.5*Jiy_list[1], \\\n               'ZZI':-0.5*Jiz_list[0], 'IZZ':-0.5*Jiz_list[1]   }\n\n#system hamiltonian\nHsys = tb.pauli_to_ham(H_pauli_str, 3)\n</code></pre> <p>The initial state is constructed as a product state \\(|\\uparrow\\downarrow\\downarrow\\cdots\\rangle\\), and its corresponding density matrix is stored in <code>rho0_sc</code>. The time evolution will be simulated over a grid defined in <code>time_arr</code>.</p> <pre><code>#set up the initial state at [up,down,down...]\ninit_state = pa.spin_up\nfor i in range(nsite-1):\n  init_state = np.kron(init_state,pa.spin_down)\n\n#set up the initial density matrix according to initial state\nrho0_sc = np.zeros((Nsys_sc,Nsys_sc),dtype=np.complex128)\nrho0_sc += np.outer(init_state,init_state.conj())\n\n#time array for simulation\ntime_arr = np.linspace(0, (250 - 1) * 0.1, 250)\n</code></pre>"},{"location":"qflux/Open_Systems/spinchainOpen/#collapse-operators-lindblad-dissipators","title":"Collapse Operators (Lindblad Dissipators)","text":"<p>Open quantum dynamics are modeled using the Lindblad master equation.</p> \\[ \\dot{\\rho}(t) = -i [H, \\rho(t)] + \\frac{1}{2} \\sum_{m=1}^{2} \\sum_{n=0}^{N-1} \\gamma_{m,n} \\left[ 2 L_{m,n} \\rho(t) L_{m,n}^{\\dagger} - \\rho(t) L_{m,n}^{\\dagger} L_{m,n} - L_{m,n}^{\\dagger} L_{m,n} \\rho(t) \\right] \\] <p>Here we construct collapse operators \\(L_i\\) representing two types of dissipation:</p> <ul> <li>Type 1: Amplitude damping via \\(\\sigma^-\\)</li> <li>Type 2: Dephasing via \\(\\sigma^+ \\sigma^-\\)</li> </ul> <p>These are weighted by decay rates \\(\\Gamma_1\\) and \\(\\Gamma_2\\) per site.</p> <pre><code>L_sc = []\n#The lindblad damping rate\nGamma1 = [0.016]*nsite\nGamma2 = [0.0523]*nsite\n\nfor isite in range(nsite):\n  #Lindbladian for type 1\n  res = 1.0\n  for j in range(nsite):\n    if(j==isite):\n      res = np.kron(res,pa.sigmam)*np.sqrt(Gamma1[isite])\n    else:\n      res = np.kron(res,pa.I)\n  L_sc.append(res)\n\n  #Lindbladian for type 2\n  res = 1.0\n  for j in range(nsite):\n    if(j==isite):\n      res = np.kron(res,pa.sigmap@pa.sigmam)*np.sqrt(Gamma2[isite])\n    else:\n      res = np.kron(res,pa.I)\n  L_sc.append(res)\n</code></pre> <p>Each collapse operator is built as a Kronecker product over the sites, selectively applying the operator at the target site and identities elsewhere.</p>"},{"location":"qflux/Open_Systems/spinchainOpen/#classical-simulation","title":"Classical Simulation","text":"<p>We now instantiate the system using both pure and open dynamics objects:</p> <ul> <li><code>DynamicsOS</code> for simulating Liouville and Lindblad evolution</li> <li>Propagation methods:</li> <li><code>propagate_qt</code>: Uses QuTiP for integration</li> <li><code>propagate_matrix_exp</code>: Uses matrix exponentials</li> </ul> <pre><code>#=============instantiation\nspin_chain_puresys =  DynamicsOS(Nsys=Nsys_sc, Hsys=Hsys, rho0=rho0_sc)\nspin_chain_opensys =  DynamicsOS(Nsys=Nsys_sc, Hsys=Hsys, rho0=rho0_sc, c_ops = L_sc)\n\n#=============propagation\n# QuTiP Propagation for the pure system Liouville equation (for comparison)\nresult_qutip_Liouv = spin_chain_puresys.propagate_qt(time_arr=time_arr, observable=rho0_sc)\n\n#matrix exponential propagation\nresult_matrix_exp = spin_chain_opensys.propagate_matrix_exp(time_arr=time_arr, observable=rho0_sc)\n\n# QuTiP Propagation for the Lindblad equation\nresult_qutip_Lindblad = spin_chain_opensys.propagate_qt(time_arr=time_arr, observable=rho0_sc)\n\nAs_matrix_exp = np.sqrt(result_matrix_exp.expect[:])\nAs_qutip = np.sqrt(result_qutip_Lindblad[0][:])\nAs_qutip_liouv = np.sqrt(result_qutip_Liouv[0][:])\n</code></pre> <p>The results <code>As_matrix_exp</code>, <code>As_qutip</code>, and <code>As_qutip_liouv</code> represent expectation values (e.g., fidelity or survival amplitude) computed using each method.</p>"},{"location":"qflux/Open_Systems/spinchainOpen/#plotting-classical-results","title":"Plotting Classical Results","text":"<p>We visualize the classical simulations by plotting the observable \\(A_s(t) = \\sqrt{\\langle \\rho_0 | \\rho(t) \\rangle}\\).</p> <pre><code>plt.figure(figsize=(6,2))\nplt.plot(time_arr,As_matrix_exp,'b-', label=\"Matrix Exponential\")\nplt.plot(time_arr,As_qutip,'ko',markersize=4,markevery=4,label=\"QuTiP_Lindblad\")\nplt.plot(time_arr,As_qutip_liouv,'r-',label=\"Pure System\")\nplt.xlabel('time',fontsize=15)\nplt.ylabel('$A_s$(t)',fontsize=15)\nplt.legend(loc = 'upper right')\n</code></pre> <p>The comparison between matrix exponential, QuTiP Lindblad, and pure unitary evolution offers a benchmark for accuracy and computational cost.</p> <p></p>"},{"location":"qflux/Open_Systems/spinchainOpen/#quantum-simulation","title":"Quantum Simulation","text":"<p>A quantum simulation backend is invoked using the <code>QubitDynamicsOS</code> class. This assumes density matrix simulation via vectorization and allows control over measurement configuration and shot noise.</p> <pre><code>qspin_chain = QubitDynamicsOS(rep='Density',Nsys=Nsys_sc, Hsys=Hsys, rho0=rho0_sc, c_ops = L_sc)\nqspin_chain.set_count_str(['0011011'])\n\nres_qc_1k = qspin_chain.qc_simulation_vecdens(time_arr,shots=1000)\nres_qc_1w = qspin_chain.qc_simulation_vecdens(time_arr,shots=10000)\n\nAs_qc_1k = np.sqrt(res_qc_1k)\nAs_qc_1w = np.sqrt(res_qc_1w)\n</code></pre> <p>The <code>set_count_str</code> method defines which measurement outcomes to track, and <code>qc_simulation_vecdens</code> performs the evolution using a quantum processor or simulator.</p>"},{"location":"qflux/Open_Systems/spinchainOpen/#plotting-quantum-results","title":"Plotting Quantum Results","text":"<p>We compare quantum results (with different shot counts) against the classical QuTiP benchmark. Increasing shot count reduces statistical noise.</p> <pre><code>plt.figure(figsize=(6,2))\nplt.plot(time_arr,As_qc_1k[:],'r-',label=f\"quantum,counts={1000}\")\nplt.plot(time_arr,As_qc_1w[:],'b-',label=f\"quantum,counts={10000}\")\nplt.plot(time_arr,As_qutip,'ko',markersize=4,markevery=4,label=\"QuTiP benchmark\")\nplt.xlabel('Time',fontsize=15)\nplt.ylabel('$A_s$(t)',fontsize=15)\nplt.legend(loc = 'upper right')\n</code></pre> <p>This plot illustrates convergence of quantum simulation with classical reference as the number of measurement shots increases.</p> <p></p>"},{"location":"qflux/Open_Systems/spinchainOpen/#summary","title":"Summary","text":"<p>This example presents a flexible simulation pipeline for open quantum systems, written in a basis of Pauli strings:</p> <ul> <li>Supports classical (QuTiP, matrix exponential) and quantum (density matrix) backends</li> <li>Compares open vs. closed evolution</li> <li>Allows benchmarking between solver strategies</li> </ul> <p>The use of Lindbladian formalism and collapse operators enables modeling dissipative processes essential for realistic simulations of physical processes.</p>"},{"location":"qflux/Open_Systems/spinhalfOpen/","title":"Spin 1/2 Demo","text":"<p>This section illustrates the simulation of an open quantum Spin-1/2 system using both classical and quantum backends, implemented within QFlux. Spin-1/2 models are chemically relevant, as they capture key features of charge and energy transfer between donor and acceptor sites, that is each spin state corresponds to an electronic state for the chemical interpretation. We examine two types of Lindblad equations for describing open system dyanmics. The Linblad equation is given as</p> \\[ \\frac{d\\rho}{dt} = -\\frac{i}{\\hbar} [H, \\rho] + \\sum_j \\gamma_j \\left( L_j \\rho L_j^\\dagger - \\frac{1}{2} \\left[ L_j^\\dagger L_j, \\rho \\right] \\right) \\] <p>The first is taking the jump operators \\(L_j\\) as just the sigle operator \\(\\sigma_x\\), the system is subject to a type of decoherence which damps both the system energy and coherences. Demonstrating the Lindblad formalism can incorporate both population relaxation and dephasing (loss of coherence), which is tyical of chemical reactions in the condensed phase. If instead we take the jump operators \\(L_j\\) as just the single operator \\(\\sigma^+\\), the system is subject to amplitude damping, a type of decoherence that affects only the populations. Modeling the irreversible decay from the excited to the ground state, while leaving the coherences intact. Although , we focus here on amplitude damping as one representative dissipation pathway. Simulation results from both classical and quantum methods are compared to validate the implementation.</p>"},{"location":"qflux/Open_Systems/spinhalfOpen/#classical-simulation","title":"Classical Simulation","text":"<p>We begin by setting up the classical evolution of a Spin-1/2 system governed by a simple Hamiltonian and subject to dissipation via a collapse operator, defined as \\(\\sqrt{\\gamma_j}L_j\\). The system's evolution is computed using both matrix exponentiation and QuTiP solvers for benchmarking. We begin by importing the necessary modules from QFlux, Numpy, and Matplotlib libraries</p> <pre><code>import qflux.open_systems.params as pa\nfrom qflux.open_systems.numerical_methods import DynamicsOS\nfrom qflux.open_systems.quantum_simulation import QubitDynamicsOS\nimport numpy as np\nimport matplotlib.pyplot as plt\n</code></pre> <p>The <code>params</code> file defines constants and quantum operators commonly used in simulations of spin-\u00bd systems. These include the Pauli matrices as well as the raising and lowering operators.</p> <p>The <code>DynamicsOS</code> class performs classical simulation of an open quantum system using the Lindblad master equation. If no collapse operators are specified, the model reduces to the quantum Liouville equation.</p> <p>The table below outlines the required inputs to initialize a <code>DynamicsOS</code> instance:</p>"},{"location":"qflux/Open_Systems/spinhalfOpen/#dynamicsos-initialization-inputs","title":"<code>DynamicsOS</code> Initialization Inputs","text":"Attribute Type Description <code>Nsys</code> <code>int</code> Dimension of the system Hilbert space, \\( N \\) <code>Hsys</code> <code>np.ndarray</code> Hamiltonian of the system, shape \\( (N, N) \\) <code>rho0</code> <code>np.ndarray</code> Initial density matrix, shape \\( (N, N) \\) <code>c_ops</code> <code>List[np.ndarray]</code> List of collapse operators, each of shape \\( (N, N) \\)"},{"location":"qflux/Open_Systems/spinhalfOpen/#simulated-system","title":"Simulated System","text":"<p>The Hamiltonian is chosen to be proportional to the Pauli-X matrix:</p> \\[ H_{\\text{sys}} = 2\\pi \\times 0.1 \\cdot \\sigma^x \\] <p>The collapse operator introduces dephasing:</p> \\[ C = \\sqrt{\\gamma} \\cdot \\sigma^x \\] \\[ \\gamma = 0.05 \\] <p>The initial state is the spin-up state along the \\( z \\)-axis:</p> \\[ \\rho_0 = |\\uparrow\\rangle \\langle\\uparrow| \\] <p>Simulation is carried out using matrix exponential propagation of the Lindbladian. Results are compared against reference dynamics obtained using QuTiP. We produce the matrix exponential propagation employing the <code>propagate_matrix_exp</code> method  then compare to results with QuTiP, which is implemented using <code>propagate_qt</code>. The following tables explain the input-output relationships to perform simulation with matrix exponential propagation and QuTiP with our QFlux methods</p>"},{"location":"qflux/Open_Systems/spinhalfOpen/#dynamicsospropagate_matrix_exp-input","title":"<code>DynamicsOS.propagate_matrix_exp</code> Input","text":"Input Type Description <code>time_arr</code> <code>List[float]</code> Time array for dynamic simulation <code>observable</code> <code>np.ndarray</code> Observable for which the expectation value is computed <code>Is_store_state</code> <code>bool</code>, optional If <code>True</code>, stores the density matrix at each time step (default: <code>False</code>) <code>Is_show_step</code> <code>bool</code>, optional If <code>True</code>, prints progress during simulation (default: <code>False</code>) <code>Is_Gt</code> <code>bool</code>, optional If <code>True</code>, includes propagators in the output (default: <code>False</code>)"},{"location":"qflux/Open_Systems/spinhalfOpen/#dynamicsospropagate_matrix_exp-output","title":"<code>DynamicsOS.propagate_matrix_exp</code> Output","text":"Return Object Attribute Type Description <code>Result</code> <code>expect</code> <code>List[float]</code> Expectation values over time <code>density_matrix</code> <code>List[np.ndarray]</code> (optional) Time-evolved density matrices (if <code>Is_store_state=True</code>) <code>Gprop</code> <code>List[np.ndarray]</code> (optional) Propagators at each time step (if <code>Is_Gt=True</code>) <p>Now we provide the information for QuTiP propagation</p>"},{"location":"qflux/Open_Systems/spinhalfOpen/#dynamicsospropagate_qt-parameters","title":"<code>DynamicsOS.propagate_qt</code> Parameters","text":"Parameter Type Description <code>time_arr</code> <code>List[float]</code> Time array for dynamic simulation <code>observable</code> <code>Any</code> Observable operator(s) for which the expectation value is computed. Can be a single operator or a list of operators. <code>**kwargs</code> <code>Any</code>, optional Additional keyword arguments passed directly to QuTiP\u2019s <code>mesolve</code> function"},{"location":"qflux/Open_Systems/spinhalfOpen/#dynamicsospropagate_qt-output","title":"<code>DynamicsOS.propagate_qt</code> Output","text":"Return Object Type Description \u2014 <code>List[float]</code> Expectation values of the observable(s) over time <p>The following code begins by defining the Hamiltonian, dissipation parameter, Lindbladian collapse operators, initial state of the density matrix, and time points we evolve along. It continues to initialize the closed and open system dynamics and solve the equations of motion with our QFlux methods</p> <pre><code>Hsys = 2 * np.pi * 0.1 * pa.X\ngamma = 0.05\nc_ops = np.sqrt(gamma)*pa.X\nrho0 = np.outer(pa.spin_up, pa.spin_up.conj())\ntime_arr = np.linspace(0, (250 - 1) * 0.1, 250)\n\nspin1_puresys = DynamicsOS(Nsys=2, Hsys=Hsys, rho0=rho0)\nspin1_dissipative = DynamicsOS(Nsys=2, Hsys=Hsys, rho0=rho0, c_ops = [c_ops])\n\nexpec_vals_qutip_Liouv = spin1_puresys.propagate_qt(time_arr=time_arr, observable=pa.Z)\nresult_matrix_exp = spin1_dissipative.propagate_matrix_exp(time_arr=time_arr, observable=pa.Z)\nexpec_vals_qutip_Lindblad = spin1_dissipative.propagate_qt(time_arr=time_arr, observable=pa.Z)\n</code></pre> <p>We now compare the results obtained from matrix exponential evolution, QuTiP Lindblad dynamics, and the pure Liouville evolution. The close agreement validates the numerical implementation.</p> <pre><code>plt.figure(figsize=(6,2))\nplt.plot(time_arr, result_matrix_exp.expect,'b-', label = \"Matrix Exponential\")\nplt.plot(time_arr, expec_vals_qutip_Lindblad[0],'ko',markersize=4,markevery=4, label = \"QuTiP_Lindblad\")\nplt.plot(time_arr, expec_vals_qutip_Liouv[0],'r-', label = \"QuTiP_Liouville\")\nplt.xlabel('time',fontsize=15)\nplt.ylabel('&lt;$\\sigma^z$&gt;(t)',fontsize=15)\nplt.legend(loc = 'upper right')\nplt.show()\n</code></pre> <p></p>"},{"location":"qflux/Open_Systems/spinhalfOpen/#quantum-simulation-of-the-spin-12-system-amplitude-channel-damping","title":"Quantum Simulation of the Spin-1/2 System: Amplitude-Channel Damping","text":"<p>We next examine the quantum simulation of amplitude damping, using a zero Hamiltonian:</p> \\[ H_{\\text{sys}} = 0 \\] <p>The collapse operator is proportional to the spin-raising operator:</p> \\[ C = \\sqrt{\\gamma} \\cdot \\sigma^+ \\] <p>with the decay rate given by:</p> \\[ \\gamma = 1.52 \\times 10^9\\ \\text{ps}^{-1} \\times 10^{-12} \\] <p>The system is initialized in a mixed state:</p> \\[ \\rho_0 = \\begin{bmatrix} \\frac{1}{4} &amp; \\frac{1}{4} \\\\ \\frac{1}{4} &amp; \\frac{3}{4} \\end{bmatrix} \\] <p>The following code defines the quantities shown above-the Hamiltonian, dissipation rate \\(\\gamma\\), collapse operator, initial state, and continues to specify the array of time points.</p> <pre><code>Hsys = 0.0 * pa.I\ngamma = 1.52e9*1E-12\nc_ops = np.sqrt(gamma)*pa.sigmap\nrho0_sdam = np.array([[1/4,1/4],[1/4,3/4]],dtype=np.complex128)\ntime_sdam = np.arange(0, 1000, 1)\n</code></pre> <p>In the following code, we instantiate the quantum simulation with <code>QubitDynamicsOS</code>, this class implements quantum dynamics simulation which can be non-unitary.</p> <p>The <code>QubitDynamicsOS</code> class extends <code>DynamicsOS</code> and provides support for simulating quantum dynamics using either a density matrix or a Kraus operator representation. One can specify performing either a Kraus operator or density matrix simulation when instantiating <code>QubitDynamicsOS</code>. Either can accept a propagator obtained from a quantum master equation of the users choice by specifying <code>Gprop</code> or by calculating it using the Lindblad equation through <code>DynamicsOS</code> shown above. The class <code>QubitDynamicsOS</code> also provides structure for circuit-based simulation with Qiskit backends.</p>"},{"location":"qflux/Open_Systems/spinhalfOpen/#qubitdynamicsos-initialization-parameters","title":"<code>QubitDynamicsOS</code> Initialization Parameters","text":"Parameter Type Description <code>rep</code> <code>str</code>, optional Representation type. Must be <code>'Density'</code> or <code>'Kraus'</code>. Defaults to <code>'Density'</code>. <code>**kwargs</code> <code>Any</code> Additional keyword arguments passed to the base <code>DynamicsOS</code> initializer (e.g., <code>Nsys</code>, <code>Hsys</code>, <code>rho0</code>, <code>c_ops</code>)"},{"location":"qflux/Open_Systems/spinhalfOpen/#qubitdynamicsos-attributes","title":"<code>QubitDynamicsOS</code> Attributes","text":"Attribute Type Description <code>rep</code> <code>str</code> The selected representation (<code>'Density'</code> or <code>'Kraus'</code>) <code>count_str</code> <code>List[str]</code>, optional Qiskit-compatible list of bitstrings for measurement counts <code>observable</code> <code>np.ndarray</code>, optional Observable matrix used in measurement <code>dilation_method</code> <code>str</code> Method used for quantum dilation. Defaults to <code>'Sz-Nagy'</code> <p>It then specifies the Qubits which will be measured with <code>QubitDynamicsOS.set_count_str</code>, so counts will be obtained for those states specifed here. Finally, the dilation method is specified, the methods available are \"Sz-Nagy\", \"SVD\", and \"SVD-Walsh\". The following code shows how to instantiate a quantum simulation</p> <pre><code>spin1_sdam = QubitDynamicsOS(rep='Density', Nsys=2, Hsys=Hsys, rho0=rho0_sdam, c_ops = [c_ops])\nspin1_sdam.set_count_str(['000','011'])\nspin1_sdam.set_dilation_method('SVD')\n</code></pre> <p>The simulation is run using the quantum backend, and results are benchmarked against a classical matrix exponentiation method. There are two representations available for performing the quantum simulation, the first being quantum simulation using the vectorized density matrix which is done with the method <code>QubitDynamicsOS.qc_simulation_vecdens</code> and the second is with the Kraus operator representation, which we do not implement here but can be done so with <code>QubitDynamics.qc_simulation_kraus</code>. The inputs and outputs of <code>QubitDynamicsOS.qc_simulation_vecdens</code> are described by the tables below</p>"},{"location":"qflux/Open_Systems/spinhalfOpen/#qubitdynamicsosqc_simulation_vecdens-parameters","title":"<code>QubitDynamicsOS.qc_simulation_vecdens</code> Parameters","text":"Parameter Type Description <code>time_arr</code> <code>List[float]</code> List of time steps for the simulation <code>shots</code> <code>int</code>, optional Number of measurement shots to run per time step. Defaults to <code>1024</code> <code>backend</code> <code>Any</code>, optional Qiskit backend for simulation (e.g., <code>AerSimulator</code>). Defaults to <code>AerSimulator()</code> <code>Gprop</code> <code>List[np.ndarray]</code>, optional List of propagator matrices for system evolution. If <code>None</code>, they will be calculated automatically <code>**kwargs</code> <code>Any</code> Additional keyword arguments passed to the propagator calculation routine"},{"location":"qflux/Open_Systems/spinhalfOpen/#qubitdynamicsosqc_simulation_vecdens-output","title":"<code>QubitDynamicsOS.qc_simulation_vecdens</code> Output","text":"Return Object Type Description \u2014 <code>np.ndarray</code> Array containing the quantum simulation results over time <p>In the following code, the classical simulation of the same system is also computed using the <code>propagate_matrix_exp</code> method from <code>DynamicsOS</code> shown before</p> <pre><code>Pop_qc = spin1_sdam.qc_simulation_vecdens(time_sdam)\nres_sdam_classical = spin1_sdam.propagate_matrix_exp(time_sdam, observable=pa.Z, Is_store_state = True)\n\nPop_Mexp = np.zeros_like(Pop_qc)\nfor i in range(len(time_sdam)):\n    Pop_Mexp[i,0] = res_sdam_classical.density_matrix[i][0,0].real\n    Pop_Mexp[i,1] = res_sdam_classical.density_matrix[i][1,1].real\n</code></pre> <p>The population dynamics of both the excited and ground states are plotted, showing excellent agreement:</p> <pre><code>plt.figure(figsize=(6,2))\nplt.plot(time_sdam,Pop_qc[:,0],'r-',label=\"quantum,|0&gt;\")\nplt.plot(time_sdam,Pop_Mexp[:,0],'ko',markersize=5,markevery=40,label=\"benchmark,|0&gt;\")\nplt.plot(time_sdam,Pop_qc[:,1],'b-',label=\"quantum,|1&gt;\")\nplt.plot(time_sdam,Pop_Mexp[:,1],'yo',markersize=5,markevery=40,label=\"benchmark,|1&gt;\")\nplt.xlabel('time (ps)',fontsize=15)\nplt.ylabel('$P(t)$',fontsize=15)\nplt.legend(loc = 'upper right')\n</code></pre> <p></p>"},{"location":"qflux/Open_Systems/spinhalfOpen/#summary","title":"Summary","text":"<p>In this tutorial, we explored both classical and quantum simulations of a spin-\u00bd (two-level) open quantum system using QFlux, with a focus on dissipative dynamics. The key objectives and takeaways include:</p> <ul> <li>Defining Hamiltonians and collapse operators within the Lindblad formalism to model open quantum systems.</li> <li>Implementing classical propagation methods, such as matrix exponential solvers and QuTiP's <code>mesolve</code>, to simulate dissipative quantum dynamics.</li> <li>Comparing Liouville and Lindblad evolution frameworks and analyzing differences in population behavior.</li> <li>Executing quantum simulations using qubit-based models, including custom dilation strategies (e.g., SVD-based dilation) to simulate quantum channels.</li> <li>Benchmarking quantum simulation results against classical solutions to assess accuracy and validity.</li> </ul> <p>These methods provide a strong foundation for simulating more complex quantum systems and serve as practical tools for investigating open-system dynamics in both research and hardware-based quantum computing.</p>"},{"location":"qflux/Variational_Methods/","title":"Variational Methods  Module","text":""},{"location":"qflux/Variational_Methods/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>variational_methods</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/Variational_Methods/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/Variational_Methods/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/Variational_Methods/#source-code","title":"Source Code","text":""},{"location":"qflux/Variational_Methods/#qflux.variational_methods","title":"<code>qflux.variational_methods</code>","text":""},{"location":"qflux/Variational_Methods/Vectorized_Adaptive/","title":"Amplitude Damping Channel Using UAVQD","text":"<p>This page focuses on the example: amplitude damping using the vectorized variational method with an unrestricted adaptive ansatz. The amplitude damping model describes energy loss from an excited quantum state to a lower-energy state (e.g., spontaneous emission). Here, we simulate this process using:</p> <ul> <li>The vectorized representation of the density matrix.</li> <li>The adaptive variational ansatz, which grows automatically when accuracy drops.</li> <li>A single-qubit system undergoing amplitude damping with decay rate (\\(\\gamma = 1.52 \\times 10^9 \\text{ s}^{-1}\\)).</li> </ul>"},{"location":"qflux/Variational_Methods/Vectorized_Adaptive/#unrestricted-adaptive-variational-quantum-dynamics-uavqd","title":"Unrestricted Adaptive Variational Quantum Dynamics (UAVQD)","text":"<p>This section demonstrates the UAVQD method using the vectorized amplitude damping model. The example illustrates how to set up the simulation, run it with adaptive variational updates, and compare the results against numerically exact <code>QuTiP</code> benchmarks.</p> <p>We first import the required QMAD module from the <code>qflux</code> package and other required standard Python libraries.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom qflux.variational_methods.qmad.solver import solve_avq_vect\nfrom qflux.variational_methods.qmad.effh import VectorizedEffectiveHamiltonian\nfrom qflux.variational_methods.qmad.ansatzVect import Ansatz\n</code></pre> <p>Define Pauli matrices and ladder operators, which will form the building block for the representation for the amplitude damping process.</p> <pre><code>sx = np.array([[0, 1], [1, 0]])\nsy = np.array([[0, -1j], [1j, 0]])\nsp = (sx + 1j * sy) / 2  # raising operator\nId = np.eye(2, dtype=np.complex128)\n</code></pre> <p>We now define simulation parameters such as total time (<code>tf</code>), time step (<code>dt</code>), and damping rate (<code>gamma</code>). These match typical amplitude damping timescales for a single qubit.</p> <pre><code>tf = 1000e-12   # 1 ns\ndt = 1000e-13   # 0.1 ns\ngamma = 1.52e9  # decay rate in s^-1\n</code></pre> <p>The system Hamiltonian is taken as identity since this model focuses on dissipation rather than coherent evolution.</p> <pre><code>H_base = np.eye(2, dtype=np.complex128)\n</code></pre>"},{"location":"qflux/Variational_Methods/Vectorized_Adaptive/#constructing-the-vectorized-effective-hamiltonian","title":"Constructing the Vectorized Effective Hamiltonian","text":"<p>The vectorized formalism rewrites the Lindblad master equation as a linear equation acting on a vectorized density matrix. The function below constructs the corresponding effective Hamiltonian used in the variational evolution.</p> <pre><code>H_vec = VectorizedEffectiveHamiltonian(H_base, gamma, sp)\n</code></pre> <p>This automatically builds the dissipative superoperator terms associated with the amplitude damping collapse operator.</p> <p>We initialize the quantum state and define an unrestricted adaptive ansatz. The ansatz adjusts its depth automatically based on the residual norm computed during evolution.</p> <pre><code>u0 = np.array([1/2, np.sqrt(3)/2], dtype=np.complex128)\nu0 /= np.linalg.norm(u0)\nansatz = Ansatz(u0, relrcut=1e-6)\n</code></pre> <p>The <code>relrcut</code> parameter determines the sensitivity of adaptive growth: smaller values increase precision but require deeper circuits.</p>"},{"location":"qflux/Variational_Methods/Vectorized_Adaptive/#running-the-uavqd-simulation","title":"Running the UAVQD Simulation","text":"<p>We now evolve the system using the adaptive variational solver <code>solve_avq_vect</code>. The function returns time steps and density matrices over the full trajectory. </p> <pre><code>res = solve_avq_vect(H_vec, ansatz, [0, tf], dt)\n</code></pre> <p>Extract ground and excited state populations from the diagonal elements of the resulting density matrices.</p> <pre><code>excited = [res.u[i][1, 1].real for i in range(len(res.u))]\nground  = [res.u[i][0, 0].real for i in range(len(res.u))]\ntimes   = np.arange(0, tf + 1e-30, dt)\n</code></pre>"},{"location":"qflux/Variational_Methods/Vectorized_Adaptive/#operator-pool-definition","title":"Operator Pool Definition","text":"<p>Please note that the default operator pool used in UAVQD simulations is defined within the source code. It consists of basic Pauli operators (<code>sx</code>, <code>sy</code>, <code>sz</code>) that form the minimal basis for constructing the variational ansatz:</p>"},{"location":"qflux/Variational_Methods/Vectorized_Adaptive/#def-build_poolnqbit-paulistr-sx-sz-sy-res-for-order-in-range1-3-for-idx-in-combinationsrange1-nqbit-1-order-for-op-in-productpaulistr-repeatorder-resappendpaulioperatorop-listidx-1-nqbit-return-res","title":"<pre><code>def build_pool(nqbit):\n    pauliStr = [\"sx\", \"sz\", \"sy\"]\n    res = []\n    for order in range(1, 3):\n        for idx in combinations(range(1, nqbit + 1), order):\n            for op in product(pauliStr, repeat=order):\n                res.append(PauliOperator(op, list(idx), 1, nqbit))\n    return res\n</code></pre>","text":""},{"location":"qflux/Variational_Methods/Vectorized_Adaptive/#reference-calculation-using-qutip","title":"Reference Calculation using QuTiP","text":"<p>To validate the UAVQD results, we compute a reference solution using QuTiP\u2019s master equation solver (<code>mesolve</code>).</p> <pre><code>from qutip import mesolve, Qobj, basis\n\nsp = Qobj(sp)\nH  = Qobj(np.eye(2, dtype=np.complex128))\n\n# Time grid matches the UAVQD simulation\ntimes = np.arange(0, tf, dt)\n\n# Define damping operator and initial state\ngamma = 1.52e9\npsi0 = Qobj(u0)\nrho0 = psi0 * psi0.dag()\nc_ops = [np.sqrt(gamma) * sp]\n\n# Projectors for populations\nproj_g = basis(2,0)*basis(2,0).dag()\nproj_e = basis(2,1)*basis(2,1).dag()\n\nres_qutip = mesolve(H, rho0, times, c_ops, [proj_g, proj_e])\nG_q, E_q = res_qutip.expect[0], res_qutip.expect[1]\n</code></pre> <p>Plot QuTiP results for direct comparison.</p> <pre><code>plt.plot(times*1e12, G_q, label='Ground (QuTiP)')\nplt.plot(times*1e12, E_q, label='Excited (QuTiP)')\nplt.xlabel('Time (ps)')\nplt.ylabel('Population')\nplt.legend()\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"qflux/Variational_Methods/Vectorized_Adaptive/#combined-comparison-plot","title":"Combined Comparison Plot","text":"<p>Overlay UAVQD and QuTiP population curves for a unified view.</p> <pre><code>plt.figure(figsize=(8,5))\n\n# QuTiP baseline (solid lines)\nplt.plot(times*1e12, G_q, label='Ground (QuTiP)')\nplt.plot(times*1e12, E_q, label='Excited (QuTiP)')\n\n# UAVQD sampled markers\nstep = max(1, len(times)//10)\nplt.plot(times[::step]*1e12, ground[::step],  '*', label='Ground (UAVQD)')\nplt.plot(times[::step]*1e12, excited[::step], '*', label='Excited (UAVQD)')\n\nplt.xlabel('Time (ps)')\nplt.ylabel('Population')\nplt.legend()\nplt.grid(True, ls='--', lw=1.2)\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"qflux/Variational_Methods/Vectorized_Adaptive/#references","title":"References","text":"<ul> <li>Chen et\u202fal., Adaptive Variational Quantum Dynamics for Open Systems (2024).</li> <li>Shivpuje et al., Designing Variational Ansatz for Quantum-Enabled Simulation of Non-Unitary Dynamical Evolution \u2014 An Excursion into Dicke Superradiance, Adv. Quantum Technol. (2024), https://doi.org/10.1002/qute.202400088</li> </ul>"},{"location":"qflux/Variational_Methods/trajectory_FMO/","title":"FMO Complex Exciton Transfer Dynamics using SSE","text":"<p>This documentation describes how to simulate and visualize the Fenna\u2013Matthews\u2013Olson (FMO) complex exciton transfer dynamics trajectory using an adaptive ansatz variational method framework (<code>QMAD</code>) within the <code>variational_methods</code> module of <code>qflux</code>. The goal is to analyze excitation energy transfer within the FMO system and demonstrate time-dependent propagation of the reduced density matrix.</p> <p>This example of open\u2011system dynamics is based on the stochastic Schr\u00f6dinger equation (SSE). This approach simulates quantum trajectories on the same number of qubits as the system state.</p> <p>Features of SSE Same qubit count as the system state (no duplication) Natural for jump/no\u2011jump dynamics and trajectory parallelization</p>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#stochastic-schrodinger-equation","title":"Stochastic Schr\u00f6dinger Equation","text":"<p>In the SSE picture, a mixed state (\\(\\rho(t)\\)) (usually evolved by a Lindblad master equation) is represented by an ensemble of pure\u2011state trajectories (\\(\\{ |\\psi_c(t)\\rangle \\}\\)). Each trajectory obeys the stochastic differential equation</p> \\[ \\mathrm{d}|\\psi_c(t)\\rangle = \\Big( -i H \\tfrac{1}{2} \\sum_k \\big(L_k^\\dagger L_k - \\langle L_k^\\dagger L_k\\rangle\\big) \\Big) |\\psi_c(t)\\rangle,\\mathrm{d}t - \\sum_k \\Big( \\frac{L_k|\\psi_c(t)\\rangle}{\\langle L_k^\\dagger L_k\\rangle} - |\\psi_c(t)\\rangle \\Big), \\mathrm{d}N_k , \\] <p>where (\\(\\langle\\cdot\\rangle\\)) denotes the expectation with respect to the current state. The binary increment (\\(\\mathrm{d}N_k\\in{0,1}\\)) encodes quantum jumps.</p> <p>Jump probability in a small step (\\(\\mathrm{d}t\\)):</p> \\[ \\mathrm{d}p = \\sum_{k=1}^K \\frac{\\langle \\psi(t) | L_k^\\dagger L_k | \\psi(t) \\rangle}{\\langle \\psi(t) | \\psi(t) \\rangle}, \\mathrm{d}t . \\] <p>If a jump occurs with operator (L_i), update the (unnormalized) state</p> \\[ \\tilde{\\psi}(t+\\mathrm{d}t) = \\frac{L_i,\\tilde{\\psi}(t)}{\\langle \\tilde{\\psi}(t) | L_i^\\dagger L_i | \\tilde{\\psi}(t) \\rangle}, \\] <p>and then normalize to obtain (\\(|\\psi_j(t)\\rangle = \\tilde{\\psi}_j(t)/\\langle \\tilde{\\psi}_j(t)|\\tilde{\\psi}_j(t)\\rangle\\)).</p> <p>Ensemble reconstruction of the density matrix:</p> \\[ \\rho(t) = \\frac{1}{n} \\sum_{j=1}^n |\\psi_j(t)\\rangle\\langle\\psi_j(t)| \\] <p>with accuracy improving as (n) (the number of trajectories) increases.</p>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#implementation-overview","title":"Implementation Overview","text":"<p>We implement a variational trajectory algorithm that alternates deterministic evolution with stochastic jumps. The effective Hamiltonian is split into Hermitian and anti\u2011Hermitian parts, the latter capturing dissipative effects from Lindblad operators.</p>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#effective-hamiltonian-preprocessing","title":"Effective Hamiltonian Pre\u2011processing","text":"<pre><code>from qflux.variational_methods.qmad.effh import EffectiveHamiltonian_class, EffectiveHamiltonian \n</code></pre> <p>Purpose: </p> <p>build (\\(H_\\mathrm{eff} = H_\\mathrm{e} - \\tfrac{i}{2}\\sum_k L_k^\\dagger L_k\\)) and cache jump structures.</p> <p>Notes: After each jump, McLachlan\u2011based adaptive ansatz updates (see below) retune parameters to track the new state efficiently.</p>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#adaptive-ansatz-updates","title":"Adaptive Ansatz Updates","text":"<p>McLachlan\u2019s variational principle selects parameter velocities (\\(\\dot{\\theta}\\)) to minimize the projection error (see Eqs. analogous to (\\(| (\\partial_t + iH)|\\psi(\\theta)\\rangle |\\)) and linear system (\\(M,\\dot{\\theta}=V\\))). We employ a pool of Pauli operators and greedily append gates that keep this McLachlan distance below a threshold, re\u2011optimizing after jumps.</p>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#parallel-trajectories","title":"Parallel Trajectories","text":"<p>Trajectories are independent and run trivially in parallel.</p> <pre><code>from multiprocessing import Pool\n\ndef run_trajectories(num_trajectory, H, ansatz, tf, dt):\n    param_list = [(H, ansatz, tf, dt) for _ in range(num_trajectory)]\n    with Pool() as pool:\n        results = pool.starmap(solve_avq_trajectory, param_list)\n    return results\n</code></pre>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#fmo-complex-sse-trajectory-simulation","title":"FMO Complex: SSE Trajectory Simulation","text":"<p>Here we revisit the Fenna\u2013Matthews\u2013Olson (FMO) complex, but now simulate stochastic trajectories with a compact state representation. We work with NumPy arrays and pad objects to powers of two for qubit compatibility (e.g., \\((5\\times5\\to8\\times8)\\)).</p>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#model-setup-numpy-padded","title":"Model Setup (NumPy, padded)","text":"<pre><code># Hamiltonian (5\u00d75) \u2192 pad to 8\u00d78\nH = [\n    [0, 0, 0, 0, 0],\n    [0, 0.0267, -0.0129, 0.000632, 0],\n    [0, -0.0129, 0.0273, 0.00404, 0],\n    [0, 0.000632, 0.00404, 0, 0],\n    [0, 0, 0, 0, 0],\n]\nH_fmo = np.pad(H, ((0, 3), (0, 3)), mode='constant')\n\n# Lindblad operators (\u03b1, \u03b2, \u03b3) and padding\nalpha, beta, gamma = 3e-3, 5e-7, 6.28e-3\nLlist_f = [np.diag([0]*i + [np.sqrt(alpha)] + [0]*(4-i)) for i in range(1,4)]\nLlist_f += [np.array([[np.sqrt(beta) if (i==0 and j==k) else 0 for j in range(5)] for i in range(5)])\n            for k in range(1,4)]\nL_tmp = np.zeros((5,5)); L_tmp[4,3] = np.sqrt(gamma); Llist_f.append(L_tmp)\nLlist_f_padded = [np.pad(M, ((0,3),(0,3)), mode='constant') for M in Llist_f]\n\n# Initial state |1&gt; in the padded 8\u2011dim space\nu0 = np.zeros(8, dtype=np.complex_); u0_fmo = u0.copy(); u0_fmo[1] = 1\n</code></pre>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#run-trajectories","title":"Run Trajectories","text":"<pre><code>from qflux.variational_methods.qmad.solver import solve_avq_trajectory\nfrom qflux.variational_methods.qmad.effh   import EffectiveHamiltonian\nfrom qflux.variational_methods.qmad.ansatz import Ansatz\n\ntf, dt = 450, 5\nnum_trajectory = 400\nH = EffectiveHamiltonian([H_fmo], [Llist_f_padded])\nansatz = Ansatz(u0_fmo, relrcut=1e-5)\nresults = run_trajectories(num_trajectory, H, ansatz, tf, dt)\n</code></pre>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#postprocessing-populations","title":"Post\u2011processing &amp; Populations","text":"<p>Compute average populations of selected basis states and compare against QuTiP reference results.</p> <pre><code># Diagonal projectors for populations in the padded basis\nMexp_f = [\n    np.diag([0,1,0,0,0,0,0,0]),\n    np.diag([0,0,1,0,0,0,0,0]),\n    np.diag([0,0,0,1,0,0,0,0]),\n    np.diag([1,0,0,0,0,0,0,0]),\n    np.diag([0,0,0,0,1,0,0,0]),\n]\n\navg = [None]*len(Mexp_f)\nfor j in range(num_trajectory):\n    for k, M in enumerate(Mexp_f):\n        ev = []\n        for psi in results[j].psi:                      # trajectory states\n            rho = np.outer(psi, psi.conj())\n            ev.append(np.trace(rho @ M).real)           # population\n        avg[k] = np.array(ev) if avg[k] is None else (avg[k] + np.array(ev))\n\navg = [a/num_trajectory for a in avg]\n# time in results[0].t\n</code></pre> <p></p> <p>Observation: With suitable (\\(\\Delta t\\)), trajectory count, ansatz pool, and McLachlan threshold, SSE trajectories closely track QuTiP\u2019s numerically exact curves.</p>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#adaptive-updates-after-jumps","title":"Adaptive Updates After Jumps","text":"<p>After each detected jump, we:</p> <ol> <li>reset the ansatz reference to the post\u2011jump state,</li> <li>re\u2011select operators from the pool, and</li> <li>re\u2011tune parameters via the McLachlan linear system.</li> </ol> <p>This keeps the variational circuit compact while maintaining accuracy under noise.</p>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#summary","title":"Summary","text":"<ul> <li>SSE avoids qubit doubling and non\u2011local Liouvillians, ideal for NISQ implementations.</li> <li>We decomposed an effective Hamiltonian, evolved quantum trajectories with deterministic and jump segments, and averaged to reconstruct (\\rho(t)).</li> <li>On the FMO complex, SSE trajectories reproduce population dynamics in strong agreement with QuTiP baselines.</li> </ul>"},{"location":"qflux/Variational_Methods/trajectory_FMO/#references-links","title":"References &amp; Links","text":"<ul> <li>Y. Chen et\u202fal., Adaptive variational quantum dynamics for open systems (2024).</li> <li> <p>Shivpuje et al., Designing Variational Ansatz for Quantum-Enabled Simulation of Non-Unitary Dynamical Evolution \u2014 An Excursion into Dicke Superradiance, Adv. Quantum Technol. (2024), https://doi.org/10.1002/qute.202400088</p> </li> <li> <p>Code: QMAD repository: <code>qmad/solver.py</code>, <code>qmad/effh.py</code>, example notebooks: <code>examples/trajectory_FMO*.ipynb</code>.</p> </li> </ul>"},{"location":"qflux/Variational_Methods/varQTE/","title":"Variational Quantum Time Evolution (VarQTE)","text":""},{"location":"qflux/Variational_Methods/varQTE/#motivation","title":"Motivation","text":"<p>The VarQTE module provides tools to simulate quantum processes through two complementary approaches:</p> <ul> <li>Variational Quantum Imaginary Time Evolution (VarQITE)</li> <li>Variational Quantum Real Time Evolution (VarQRTE)</li> </ul> <p>Both methods allow the user to approximate observables of a quantum system by updating the parameters of a parameterized ansatz circuit.</p> <p>Protocol for using VarQTE in practice:</p> <ol> <li>Construct the problem Hamiltonian as a <code>qiskit.SparsePauliOp</code> object</li> <li>Construct the initial state as a <code>qiskit.QuantumCircuit</code></li> <li>Run VarQITE or VarQRTE with the desired hyperparameters (layers, total time, timestep)</li> <li>Obtain ansatz parameters at each timestep</li> <li> <p>Measure observables, either:</p> </li> <li> <p>directly with the <code>ansatz_energy</code> function (for energy), or</p> </li> <li>by constructing the ansatz circuit with <code>Construct_Ansatz</code> (for custom observables).</li> </ol> <p>VarQITE and VarQRTE both employ a TwoLocal ansatz, returning the optimal parameter values at each timestep, which can then be analyzed to study system properties.</p>"},{"location":"qflux/Variational_Methods/varQTE/#import-dependencies","title":"Import Dependencies","text":"<pre><code>!pip install qflux\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nfrom qiskit import QuantumCircuit\nfrom qiskit.quantum_info import SparsePauliOp\n\nfrom qflux.closed_systems.VarQTE import VarQITE, VarQRTE, ansatz_energy, Construct_Ansatz\n</code></pre>"},{"location":"qflux/Variational_Methods/varQTE/#variational-quantum-imaginary-time-evolution-varqite","title":"Variational Quantum Imaginary Time Evolution (VarQITE)","text":"<p>We begin with the Wick-rotated Schr\u00f6dinger equation and apply McLachlan\u2019s Variational Principle:</p> \\[ \\delta \\bigg\\lVert \\Big(\\frac{d}{d\\tau} + \\mathcal{H} - E_{\\tau}\\Big)\\left|{\\psi(\\tau)}\\right\\rangle \\bigg\\rVert = 0 \\] <p>For a parameterized ansatz state,</p> \\[ \\left|{\\psi(\\tau)}\\right\\rangle = \\left|{\\psi(\\theta(\\tau))}\\right\\rangle \\] <p>this leads to a system of linear equations:</p> \\[ \\sum_j A_{ij} \\dot\\theta_j = C_i \\] <p>where</p> \\[     A_{ij} = \\Re\\Bigg(\\frac{\\partial\\left\\langle{\\phi(\\theta(\\tau))}\\right|}{\\partial\\theta_i}\\frac{\\partial\\left|{\\phi(\\theta(\\tau))}\\right\\rangle}{\\partial\\theta_j}\\Bigg), \\] \\[     C_i = - \\Re\\Bigg({\\frac{\\partial\\left\\langle\\phi(\\theta(\\tau))\\right|}{\\partial\\theta_i}}\\mathcal{H}\\left|{\\phi(\\theta(\\tau))}\\right\\rangle\\Bigg). \\] <p>These $A_{ij}$ and $C_i$ values are measured on a quantum device and used to update ansatz parameters:</p> \\[ \\theta(\\tau + d\\tau) = \\theta(\\tau) + \\dot\\theta\\, d\\tau. \\] <p>The derivatives of the quantum state with respect to the variational parameters are linked to the generators \\(G_i\\) of the ansatz:</p> \\[     \\dfrac{\\partial\\left|{\\psi(\\theta(t))}\\right\\rangle}{\\partial\\theta_i} = -i G_i\\left|{\\psi(\\theta(t))}\\right\\rangle. \\] <p>For instance, in the case of a single qubit \\(Z\\)-rotation,</p> \\[     \\dfrac{\\partial}{\\partial\\theta} e^{-i\\theta\\sigma_Z}\\left|{\\psi}\\right\\rangle = -i\\sigma_Ze^{-i\\theta\\sigma_Z}\\left|{\\psi}\\right\\rangle \\] <p>Therefore, one can evaluate the expectation values introduced by the \\(A_{ij}, C_{i}\\) by performing Hadamard tests on the corresponding generators of the ansatz.</p> <p>For example, to determine the elements of the matrix \\(A_{ij}\\), the dagger of the generator of parameter i (\\(G_i^\\dagger\\)) and the parameter of generator j (\\(G_j\\)) must be measured using the same ancilla qubit.  This can be done by initializing the ancilla qubit to the \\(\\left|{0}\\right\\rangle\\) state, and performing a pair of not-gates on the ancilla qubits before and after measuring \\(G_i\\) to measure \\(G_i^\\dagger\\), and subsequently measuring \\(G_i\\) with a Hadamard test using the same ancilla.</p> <p>Reference implementations of this algorithm are used below, using QFlux to simulate the imaginary-time evolution spin-systems. The simulations apply the McLachlan variational principle through the <code>VarQRTE</code> function, demonstrating how variational techniques can efficiently capture quantum dynamics within shallow, noise-resilient circuits.</p>"},{"location":"qflux/Variational_Methods/varQTE/#demonstrations","title":"Demonstrations","text":""},{"location":"qflux/Variational_Methods/varQTE/#example-1-simple-hamiltonian","title":"Example 1: Simple Hamiltonian","text":"<p>Focusing on a simple Hamiltonian, consisting of a spin chain defined by the Pauli-Z matrix, we setup the initial state using a qiskit QuantumCircuit and the hyperparameters for VarQITE, such as number of layers in the ansatz, the timestep and total simulation time. Finally, we call VarQITE to run the time evolution and output the ansatz parameter values.</p> <pre><code># Define the problem Hamiltonian\nH = SparsePauliOp.from_list([(\"Z\", 1.0)])\n\n# Set up the initial state\nqc = QuantumCircuit(3)\n\n# Hyperparameters for VarQITE\nlayers = 0\ntotal_time = 10\ntimestep = 0.1\n\n# Run VarQITE\nparams = VarQITE(layers, H, total_time, timestep, init_circ=qc)\n</code></pre> <p>Furethermore, we can use the parameters to measure observables with a quantum circuit:</p> <pre><code># Measure energy at a given timestep\nmy_energy, my_stdev = ansatz_energy(qc, params[i], H)\n\n# Measure a custom observable\nobservable = SparsePauliOp.from_list([(\"Z\", 1.0)])\nansatz = Construct_Ansatz(qc, params[i], H.num_qubits)\nresult = estimator.run(ansatz, observables=observable).result()\n</code></pre>"},{"location":"qflux/Variational_Methods/varQTE/#example-2-hamiltonian-with-couplings","title":"Example 2: Hamiltonian with couplings","text":"<p>Similarly, we can apply this protocol for a more sophisticated Hamiltonian, containing couplings between different sites:</p> <pre><code>H = SparsePauliOp.from_list([\n    (\"IIZ\", 1.0), (\"IZI\", 1.0), (\"ZII\", 0.65),\n    (\"IXX\", 1.0), (\"IYY\", 1.0),\n    (\"XXI\", 0.75), (\"YYI\", 0.75)\n])\n</code></pre> <p>Initial state and execution:</p> <pre><code>qc = QuantumCircuit(3)\nqc.rx(0.5, 0)\nqc.rx(0.5, 1)\nqc.rx(0.5, 2)\n\nparams = VarQITE(layers, H, total_time, timestep, init_circ=qc)\n</code></pre> <p><code>params</code> now holds the parameter values for the ansatz at each timestep for Imaginary-Time Evolution</p> <p>Plotting the dynamics:</p> <pre><code>all_energies = []\nfor i in range(len(params)):\n    print(f\"Timestep {i} Energy: {ansatz_energy(qc, params[i], H)}\")\n    all_energies.append(ansatz_energy(qc, params[i], H)[0])\n\nplt.title(\"VarQITE Energy Over Imaginary Time\")\nplt.plot([i*timestep for i in range(int(total_time/timestep)+1)], all_energies)\nplt.xlabel(\"Imaginary Time\")\nplt.ylabel(\"Energy (eV)\")\nplt.show()\n</code></pre> <p></p> <p>Interpretation: VarQITE drives the system toward the ground state as imaginary time increases, provided the ansatz is expressive enough. This enables estimation of the ground-state energy by sampling the long-time behavior.</p>"},{"location":"qflux/Variational_Methods/varQTE/#variational-quantum-real-time-evolution-varqrte","title":"Variational Quantum Real Time Evolution (VarQRTE)","text":"<p>Analogous to the problem of finding eigenstates of a Hamiltonian is the problem of dynamics, which can be also be approached with the Variational Quantum Real-Time Evolution (VarQRTE).</p> <p>We now consider real-time dynamics by starting with the Schr\u00f6dinger equation and applying McLachlan\u2019s Variational Principle:</p> \\[     \\delta \\left\\Vert\\left(\\frac{\\partial}{\\partial t} + i\\mathcal{H}\\right)\\left|{\\psi(\\theta(t))}\\right\\rangle\\right\\Vert = 0. \\] <p>The starting state can be evolved through real time in a variational form vary similar to VarQITE, except with one change when calculating the elements of \\(C_i\\),</p> \\[     C_i = - \\Im\\Bigg({\\frac{\\partial \\left\\langle\\phi(\\theta(t))\\right|}{\\partial\\theta_i}} \\mathcal{H}\\left|{\\phi(\\theta(t))}\\right\\rangle\\Bigg). \\] <p>Building upon the same framework as VarQITE, one can measure the \\(A_{ij}\\) and \\(C_i\\) matrices on a quantum computer, and use them to change the parameters \\(\\theta(t+dt) = \\theta(t)+\\dot\\theta dt\\).</p> <p>Within QFlux, <code>VarQRTE</code> reuses the same modular components while invoking <code>Measure_C</code> with <code>evolution_type=\"imaginary\"</code>. This structural parallel highlights how both real- and imaginary-time algorithms are implemented through identical circuit primitives.</p>"},{"location":"qflux/Variational_Methods/varQTE/#demonstration","title":"Demonstration","text":"<p>We proceed by defining the Hamiltonian and initial state, along with instantiating the VarQRTE class with appropriate hyper-parameters.</p> <pre><code>H = SparsePauliOp.from_list([(\"X\", 1.0)])\nqc = QuantumCircuit(1)\nqc.x(0)  # Prepare |1&gt; state\n\nlayers = 1\ntotal_time = 12\ntimestep = 0.1\n\nparams = VarQRTE(layers, H, total_time, timestep, init_circ=qc)\n</code></pre> <p>We can measure observables over time using an Estimator object, supplied with the optimized circuit parameters and the observable circuit.</p> <pre><code>from qiskit_aer.primitives import EstimatorV2 as Estimator\n\nestimator = Estimator()\nobservable = SparsePauliOp.from_list([(\"Z\", 1.0)])\nspin_values = []\n\nfor i in range(len(params)):\n    ansatz = Construct_Ansatz(qc, params[i], H.num_qubits)\n    result = estimator.run(ansatz, observables=observable).result() \n    spin_values.append(result[0].data.evs())\n\nplt.title(\"Spin Expectation Value Over Time\")\nplt.plot([i*timestep for i in range(int(total_time/timestep)+1)], spin_values)\nplt.xlabel(\"Time\")\nplt.ylabel(\"Expectation Value\")\nplt.show()\n</code></pre> <p></p> <p>Interpretation: VarQRTE captures the change in state of quantum systems in real-time. As seen in the example, the expectation value of spin follows the expected sinusoidal pattern of coherent quantum evolution.</p>"},{"location":"qflux/Variational_Methods/var_api/","title":"Variational Methods  Module","text":""},{"location":"qflux/Variational_Methods/var_api/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>variational_methods</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/Variational_Methods/var_api/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/Variational_Methods/var_api/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/Variational_Methods/var_api/#source-code","title":"Source Code","text":""},{"location":"qflux/Variational_Methods/var_api/#qflux.variational_methods","title":"<code>qflux.variational_methods</code>","text":""}]}