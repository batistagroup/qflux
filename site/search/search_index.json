{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the QFlux Documentation","text":"<p>This is a Python package containing various protocols for performing quantum dynamics simulations with quantum devices. Each submodule contains object-oriented implementations for these protocols as demonstrated in our publication, as well as comprehensive tutorial notebooks designed to help users understand, implement and build upon various simulation techniques for studying quantum dynamics using quantum computer frameworks. Each tutorial is provided in Python, using Jupyter Notebooks to offer detailed explanations in both markdown and code comments.</p>"},{"location":"#installation","title":"Installation","text":"<p>This project uses <code>uv</code> for fast and reliable Python package management. To set up your development environment:</p> <pre><code># Create and activate a virtual environment\nuv venv\nsource .venv/bin/activate\n\n# Install the package and all development dependencies\nuv pip install -e \".[dev]\"\n# Initiate pre-commit checks\npre-commit install\n</code></pre> <p>This will install all necessary dependencies, including development tools like pre-commit hooks, testing frameworks, and documentation generators.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>.\n\u251c\u2500\u2500 data/           # Data files and resources\n\u251c\u2500\u2500 docs/           # Documentation files (MkDocs)\n\u251c\u2500\u2500 scripts/        # Utility and automation scripts\n\u251c\u2500\u2500 src/            # Source code\n\u2502   \u2514\u2500\u2500 qflux/\n\u251c\u2500\u2500 tests/          # Test files\n\u251c\u2500\u2500 .github/        # GitHub Actions workflows\n\u251c\u2500\u2500 mkdocs.yml      # MkDocs configuration\n\u251c\u2500\u2500 pyproject.toml  # Project dependencies and settings\n\u2514\u2500\u2500 .pre-commit-config.yaml  # Pre-commit hooks configuration\n</code></pre>"},{"location":"#development-setup","title":"Development Setup","text":""},{"location":"#documentation","title":"Documentation","text":"<p>This project uses MkDocs with the Material theme for documentation. To work with the documentation locally:</p> <ol> <li>Make sure you have all development dependencies installed</li> <li>Run the documentation server:</li> </ol> <pre><code>mkdocs serve\n</code></pre> <ol> <li>Open your browser and navigate to <code>http://127.0.0.1:8000</code></li> </ol> <p>The documentation will automatically reload when you make changes to the markdown files.</p>"},{"location":"#code-quality-tools","title":"Code Quality Tools","text":"<p>We use pre-commit hooks to ensure code quality and consistency. The following tools are configured in <code>.pre-commit-config.yaml</code>:</p> <ul> <li>Ruff: A fast Python linter and formatter</li> <li>Runs linting checks with auto-fix capability</li> <li>Handles code formatting</li> </ul> <p>After installing the development dependencies (as described in the Installation section), enable the pre-commit hooks by running:</p> <pre><code>pre-commit install\n</code></pre> <p>Now the hooks will run automatically on every commit, ensuring code quality and consistency.</p>"},{"location":"#managing-dependencies","title":"Managing Dependencies","text":"<p>This project uses <code>uv</code> for fast and reliable dependency management. Here's how to manage your dependencies:</p>"},{"location":"#adding-new-dependencies","title":"Adding New Dependencies","text":"<p>To add a new package dependency:</p> <pre><code>uv add package_name\n# Add a development dependency\nuv add --dev package_name\n</code></pre> <p>This will:</p> <ol> <li>Install the package in your virtual environment</li> <li>Update your <code>pyproject.toml</code> with the new dependency</li> <li>Update the <code>uv.lock</code> file with exact versions</li> </ol>"},{"location":"#synchronizing-dependencies","title":"Synchronizing Dependencies","text":"<p>If you pull changes that include new dependencies or switch branches, synchronize your environment:</p> <pre><code>uv sync\n</code></pre> <p>This ensures your virtual environment exactly matches the dependencies specified in the lock file, removing any packages you don't need and installing any that are missing.</p>"},{"location":"#writing-documentation","title":"Writing Documentation","text":"<p>This project follows a structured approach to documentation. Each module should have its own markdown file in the <code>docs/batistatemplate/</code> directory. Documentation files might include:</p> <ol> <li>Overview: A brief description of the module's purpose and key features</li> <li>Concepts: Explanation of important concepts and design decisions</li> <li>Examples: Code examples showing common usage patterns</li> <li>Source Code: Auto-generated documentation from source code annotations</li> </ol>"},{"location":"qflux/Closed_Systems/","title":"Closed Systems Documentation and User Guide","text":"<p>This section includes documentation and tutorials focused on illustrating the usage and versatility of the <code>qflux.closed_systems</code> module. </p>"},{"location":"qflux/Closed_Systems/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>closed_systems</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/Closed_Systems/#examples-and-introductory-concepts","title":"Examples and Introductory Concepts","text":"<p>Before we look at doing Quantum Dynamics on a quantum computer, we'll start out by looking at some ways that we can do quantum dynamics on a classical computer! This is an important step as it will familiarize you with the general ingredients of a quantum dynamics simulation and will also provide us with a means of validating the results obtained from a quantum computer.</p> <ul> <li>Anatomy of a Dynamics Simulation: Advanced Use Cases</li> <li>Example: Quantum Harmonic Oscillator</li> <li>Example: Adenine-Thymine Base Pair</li> <li>Example: Spin Chain</li> <li>API Documentation</li> </ul>"},{"location":"qflux/Closed_Systems/AT_basepair/","title":"Simulation of Proton Transfer Dynamics in Adenine-Thymine Base Pair","text":"<p>In this section, we will compute the dynamics for the proton transfer in an Adenine-Thymine Base Pair as it would be implemented on a qubit-based quantum computer. We will model the Adenine-Thymine base pair following this paper. A cartoon schematic of our model is shown here:</p> <p></p>"},{"location":"qflux/Closed_Systems/AT_basepair/#setting-up-the-simulation","title":"Setting Up The Simulation","text":"<p>We have included the Adenine-Thymine base pair potential as a default quartic potential in <code>qflux</code>. It can be implemented with the following code: </p> <pre><code>from qflux.closed_systems.utils import get_proton_mass\nfrom qflux.closed_systems import DynamicsCS\n\nx0 = 1.9592 # x_0 scaling factor\nomega = 0.00436 # frequency corresponding to right well from V''(x)\nproton_mass = get_proton_mass() # Proton mass in a.u.\n\n# Instantiate our class with 128 grid points, initial displacement, mass of proton, and frequency\ndw_dyn_obj = DynamicsCS(n_basis=128, xo=1.5*x0, mass=proton_mass, omega=omega)\n\n# Define our coordinate grid range\ndw_dyn_obj.set_coordinate_operators(x_min=-4.0, x_max=4.0)\n# Initialize operators\ndw_dyn_obj.initialize_operators()\n# Construct initial state\ndw_dyn_obj.set_initial_state(wfn_omega=omega)\n\n# Define the propagation time\ntotal_time = convert_fs_to_au(30.0)\nN_steps = 3000\ndw_dyn_obj.set_propagation_time(total_time, N_steps)\n\n# Set our hamiltonian as a quartic potential\ndw_dyn_obj.set_hamiltonian(potential_type='quartic')\n# Propagate\ndw_dyn_obj.propagate_qSOFT()\ndw_dyn_obj.propagate_SOFT()\ndw_dyn_obj.propagate_qt()\n</code></pre> <p>We can check the initial state by plotting on the potential: </p> <pre><code>import matplotlib.pyplot as plt\nfig, ax = plt.subplots()\nax.plot(dw_dyn_obj.x_grid, dw_dyn_obj._PE_grid + 0.008 , '-', color='black', label='A-T Basepair Potential')\nax.plot(dw_dyn_obj.x_grid, np.real(0.04*dw_dyn_obj.psio_grid.conj()*dw_dyn_obj.psio_grid), '--', color='red', label='Initial Coherent State')\nax.plot(dw_dyn_obj.x_grid, np.real(0.04*dw_dyn_obj.dynamics_results_qSOFT[0].conj()*\n                                   dw_dyn_obj.dynamics_results_qSOFT[0])/dw_dyn_obj.dx,\n        '--o', markevery=3, color='dodgerblue', label='Initial Qubit State')\nax.axhline(0, lw=0.5, color='black', alpha=1.0)\nax.axvline(-dw_dyn_obj.x0, lw=0.5, color='black', alpha=0.5)\nax.axvline(dw_dyn_obj.x0, lw=0.5, color='black', alpha=0.5)\nax.axvline(dw_dyn_obj.x0*1.5, lw=0.5, color='red', alpha=0.5)\nax.set_xlabel('x, Bohr',fontsize=18)\nax.set_ylabel('Energy, Hartree',fontsize=18)We i\nax.tick_params(labelsize=16, grid_alpha=0.5)\nplt.ylim(-0.03,0.07)\nplt.legend(fontsize=14,loc='upper center')\n</code></pre> <p>Which should produce a plot like this: </p> <p></p> <p>And we can also visualize with the final propagated state: </p> <pre><code>from scipy.interpolate import interp1d\nimport numpy as np \n\nx_1024 = np.linspace(dw_dyn_obj.x_grid[0], dw_dyn_obj.x_grid[-1], 1024)\nf_interp = interp1d(dw_dyn_obj.x_grid, dw_dyn_obj.dynamics_results_grid[-1], kind='cubic')\nfq_interp = interp1d(dw_dyn_obj.x_grid, dw_dyn_obj.dynamics_results_qSOFT[-1], kind='cubic')\nrho_interp = f_interp(x_1024)\nrho_q_interp = fq_interp(x_1024)\n\nfig, ax = plt.subplots()\nax.plot(dw_dyn_obj.x_grid, dw_dyn_obj._PE_grid + 0.008,\n        '-',color='black',label='A-T Basepair Potential', lw=3)\nax.plot(dw_dyn_obj.x_grid, 0.04*np.real(dw_dyn_obj.psio_grid.conj()*dw_dyn_obj.psio_grid),\n        '-',color='crimson',label='Initial Coherent State', lw=1.8)\nax.plot(dw_dyn_obj.x_grid, np.real(0.04*dw_dyn_obj.dynamics_results_qSOFT[0].conj()*\n                                   dw_dyn_obj.dynamics_results_qSOFT[0])/dw_dyn_obj.dx,\n        'o', markevery=3, color='crimson', label='Initial Qubit State')\n\nax.plot(x_1024, 0.04*np.real(rho_interp.conj()*rho_interp),'-',color='dodgerblue', \n        label=f'State at t = {convert_au_to_fs(total_time)} fs', lw=1.8)\nax.plot(x_1024, 0.04*np.real(rho_q_interp.conj()*rho_q_interp)/dw_dyn_obj.dx,'o',color='dodgerblue', \n        label=f'Qubit State at t = {convert_au_to_fs(total_time)} fs', lw=0, markevery=3)\n\nax.axhline(0, lw=0.5, color='black', alpha=1.0)\nax.set_xlabel('$x$, Bohr',fontsize=18)\nax.set_ylabel('Energy, Hartree',fontsize=18)\nax.tick_params(labelsize=16, grid_alpha=0.5)\nplt.ylim(-0.03,0.07)\nplt.xlim(-4, 4)\nplt.legend(fontsize=14,loc='upper center')\n</code></pre> <p></p> <p>And we can also look at the expectation value of the position as a function of time: </p> <pre><code>from qflux.closed_systems.utils import calculate_expectation_values, convert_au_to_fs\n\navxgrid = calculate_expectation_values(dw_dyn_obj.dynamics_results_grid, dw_dyn_obj.x_grid)\nqb_x = calculate_expectation_values(dw_dyn_obj.dynamics_results_qSOFT, dw_dyn_obj.x_grid, dx=1)\n\nfig, ax = plt.subplots()\nax.plot(dw_dyn_obj.tlist*convert_au_to_fs(1.), avxgrid, '-', color='dodgerblue',label=r'SOFT')\nax.plot(dw_dyn_obj.tlist*convert_au_to_fs(1.), qb_x, 'o', markevery=50, \n        color='dodgerblue',label=r'qSOFT', lw=0, fillstyle='none', ms=6)\nax.axhline(-x0, ls='--', lw=0.5, color='black', alpha=0.5)\nax.axhline( x0, ls='--', lw=0.5, color='black', alpha=0.5)\nplt.text(20, x0-0.1, 'Reactant Well', fontsize = 16, backgroundcolor='white')\nplt.text(5, -x0-0.1, 'Product Well', fontsize = 16, backgroundcolor='white')\nax.set_xlabel(r'Time, fs')\nax.set_ylabel(r'$\\left\\langle x \\right\\rangle$, Bohr')\nax.tick_params(grid_alpha=0.5)\nplt.ylim(-3,4)\nplt.xlim(-.10, 30.1)\nplt.legend(loc='upper right')\n</code></pre> <p></p> <p>We can see that we have good agreement between the expectation values computed from the qubit dynamics and the classical grid-based dynamics. </p> <p>Lastly, we can visualize the evolution over time and see that the dynamics are nearly identical: </p> <p>Note: We can visualize the quantum circuit behind the evolution for a single time-step: </p> <pre><code>dw_dyn_obj.quantum_circuit.draw('mpl', fold=-1)\n</code></pre> <p>And get a nice simplified diagram for the quantum circuit: </p> <p></p> <p>But, in order to get an actual idea for how complex the circuit is, we should first call the <code>.decompose()</code> method, which will break things up into fundamental gates. The resulting circuit is massive (I'll let you see for yourself!):</p> <pre><code>dw_dyn_obj.quantum_circuit.decompose(reps=1).draw('mpl', fold=-1)\n</code></pre> <p>You can increase the number of <code>reps</code> repetitions that the circuit will be decomposed to further decompose the circuit. Here, we're just going to highlight that the number of non-local gates (those involving at least 2 qubits) is greater than 3000 - far more than we can reasonably run on current NISQ devices. </p>"},{"location":"qflux/Closed_Systems/basics/","title":"Anatomy of a Closed System Quantum Dynamics Simulation","text":"<p>To run a dynamics simulation, we need to define some key quantities. This section will walk you through the process of defining these things within <code>qflux</code>.</p> <p>As a reminder, the task at hand is compute the time evolution of a wavefunction according to the Schrodinger equation: </p> \\[ \\left| \\psi (t) \\right\\rangle = e^{- \\frac{i}{\\hbar} H t} \\left| \\psi_{0} \\right\\rangle \\] <p>To do this, we must: </p> <ul> <li>Define the initial state \\(\\psi_{0}\\). </li> <li>Define the Hamiltonian describing the system of interest.</li> <li>Define a propgation time-step \\(t\\) and the number of time steps \\(n\\) for which we want to compute the evolved wavefunction. </li> </ul> <p>We will now look at how each of these steps can be done with qflux. </p>"},{"location":"qflux/Closed_Systems/basics/#definition-of-the-initial-state","title":"Definition of the Initial State","text":"<p>The initial state is our wavefunction \\(\\psi_{0}\\). In order to define this abstract object on a computer, we must define a finite space in which it exists. The number of discrete points in this space is controlled by the <code>n_basis</code> parameter that is passed to the <code>DynamicsCS</code> class upon instantiation. Note that if you do not define this argument, the default value of 128 is used. Given 128 grid points, we can begin defining operators. To compute the dynamics in the so-called \"Fock basis\", we define the ladder operators \\(\\hat{a}\\), \\(\\hat{x}\\), and \\(\\hat{p}\\). This is done by calling the <code>.intialize_operator()</code> method. To compute the dynamics in the position/coordinate basis, we must define a range of position-values that define the x-grid of our space. This can be done with the <code>.set_coordinate_operators(x_min=-7., x_max=7)</code> method, which will define an array of <code>n_basis</code> points, ranging from <code>x_min</code> to <code>x_max</code>. Now that we've defined the space in which our wavefunction can exist, we can finally define the wavefunction. </p> <p>When instantiating a dynamics object with the <code>DynamicsCS</code> class, there are some other important arguments that are taken into account: </p> <ul> <li><code>xo</code>: The initial displacement in the position-coordinate. </li> <li><code>po</code>: The initial displacement in the momentum-coordinate. </li> <li><code>mass</code>: The mass of the particle/system of interest.</li> </ul> <p>Note that these should all be defined in atomic units. </p> <p>To define the initial state in our default way, you can simply use the <code>.set_initial_state()</code> method. This takes the optional argument of <code>wfn_omega</code> defining the frequency/width of the intiial state, which takes the default value of 1.0 au. The default initial state in the coordinate basis is defined as a Gaussian coherent state: </p> \\[ \\psi_{0} = \\left( \\frac{m \\omega}{\\pi \\hbar} \\right)^{1/4} e^{- \\frac{m \\omega}{2 \\hbar} \\left( x - x_{0} \\right)^{2} + \\frac{i}{\\hbar} p_{0} x} \\] <p>The default initial state in the ladder/Fock basis is defined as the coherent state with amplitude \\(\\alpha = (x_{0} + i p_{0})/ \\sqrt{2}\\), defined in the Fock basis as: </p> \\[ \\left| \\alpha \\right\\rangle = \\sum_{n=0}^{n_{basis}} \\frac{\\alpha^{n}}{\\sqrt{n!}} e^{- \\frac{1}{2} \\left| \\alpha \\right|^{2}} \\left| n \\right\\rangle \\] <p>where \\(n\\) is a state in the Fock basis. </p> <p>Note that <code>qflux</code> also provides functionality for custom state initialization, in which a user-defined function can be provided. </p> <p>Custom initialization in the coordinate basis is done with the <code>.custom_grid_state_initialization()</code> method. This can be used if you wish to initialize with a different state. To exemplify the usage of this functionality, we can define some function that takes arguments necessary to define a state: </p> <pre><code>import numpy as np\n\ndef custom_gaussian(xvals, xo, po, omega, mass, hbar):\n    normalization_factor = (mass * omega / (np.pi * hbar))**(0.25)\n    exp_func = np.exp( - mass * omega / (2 * hbar) * (xvals - xo)**2 + 1j/hbar * po * xvals)\n    return(normalization_factor * exp_func)\n</code></pre> <p>Then, we can set-up a dynamics object that is ready to initialize a state: </p> <pre><code>from qflux.closed_systems import DynamicsCS, QubitDynamicsCS\n\ndyn_obj = DynamicsCS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=0.2)\ndyn_obj.set_coordinate_operators()\ndyn_obj.initialize_operators()\n</code></pre> <p>And define some arguments to provide to the function: </p> <pre><code>func_args = {'xvals': dyn_obj.x_grid,\n             'xo'   : dyn_obj.xo,\n             'po'   : dyn_obj.po,\n             'omega': 1.0,\n             'mass': dyn_obj.mass,\n             'hbar': 1.0}\n</code></pre> <p>And we can now define the state by calling: </p> <pre><code>dyn_obj.custom_grid_state_initialization(custom_gaussian, **func_args)\n</code></pre> <p>Similarly, to define a custom initial state to be used in the Fock/ladder basis, we follow a similar pattern. We first define some custom function that will return a <code>qutip.Qobj</code>: </p> <pre><code>def custom_coherent_state(N_basis):\n    '''\n    Function to define a squeezed coherent state by squeezing, then displacing the vacuum state.\n    '''\n    squeezed_coh_state = qt.displace(N_basis, 2) * qt.squeeze(N_basis, 1.0) * qt.basis(N_basis, 0)\n    return(squeezed_coh_state)\n</code></pre> <p>And define the keyword arguments as a dictionary:</p> <pre><code>qt_func_args = {'N_basis': dyn_obj.n_basis}\n</code></pre> <p>Then we can perform the custom initialization by calling the <code>.custom_ladder_state_initialization()</code> method:</p> <pre><code>dyn_obj.custom_ladder_state_initialization(custom_coherent_state, **qt_func_args)\n</code></pre> <p>For the custom Fock/ladder basis initialization, the custom function must return a <code>qutip.Qobj</code>. </p>"},{"location":"qflux/Closed_Systems/basics/#defining-the-hamiltonian","title":"Defining the Hamiltonian","text":"<p>The next step for running our dynamics simulation is to define the Hamiltonian, which should describe the system of interest. For the coordinate basis, we assume that the Hamiltonian takes the form of: </p> \\[ H = V(x) + \\frac{p^{2}}{2 m} \\] <p>where \\(V(x)\\) describes the potential energy of our system. <code>qflux</code> provides some example systems out of the box, which we will now demonstrate how to use.</p> <p>To use the built-in potential energy functions, all one must do is use the <code>.set_hamiltonian()</code> method. This method has the optional keyword argument <code>potential_type</code>, which can be used to choose one of the two currently implemented potentials: - Harmonic Oscillator Potential - Arbitrary Quartic Potential</p> <p>The harmonic oscilator potential is implemented in the grid-basis as: </p> \\[ V(x) = \\frac{1}{2} m \\omega^{2} x^{2} \\] <p>and in the ladder basis as: </p> \\[ H = \\hbar \\omega \\left( \\hat{a}^{\\dagger} \\hat{a} + \\frac{1}{2} \\right) \\] <p>The frequency (\\(\\omega\\)) and mass (\\(m\\)) can be controlled when instantiating the dynamics object with the <code>mass</code> and <code>omega</code> keyword arguments. </p> <p>The quartic potential is implemented as: </p> \\[ V(x) = a_{0} + a_{1} \\frac{x}{x_{0}} + a_{2} \\frac{x^{2}}{x_{0}^{2}} + a_{3} \\frac{x^{3}}{x_{0}^{3}} + a_{4} \\frac{x^{4}}{x_{0}^{4}} \\] <p>To use a custom quartic potential, the user should provide a dictionary of keyword arguments that define the coefficients (\\(a_{0}, a_{1}, a_{2}, a_{3}, a_{4}\\)) and the scaling factor \\(x_{0}\\): </p> <pre><code>coeffs_dict = {'a0': 1, 'a1': 1, 'a2': 1, 'a3': 1, 'a4': 1, 'x0': 1}\ndyn_obj.set_hamiltonian(potential_type='quartic', **coeffs_dict)\n</code></pre> <p>For the Fock/ladder basis, the \\(x\\) in the previous equation is replaced with an operator \\(\\hat{a}\\) defined in terms of the creation and annihilation operators as \\(\\hat{x} = \\frac{1}{\\sqrt{2}} \\left( \\hat{a}^{\\dagger} + \\hat{a} \\right)\\) and in the kinetic energy term \\(\\frac{p^{2}}{2m}\\), \\(p\\) is replaced with \\(\\hat{p} =  \\frac{i}{\\sqrt{2}} \\left( \\hat{a}^{\\dagger} - \\hat{a} \\right)\\).</p> <p><code>qflux</code> also supports arbitrary customization of the potential energy function by use of the <code>.set_H_grid_with_custom_potential()</code> and <code>.set_H_op_with_custom_potential()</code> methods. These methods expect a function and a dictionary (of keyword arguments for that function) as arguments. This is illustrated in the following example: </p> <p>Suppose you have some arbitrary Morse-like potential of the form:</p> \\[ V_{Morse} = De ( 1 - e^{- a (x-x_{eq})})^{2} \\] <p>We can define a python function to to construct this potential:</p> <pre><code>def morse_potential(x_eq=None, mass=None, omega=None, xval=None):\n    De = 8\n    xe = 0\n    k = mass*omega**2\n    a = np.sqrt(k/(2*De))\n    y = De * ((1 - np.exp(-a*(xval-x_eq)))**2)\n    return(y)\n</code></pre> <p>And define a dictionary with parameters to define a specific potential:</p> <pre><code>morse_args = {'x_eq': -1.0, 'mass': 1.0, 'omega': 1.5, 'xval': dyn_obj.x_grid}\n</code></pre> <p>And then construct a Hamiltonian with this custom function for our dynamics object by calling: </p> <pre><code>dyn_obj.set_H_grid_with_custom_potential(morse_potential, **morse_args)\n</code></pre> <p>Similarly, we can do this in a <code>qutip.Qobj</code>-compatible format: </p> <pre><code>def morse_potential_op(x_eq=None, mass=None, omega=None, xval=None):\n    De = 8\n    xe = 0\n    k = mass*omega**2\n    a = np.sqrt(k/(2*De))\n    exponential_f = (-a * (xval - x_eq)).expm()\n    y = De * ((1 - exponential_f)**2)\n    return(y)\n</code></pre> <p>And define our dictionary of custom parameters: </p> <pre><code>morse_op_args = {'x_eq': -1.0, 'mass': 1.0, 'omega': 1.5, 'xval': dyn_obj.x_op}\n</code></pre> <p>And finally we can set our Hamiltonian for the Fock/ladder basis by calling: </p> <pre><code>dyn_obj.set_H_op_with_custom_potential(morse_potential_op, **morse_op_args)\n</code></pre>"},{"location":"qflux/Closed_Systems/basics/#definition-of-the-time-grid","title":"Definition of the Time Grid","text":"<p>Given some total propagation time \\(t_{\\text{final}}\\) and a number of steps \\(N_{\\text{steps}}\\), the time list is generated as a numpy array ranging from \\(0\\) to \\(t_{\\text{final}}\\) with an interval \\(dt = t_{\\textrm{final}} / N_{\\text{steps}}\\). This is done with <code>qflux</code> by calling the <code>.set_propagation_time(total_time=20, n_tsteps=400)</code> method. </p>"},{"location":"qflux/Closed_Systems/cs_api/","title":"Source Code","text":""},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems","title":"<code>qflux.closed_systems</code>","text":""},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS","title":"<code>DynamicsCS</code>","text":"<p>Class for closed-system dynamics. All input parameters must be in atomic units to ensure consistency. Please be sure to convert your parameters to atomic units prior to instantiation.</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>class DynamicsCS:\n    \"\"\"\n        Class for closed-system dynamics. **All input parameters must be in\n        atomic units to ensure consistency. Please be sure to convert your\n        parameters to atomic units prior to instantiation.**\n\n    \"\"\"\n\n    def __init__(self, n_basis: int = 128, xo: float = 1.0, po: float = 0.0, mass: float = 1.0,\n                 omega: float = 1.0) -&gt; None:\n        \"\"\"\n        Args:\n            n_basis (int): Number of states to include in the chosen representation. If basis\n                = 'ladder', this is the Fock cutoff and defines the number of states\n                used for representing the ladder operators. If basis = 'coordinate',\n                this defines the number of points for the position and momenta.\n\n            xo (float, optional): Defines the displacement of the initial state in the position\n                coordinate. Default is 1.0 Bohr.\n\n            po (float, optional): Defines the displacement of the initial state in the position\n                coordinate. Default is 1.0 au.\n\n            mass (float, optional): Defines the mass of the particle/system of interest.\n                Default is 1.0 au.\n\n            omega (float, optional): Frequency of harmonic oscillator.\n                Default is 1.0 au.\n\n        \"\"\"\n        #--------- Required Attributes Populated During Execution ----------#\n        self.n_basis                   = n_basis\n        self.xo                        = xo\n        self.po                        = po\n        self.mass                      = mass\n        self.hbar                      = 1.0\n        self.omega                     = omega\n        #--------- Below are Attributes Populated During Execution ---------#\n        self.total_time                = 0.\n        self.n_tsteps                  = 0.\n        self._KE_op                    = None\n        self._PE_op                    = None\n        self.H_op                      = None\n        self.prop_KE_op                = None\n        self.prop_PE_op                = None\n        self.prop_H_op                 = None\n        # Grid operators\n        self._KE_grid                  = None\n        self._PE_grid                  = None\n        self.H_grid                    = None\n        self.PE_prop_grid              = None\n        self.KE_prop_grid              = None\n\n\n    def _get_xgrid(self, x_min: float, x_max: float) -&gt; None:\n        \"\"\"\n        Populate the `self.x_grid` and `self.dx` attributes. This function\n        generates an array of `self.n_basis` evenly spaced values between\n        `x_min` and `x_max`.\n\n        Args:\n            x_min (float): Minimum value of x-coordinates\n            x_max (float): Maximum value of x-coordinates\n\n        Returns:\n            self.dx (float): Spacing between points in the x-coordinate grid.\n            self.xgrid (array_like): Array of grid points from x_min to x_max with spacing of dx\n        \"\"\"\n        dx = (x_max - x_min) / self.n_basis\n        x_grid = np.arange(-self.n_basis / 2, self.n_basis / 2) * dx\n        self.dx = dx\n        self.x_grid = x_grid\n        return\n\n\n    def _get_pgrid(self, x_min: float, x_max: float, reorder: bool = True) -&gt; None:\n        \"\"\"\n        Populate the `self.p_grid` and `self.dp` attributes. This function\n        generates an array of `self.n_basis` evenly spaced values.\n\n        Args:\n            x_min (float): Minimum value of x-coordinates\n            x_max (float): Maximum value of x-coordinates\n            reorder (bool): Boolean flag to determine whether points should be reordered to be\n                compatible with the FFT routine or not.\n\n        Returns:\n            self.dp (float): Spacing between points in the p-coordinate grid.\n            self.pgrid (array_like): Array of momentum grid points\n        \"\"\"\n        dp = 2 * np.pi / (x_max - x_min)\n        pmin = -dp * self.n_basis / 2\n        pmax = dp * self.n_basis / 2\n        plus_pgrid = np.linspace(0, pmax, self.n_basis // 2 + 1)\n        minus_pgrid = - np.flip(np.copy(plus_pgrid))\n        if reorder:\n            p_grid = np.concatenate((plus_pgrid[:-1], minus_pgrid[:-1]))\n        else:\n            p_grid = np.concatenate((minus_pgrid, plus_pgrid))\n        self.p_grid = p_grid\n        self.dp = dp\n        return\n\n\n    def set_coordinate_operators(self, x_min: float = -7., x_max: float = 7., reorder_p: bool = True) -&gt; None:\n        \"\"\"\n        Populate the `self.x_grid`, `self.p_grid`, `self.dx`, and `self.dp`\n        attributes. This functions generates an array of `self.n_basis`\n        evenly spaced values.\n\n        Args:\n            x_min : float\n                Minimum value of x-coordinates\n            x_max : float\n                Maximum value of x-coordinates\n            reorder_p : bool\n                Boolean flag to determine whether momentum values should be\n                reordered to be compatible with the FFT routine or not.\n\n        Returns:\n            self.dx : float\n                Spacing between points in the x-coordinate grid.\n            self.xgrid : array_like\n                Array of x-values\n            self.dp : float\n                Spacing between points in the p-coordinate grid.\n            self.pgrid : array_like\n                Array of p-values\n        \"\"\"\n        self._get_xgrid(x_min, x_max)\n        self._get_pgrid(x_min, x_max, reorder=reorder_p)\n        return\n\n\n    def initialize_operators(self):\n        \"\"\"\n            Function to initialize core operators in the chosen basis.\n\n        \"\"\"\n\n        self.a_op = qt.destroy(self.n_basis)\n        self.x_op = qt.position(self.n_basis)\n        self.p_op = qt.momentum(self.n_basis)\n        return\n\n\n    def _set_hamiltonian_grid(self, potential_type: str = 'harmonic', **kwargs):\n        if potential_type == 'harmonic':\n\n            # Set attributes for the coordinate basis\n            self._PE_grid = self.mass * self.omega ** 2 * self.x_grid ** 2 / 2.\n            self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n            self.H_grid = self._PE_grid + self._KE_grid\n        elif potential_type == 'quartic':\n            if kwargs:\n                if 'a0' in kwargs:\n                    a0 = kwargs['a0']\n                if 'a1' in kwargs:\n                    a1 = kwargs['a1']\n                if 'a2' in kwargs:\n                    a2 = kwargs['a2']\n                if 'a3' in kwargs:\n                    a3 = kwargs['a3']\n                if 'a4' in kwargs:\n                    a4 = kwargs['a4']\n                if 'x0' in kwargs:\n                    x0 = kwargs['x0']\n                # Assume that all inputs have the proper atomic units:\n                cf = 1.0\n                xi = self.x_op\n\n            else:\n                # Define relevant parameters\n                cf = convert_eV_to_au(1.)\n                x0 = 1.9592\n                a0 = 0.0\n                a1 = 0.429\n                a2 = -1.126\n                a3 = -0.143\n                a4 = 0.563\n                # Do calculation for ladder basis\n                xi = self.x_grid / x0\n            self._PE_grid = cf * (a0 + a1 * xi + a2 * xi ** 2 + a3 * xi ** 3 + a4 * xi ** 4)\n            self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n            self.H_grid = self._PE_grid + self._KE_grid\n        return\n\n\n    def _set_hamiltonian_qt(self, potential_type: str = 'harmonic', **kwargs):\n        if potential_type == 'harmonic':\n            # Set attributes for the ladder basis\n            self.H_op = self.hbar * self.omega * (self.a_op.dag() * self.a_op + 0.5)\n            self._KE_op = self.p_op ** 2 / (2. * self.mass)\n            self._PE_op = self.mass * self.omega ** 2 * self.x_op ** 2 / 0.5\n            self.H_xp_op = self._PE_op + self._KE_op\n        elif potential_type == 'quartic':\n            if kwargs:\n                if 'a0' in kwargs:\n                    a0 = kwargs['a0']\n                if 'a1' in kwargs:\n                    a1 = kwargs['a1']\n                if 'a2' in kwargs:\n                    a2 = kwargs['a2']\n                if 'a3' in kwargs:\n                    a3 = kwargs['a3']\n                if 'a4' in kwargs:\n                    a4 = kwargs['a4']\n                if 'x0' in kwargs:\n                    x0 = kwargs['x0']\n                # Assume that all inputs have the proper atomic units:\n                cf = 1.0\n                xi = self.x_op\n\n            else:\n                # Define relevant parameters\n                cf = convert_eV_to_au(1.)\n                x0 = 1.9592\n                a0 = 0.0\n                a1 = 0.429\n                a2 = -1.126\n                a3 = -0.143\n                a4 = 0.563\n                # Do calculation for ladder basis\n                xi = self.x_op / x0\n            self.x0 = x0\n            self._PE_op = cf * (a0 + a1 * xi + a2 * xi ** 2 + a3 * xi ** 3 + a4 * xi ** 4)\n            self._KE_op = self.p_op ** 2 / (2. * self.mass)\n            self.H_op = self._PE_op + self._KE_op\n            return\n\n    def set_hamiltonian(self, potential_type: str = 'harmonic', **kwargs):\n        \"\"\"\n        Function to define Hamiltonian.\n\n        Args:\n            potential_type : str\n                String defining the type of potential energy surface.\n                Available options are: ('harmonic', 'quartic', ...)\n\n                Note: You can manually define your potential energy using the functions:\n                    - set_H_grid_with_custom_potential\n                    - set_H_op_with_custom_potential\n\n        \"\"\"\n\n        if potential_type == 'harmonic':\n            self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n            self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n        elif potential_type == 'quartic':\n            self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n            self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n        else:\n            print('Error, this potential type has not yet been implemented!')\n            print('Set your parameters with the custom functions!')\n        return\n\n\n    def set_H_grid_with_custom_potential(self, custom_function: Callable, **kwargs):\n        \"\"\"\n        Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n        Args:\n            custom_function (Callable): Function that defines the custom potential\n                energy. Must return an array\n\n        \"\"\"\n        potential = custom_function(**kwargs)\n        self._PE_grid = potential\n        self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n        self.H_grid = self._PE_grid + self._KE_grid\n        return\n\n\n    def set_H_op_with_custom_potential(self, custom_function: Callable, **kwargs):\n        \"\"\"\n        Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n        Args:\n            custom_function (Callable): Function that defines the potential\n                energy in terms of qutip QObj operators. Must return a qutip.Qobj\n        \"\"\"\n        potential = custom_function(**kwargs)\n        self._PE_op = potential\n        self._KE_op = self.p_op ** 2 / (2. * self.mass)\n        self.H_op = self._PE_op + self._KE_op\n        return\n\n\n    def set_initial_state(self, wfn_omega: float = 1.0):\n        \"\"\"\n        Function to define the initial state. By default, a coherent state is\n        used as the initial state defined in the basis chosen upon instantiation\n\n        Args:\n            wfn_omega (float, optional): Defines the frequency/width of the initial state.\n                Default is 1.0 au.\n        \"\"\"\n\n        alpha_val = (self.xo + 1j * self.po) / np.sqrt(2)\n        psio = qt.coherent(self.n_basis, alpha=alpha_val)\n        # Now populate the initial state in the grid basis\n        normalization = (self.mass * wfn_omega / np.pi / self.hbar) ** (0.25)\n        exponential = np.exp(-1 * (self.mass * wfn_omega / self.hbar / 2) *\n                             ((self.x_grid - self.xo) ** 2)\n                             + 1j * self.po * self.x_grid / self.hbar\n                             )\n\n        coherent_state = normalization * exponential\n        # Set the attributes\n        self.psio_grid = coherent_state\n        self.psio_op = psio\n        return\n\n\n\n    def custom_grid_state_initialization(self, function_name: Callable, **kwargs):\n        \"\"\"\n        Function to allow for customized grid state initialization.\n\n        Args:\n            function_name (Callable): name of user-defined function that returns\n                the initial state. Must return an array\n        \"\"\"\n\n        self.psio_grid = function_name(**kwargs)\n        return\n\n    def custom_ladder_state_initialization(self, function_name: Callable, **kwargs):\n        \"\"\"\n        Function to allow for customized ladder state initialization.\n\n        Args:\n            function_name (Callable): name of user-defined function that returns\n                the initial state. Must return a qutip.Qobj.\n        \"\"\"\n\n        self.psio_op = function_name(**kwargs)\n        return\n\n    def set_propagation_time(self, total_time: float, n_tsteps: int):\n        \"\"\"\n        Function to define the propagation time, an array of times from\n        t=0 to total_time, with n_tsteps equally-spaced steps.\n\n        Args:\n        total_time : float\n            The total time for which we wish to compute the dynamics.\n        n_tsteps : int\n            The number of equally-spaced time steps used to compute the dynamics\n\n        Returns:\n        self.tlist : array-like\n\n        \"\"\"\n\n        self.tlist = np.linspace(0., total_time, n_tsteps+1)\n        self.dt = self.tlist[1] - self.tlist[0]\n        return\n\n\n    def propagate_qt(self, solver_options : dict = None):\n        \"\"\"\n        Function used to propagate with qutip.\n\n        Args:\n            solver_options (dict): A dictionary of arguments to pass to the qutip.sesolve function\n\n        Returns:\n            dynamics_results (array-like): array containing the propagated state\n\n        \"\"\"\n\n        options = {'nsteps': len(self.tlist),\n                    'progress_bar': True}\n\n        if solver_options:\n            for key in solver_options:\n                options[key] = solver_options[key]\n\n        results = qt.sesolve(self.H_op, self.psio_op, self.tlist,\n                             options=options)\n\n        self.dynamics_results_op = results\n        return\n\n\n    def propagate_SOFT(self):\n        \"\"\"\n        Function used to propagate with the 2nd-Order Trotter Expansion.\n\n        $$\n        e^{- \\frac{i}{\\\\hbar} H t} \\approx e^{- \\frac{i}{\\\\hbar} V t/2} e^{- \\frac{i}{\\\\hbar} T t} e^{- \\frac{i}{\\\\hbar} V t/2} + \\\\mathcal{O}^{3}\n        $$\n\n        Returns:\n            dynamics_results_grid (array-like): array containing the propagated state\n                                                shape (n_tsteps x self.n_basis)\n\n        \"\"\"\n        self.tau = self.tlist[1] - self.tlist[0]\n        PE_prop = np.exp(-1.0j * self._PE_grid / 2 * self.tau / self.hbar)\n        KE_prop = np.exp(-1.0j * self._KE_grid * self.tau / self.hbar)\n\n        self.PE_prop_grid = PE_prop\n        self.KE_prop_grid = KE_prop\n\n        propagated_states = [self.psio_grid]\n        psi_t = self.psio_grid\n        for ii in range(1, len(self.tlist)):\n            psi_t_position_grid = PE_prop * psi_t\n            psi_t_momentum_grid = KE_prop * np.fft.fft(psi_t_position_grid, norm=\"ortho\")\n            psi_t = PE_prop * np.fft.ifft(psi_t_momentum_grid, norm=\"ortho\")\n            propagated_states.append(psi_t)\n\n        self.dynamics_results_grid = np.asarray(propagated_states)\n        return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.__init__","title":"<code>__init__(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>n_basis</code> <code>int</code> <p>Number of states to include in the chosen representation. If basis = 'ladder', this is the Fock cutoff and defines the number of states used for representing the ladder operators. If basis = 'coordinate', this defines the number of points for the position and momenta.</p> <code>128</code> <code>xo</code> <code>float</code> <p>Defines the displacement of the initial state in the position coordinate. Default is 1.0 Bohr.</p> <code>1.0</code> <code>po</code> <code>float</code> <p>Defines the displacement of the initial state in the position coordinate. Default is 1.0 au.</p> <code>0.0</code> <code>mass</code> <code>float</code> <p>Defines the mass of the particle/system of interest. Default is 1.0 au.</p> <code>1.0</code> <code>omega</code> <code>float</code> <p>Frequency of harmonic oscillator. Default is 1.0 au.</p> <code>1.0</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def __init__(self, n_basis: int = 128, xo: float = 1.0, po: float = 0.0, mass: float = 1.0,\n             omega: float = 1.0) -&gt; None:\n    \"\"\"\n    Args:\n        n_basis (int): Number of states to include in the chosen representation. If basis\n            = 'ladder', this is the Fock cutoff and defines the number of states\n            used for representing the ladder operators. If basis = 'coordinate',\n            this defines the number of points for the position and momenta.\n\n        xo (float, optional): Defines the displacement of the initial state in the position\n            coordinate. Default is 1.0 Bohr.\n\n        po (float, optional): Defines the displacement of the initial state in the position\n            coordinate. Default is 1.0 au.\n\n        mass (float, optional): Defines the mass of the particle/system of interest.\n            Default is 1.0 au.\n\n        omega (float, optional): Frequency of harmonic oscillator.\n            Default is 1.0 au.\n\n    \"\"\"\n    #--------- Required Attributes Populated During Execution ----------#\n    self.n_basis                   = n_basis\n    self.xo                        = xo\n    self.po                        = po\n    self.mass                      = mass\n    self.hbar                      = 1.0\n    self.omega                     = omega\n    #--------- Below are Attributes Populated During Execution ---------#\n    self.total_time                = 0.\n    self.n_tsteps                  = 0.\n    self._KE_op                    = None\n    self._PE_op                    = None\n    self.H_op                      = None\n    self.prop_KE_op                = None\n    self.prop_PE_op                = None\n    self.prop_H_op                 = None\n    # Grid operators\n    self._KE_grid                  = None\n    self._PE_grid                  = None\n    self.H_grid                    = None\n    self.PE_prop_grid              = None\n    self.KE_prop_grid              = None\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS._get_pgrid","title":"<code>_get_pgrid(x_min, x_max, reorder=True)</code>","text":"<p>Populate the <code>self.p_grid</code> and <code>self.dp</code> attributes. This function generates an array of <code>self.n_basis</code> evenly spaced values.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <code>float</code> <p>Minimum value of x-coordinates</p> required <code>x_max</code> <code>float</code> <p>Maximum value of x-coordinates</p> required <code>reorder</code> <code>bool</code> <p>Boolean flag to determine whether points should be reordered to be compatible with the FFT routine or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>self.dp (float): Spacing between points in the p-coordinate grid.</p> <code>None</code> <p>self.pgrid (array_like): Array of momentum grid points</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def _get_pgrid(self, x_min: float, x_max: float, reorder: bool = True) -&gt; None:\n    \"\"\"\n    Populate the `self.p_grid` and `self.dp` attributes. This function\n    generates an array of `self.n_basis` evenly spaced values.\n\n    Args:\n        x_min (float): Minimum value of x-coordinates\n        x_max (float): Maximum value of x-coordinates\n        reorder (bool): Boolean flag to determine whether points should be reordered to be\n            compatible with the FFT routine or not.\n\n    Returns:\n        self.dp (float): Spacing between points in the p-coordinate grid.\n        self.pgrid (array_like): Array of momentum grid points\n    \"\"\"\n    dp = 2 * np.pi / (x_max - x_min)\n    pmin = -dp * self.n_basis / 2\n    pmax = dp * self.n_basis / 2\n    plus_pgrid = np.linspace(0, pmax, self.n_basis // 2 + 1)\n    minus_pgrid = - np.flip(np.copy(plus_pgrid))\n    if reorder:\n        p_grid = np.concatenate((plus_pgrid[:-1], minus_pgrid[:-1]))\n    else:\n        p_grid = np.concatenate((minus_pgrid, plus_pgrid))\n    self.p_grid = p_grid\n    self.dp = dp\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS._get_xgrid","title":"<code>_get_xgrid(x_min, x_max)</code>","text":"<p>Populate the <code>self.x_grid</code> and <code>self.dx</code> attributes. This function generates an array of <code>self.n_basis</code> evenly spaced values between <code>x_min</code> and <code>x_max</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <code>float</code> <p>Minimum value of x-coordinates</p> required <code>x_max</code> <code>float</code> <p>Maximum value of x-coordinates</p> required <p>Returns:</p> Type Description <code>None</code> <p>self.dx (float): Spacing between points in the x-coordinate grid.</p> <code>None</code> <p>self.xgrid (array_like): Array of grid points from x_min to x_max with spacing of dx</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def _get_xgrid(self, x_min: float, x_max: float) -&gt; None:\n    \"\"\"\n    Populate the `self.x_grid` and `self.dx` attributes. This function\n    generates an array of `self.n_basis` evenly spaced values between\n    `x_min` and `x_max`.\n\n    Args:\n        x_min (float): Minimum value of x-coordinates\n        x_max (float): Maximum value of x-coordinates\n\n    Returns:\n        self.dx (float): Spacing between points in the x-coordinate grid.\n        self.xgrid (array_like): Array of grid points from x_min to x_max with spacing of dx\n    \"\"\"\n    dx = (x_max - x_min) / self.n_basis\n    x_grid = np.arange(-self.n_basis / 2, self.n_basis / 2) * dx\n    self.dx = dx\n    self.x_grid = x_grid\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.custom_grid_state_initialization","title":"<code>custom_grid_state_initialization(function_name, **kwargs)</code>","text":"<p>Function to allow for customized grid state initialization.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>Callable</code> <p>name of user-defined function that returns the initial state. Must return an array</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def custom_grid_state_initialization(self, function_name: Callable, **kwargs):\n    \"\"\"\n    Function to allow for customized grid state initialization.\n\n    Args:\n        function_name (Callable): name of user-defined function that returns\n            the initial state. Must return an array\n    \"\"\"\n\n    self.psio_grid = function_name(**kwargs)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.custom_ladder_state_initialization","title":"<code>custom_ladder_state_initialization(function_name, **kwargs)</code>","text":"<p>Function to allow for customized ladder state initialization.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>Callable</code> <p>name of user-defined function that returns the initial state. Must return a qutip.Qobj.</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def custom_ladder_state_initialization(self, function_name: Callable, **kwargs):\n    \"\"\"\n    Function to allow for customized ladder state initialization.\n\n    Args:\n        function_name (Callable): name of user-defined function that returns\n            the initial state. Must return a qutip.Qobj.\n    \"\"\"\n\n    self.psio_op = function_name(**kwargs)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.initialize_operators","title":"<code>initialize_operators()</code>","text":"<p>Function to initialize core operators in the chosen basis.</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def initialize_operators(self):\n    \"\"\"\n        Function to initialize core operators in the chosen basis.\n\n    \"\"\"\n\n    self.a_op = qt.destroy(self.n_basis)\n    self.x_op = qt.position(self.n_basis)\n    self.p_op = qt.momentum(self.n_basis)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.propagate_SOFT","title":"<code>propagate_SOFT()</code>","text":"<p>Function used to propagate with the 2nd-Order Trotter Expansion.</p> \\[ e^{- \frac{i}{\\hbar} H t} \u0007pprox e^{- \frac{i}{\\hbar} V t/2} e^{- \frac{i}{\\hbar} T t} e^{- \frac{i}{\\hbar} V t/2} + \\mathcal{O}^{3} \\] <p>Returns:</p> Name Type Description <code>dynamics_results_grid</code> <code>array - like</code> <p>array containing the propagated state                                 shape (n_tsteps x self.n_basis)</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def propagate_SOFT(self):\n    \"\"\"\n    Function used to propagate with the 2nd-Order Trotter Expansion.\n\n    $$\n    e^{- \\frac{i}{\\\\hbar} H t} \\approx e^{- \\frac{i}{\\\\hbar} V t/2} e^{- \\frac{i}{\\\\hbar} T t} e^{- \\frac{i}{\\\\hbar} V t/2} + \\\\mathcal{O}^{3}\n    $$\n\n    Returns:\n        dynamics_results_grid (array-like): array containing the propagated state\n                                            shape (n_tsteps x self.n_basis)\n\n    \"\"\"\n    self.tau = self.tlist[1] - self.tlist[0]\n    PE_prop = np.exp(-1.0j * self._PE_grid / 2 * self.tau / self.hbar)\n    KE_prop = np.exp(-1.0j * self._KE_grid * self.tau / self.hbar)\n\n    self.PE_prop_grid = PE_prop\n    self.KE_prop_grid = KE_prop\n\n    propagated_states = [self.psio_grid]\n    psi_t = self.psio_grid\n    for ii in range(1, len(self.tlist)):\n        psi_t_position_grid = PE_prop * psi_t\n        psi_t_momentum_grid = KE_prop * np.fft.fft(psi_t_position_grid, norm=\"ortho\")\n        psi_t = PE_prop * np.fft.ifft(psi_t_momentum_grid, norm=\"ortho\")\n        propagated_states.append(psi_t)\n\n    self.dynamics_results_grid = np.asarray(propagated_states)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.propagate_qt","title":"<code>propagate_qt(solver_options=None)</code>","text":"<p>Function used to propagate with qutip.</p> <p>Parameters:</p> Name Type Description Default <code>solver_options</code> <code>dict</code> <p>A dictionary of arguments to pass to the qutip.sesolve function</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dynamics_results</code> <code>array - like</code> <p>array containing the propagated state</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def propagate_qt(self, solver_options : dict = None):\n    \"\"\"\n    Function used to propagate with qutip.\n\n    Args:\n        solver_options (dict): A dictionary of arguments to pass to the qutip.sesolve function\n\n    Returns:\n        dynamics_results (array-like): array containing the propagated state\n\n    \"\"\"\n\n    options = {'nsteps': len(self.tlist),\n                'progress_bar': True}\n\n    if solver_options:\n        for key in solver_options:\n            options[key] = solver_options[key]\n\n    results = qt.sesolve(self.H_op, self.psio_op, self.tlist,\n                         options=options)\n\n    self.dynamics_results_op = results\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_H_grid_with_custom_potential","title":"<code>set_H_grid_with_custom_potential(custom_function, **kwargs)</code>","text":"<p>Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.</p> <p>Parameters:</p> Name Type Description Default <code>custom_function</code> <code>Callable</code> <p>Function that defines the custom potential energy. Must return an array</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_H_grid_with_custom_potential(self, custom_function: Callable, **kwargs):\n    \"\"\"\n    Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n    Args:\n        custom_function (Callable): Function that defines the custom potential\n            energy. Must return an array\n\n    \"\"\"\n    potential = custom_function(**kwargs)\n    self._PE_grid = potential\n    self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n    self.H_grid = self._PE_grid + self._KE_grid\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_H_op_with_custom_potential","title":"<code>set_H_op_with_custom_potential(custom_function, **kwargs)</code>","text":"<p>Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.</p> <p>Parameters:</p> Name Type Description Default <code>custom_function</code> <code>Callable</code> <p>Function that defines the potential energy in terms of qutip QObj operators. Must return a qutip.Qobj</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_H_op_with_custom_potential(self, custom_function: Callable, **kwargs):\n    \"\"\"\n    Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n    Args:\n        custom_function (Callable): Function that defines the potential\n            energy in terms of qutip QObj operators. Must return a qutip.Qobj\n    \"\"\"\n    potential = custom_function(**kwargs)\n    self._PE_op = potential\n    self._KE_op = self.p_op ** 2 / (2. * self.mass)\n    self.H_op = self._PE_op + self._KE_op\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_coordinate_operators","title":"<code>set_coordinate_operators(x_min=-7.0, x_max=7.0, reorder_p=True)</code>","text":"<p>Populate the <code>self.x_grid</code>, <code>self.p_grid</code>, <code>self.dx</code>, and <code>self.dp</code> attributes. This functions generates an array of <code>self.n_basis</code> evenly spaced values.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <p>float Minimum value of x-coordinates</p> <code>-7.0</code> <code>x_max</code> <p>float Maximum value of x-coordinates</p> <code>7.0</code> <code>reorder_p</code> <p>bool Boolean flag to determine whether momentum values should be reordered to be compatible with the FFT routine or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>self.dx : float Spacing between points in the x-coordinate grid.</p> <code>None</code> <p>self.xgrid : array_like Array of x-values</p> <code>None</code> <p>self.dp : float Spacing between points in the p-coordinate grid.</p> <code>None</code> <p>self.pgrid : array_like Array of p-values</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_coordinate_operators(self, x_min: float = -7., x_max: float = 7., reorder_p: bool = True) -&gt; None:\n    \"\"\"\n    Populate the `self.x_grid`, `self.p_grid`, `self.dx`, and `self.dp`\n    attributes. This functions generates an array of `self.n_basis`\n    evenly spaced values.\n\n    Args:\n        x_min : float\n            Minimum value of x-coordinates\n        x_max : float\n            Maximum value of x-coordinates\n        reorder_p : bool\n            Boolean flag to determine whether momentum values should be\n            reordered to be compatible with the FFT routine or not.\n\n    Returns:\n        self.dx : float\n            Spacing between points in the x-coordinate grid.\n        self.xgrid : array_like\n            Array of x-values\n        self.dp : float\n            Spacing between points in the p-coordinate grid.\n        self.pgrid : array_like\n            Array of p-values\n    \"\"\"\n    self._get_xgrid(x_min, x_max)\n    self._get_pgrid(x_min, x_max, reorder=reorder_p)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_hamiltonian","title":"<code>set_hamiltonian(potential_type='harmonic', **kwargs)</code>","text":"<p>Function to define Hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>potential_type</code> <p>str String defining the type of potential energy surface. Available options are: ('harmonic', 'quartic', ...)</p> <p>Note: You can manually define your potential energy using the functions:     - set_H_grid_with_custom_potential     - set_H_op_with_custom_potential</p> <code>'harmonic'</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_hamiltonian(self, potential_type: str = 'harmonic', **kwargs):\n    \"\"\"\n    Function to define Hamiltonian.\n\n    Args:\n        potential_type : str\n            String defining the type of potential energy surface.\n            Available options are: ('harmonic', 'quartic', ...)\n\n            Note: You can manually define your potential energy using the functions:\n                - set_H_grid_with_custom_potential\n                - set_H_op_with_custom_potential\n\n    \"\"\"\n\n    if potential_type == 'harmonic':\n        self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n        self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n    elif potential_type == 'quartic':\n        self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n        self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n    else:\n        print('Error, this potential type has not yet been implemented!')\n        print('Set your parameters with the custom functions!')\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_initial_state","title":"<code>set_initial_state(wfn_omega=1.0)</code>","text":"<p>Function to define the initial state. By default, a coherent state is used as the initial state defined in the basis chosen upon instantiation</p> <p>Parameters:</p> Name Type Description Default <code>wfn_omega</code> <code>float</code> <p>Defines the frequency/width of the initial state. Default is 1.0 au.</p> <code>1.0</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_initial_state(self, wfn_omega: float = 1.0):\n    \"\"\"\n    Function to define the initial state. By default, a coherent state is\n    used as the initial state defined in the basis chosen upon instantiation\n\n    Args:\n        wfn_omega (float, optional): Defines the frequency/width of the initial state.\n            Default is 1.0 au.\n    \"\"\"\n\n    alpha_val = (self.xo + 1j * self.po) / np.sqrt(2)\n    psio = qt.coherent(self.n_basis, alpha=alpha_val)\n    # Now populate the initial state in the grid basis\n    normalization = (self.mass * wfn_omega / np.pi / self.hbar) ** (0.25)\n    exponential = np.exp(-1 * (self.mass * wfn_omega / self.hbar / 2) *\n                         ((self.x_grid - self.xo) ** 2)\n                         + 1j * self.po * self.x_grid / self.hbar\n                         )\n\n    coherent_state = normalization * exponential\n    # Set the attributes\n    self.psio_grid = coherent_state\n    self.psio_op = psio\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.DynamicsCS.set_propagation_time","title":"<code>set_propagation_time(total_time, n_tsteps)</code>","text":"<p>Function to define the propagation time, an array of times from t=0 to total_time, with n_tsteps equally-spaced steps.</p> <p>total_time : float     The total time for which we wish to compute the dynamics. n_tsteps : int     The number of equally-spaced time steps used to compute the dynamics</p> <p>Returns: self.tlist : array-like</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_propagation_time(self, total_time: float, n_tsteps: int):\n    \"\"\"\n    Function to define the propagation time, an array of times from\n    t=0 to total_time, with n_tsteps equally-spaced steps.\n\n    Args:\n    total_time : float\n        The total time for which we wish to compute the dynamics.\n    n_tsteps : int\n        The number of equally-spaced time steps used to compute the dynamics\n\n    Returns:\n    self.tlist : array-like\n\n    \"\"\"\n\n    self.tlist = np.linspace(0., total_time, n_tsteps+1)\n    self.dt = self.tlist[1] - self.tlist[0]\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.QubitDynamicsCS","title":"<code>QubitDynamicsCS</code>","text":"<p>               Bases: <code>DynamicsCS</code></p> <p>Class to extend <code>DynamicsCS</code> by adding qubit-based methods for dynamics.</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>class QubitDynamicsCS(DynamicsCS):\n    \"\"\"\n    Class to extend `DynamicsCS` by adding qubit-based methods for dynamics.\n\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.n_qubits        = int(np.log2(self.n_basis))\n        self.quantum_circuit = None\n\n\n    def _create_QSOFT_Circuit(self, psio: npt.ArrayLike=None):\n        \"\"\"\n        Function to construct the QSOFT Circuit.\n\n        Args:\n            psio (npt.ArrayLike): initial state that we wish to propagate\n        \"\"\"\n        tgrid = self.tlist\n        time_step = self.dt\n        n_qubits = self.n_qubits\n        # Qubit-Basis Propagators\n        self.prop_PE_qubit = np.diag(np.exp(-1j*self._PE_grid/2*time_step))\n        self.prop_KE_qubit = np.diag(np.exp(-1j*self._KE_grid*time_step))\n\n        q_reg = QuantumRegister(n_qubits)\n        c_reg = ClassicalRegister(n_qubits)\n        qc = QuantumCircuit(q_reg)\n        if type(psio) == type(None):\n            qc.initialize(self._psio_grid, q_reg[:], normalize=True)\n        else:\n            qc.initialize(psio, q_reg[:], normalize=True)\n        # Define our PE and KE propagators in Qiskit-friendly manner\n        PE_cirq_op = Operator(self.prop_PE_qubit)\n        KE_cirq_op = Operator(self.prop_KE_qubit)\n        qc.append(PE_cirq_op, q_reg)\n        qc.append(QFT(self.n_qubits, do_swaps=True, inverse=False), q_reg)\n        qc.append(KE_cirq_op, q_reg)\n        qc.append(QFT(self.n_qubits, do_swaps=True, inverse=True), q_reg)\n        qc.append(PE_cirq_op, q_reg)\n        self.quantum_circuit = qc\n        return(qc)\n\n\n    def _execute_circuit(self, QCircuit: QuantumCircuit, backend=None, shots: int = None, real_backend: bool = False):\n        \"\"\"\n            Function to replace the now-deprecated Qiskit\n            `QuantumCircuit.execute()` method.\n\n            Args:\n                QCircuit (qiskit.QuantumCircuit): qiskit.QuantumCircuit object\n                backend (qiskit.Backend): qiskit backend instance\n                shots (int): the number of shots to use for circuit sampling\n\n            Returns:\n                job: an executed quantum circuit job\n        \"\"\"\n        if shots:\n            n_shots = shots\n        else:\n            n_shots = 1024 # Use the qiskit default if not specified\n        backend_type = type(backend)\n        sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n        if backend_type == sv_type:\n            real_backend = False\n        else:\n            real_backend = True\n\n        if real_backend:\n            QCircuit.measure_all()\n            qc = transpile(QCircuit, backend=backend)\n            sampler = Sampler(backend)\n            job = sampler.run([qc], shots=n_shots)\n        else:\n            # Transpile circuit with statevector backend\n            tmp_circuit = transpile(QCircuit, backend)\n            # Run the transpiled circuit\n            job = backend.run(tmp_circuit, n_shots=shots)\n        return(job)\n\n\n    def propagate_qSOFT(self, backend=None, n_shots: int = 1024):\n        \"\"\"Function to propagate dynamics object with the qubit SOFT method.\n\n            Args:\n                backend (qiskit.Backend): qiskit backend object\n                n_shots (int): specifies the number of shots to use when\n                    executing the circuit\n\n            Example for using the Statevector Simulator backend:\n                &gt;&gt;&gt; from qiskit_aer import Aer\n                &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n                &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n        \"\"\"\n        if backend is None:\n            print('A valid backend must be provided ')\n        backend_type = type(backend)\n        sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n        if backend_type != sv_type:\n            self._propagate_qSOFT_real(backend=backend, n_shots=n_shots)\n            return\n        else:\n\n            psi_in = self.psio_grid\n            # Get initial state from qiskit routine\n            q_reg = QuantumRegister(self.n_qubits)\n            c_reg = ClassicalRegister(self.n_qubits)\n            qc = QuantumCircuit(q_reg, c_reg)\n            qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n            qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n            psio_cirq = qc_result.result().get_statevector().data\n            psi_in = psio_cirq\n            # Now do propagation loop\n            qubit_dynamics_results = [psio_cirq]\n            for ii in trange(1, len(self.tlist)):\n                circuit = self._create_QSOFT_Circuit(psio=psi_in)\n                executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n                psi_out = executed_circuit.result().get_statevector().data\n                qubit_dynamics_results.append(psi_out)\n                psi_in = psi_out\n\n            self.dynamics_results_qSOFT = np.asarray(qubit_dynamics_results)\n            return\n\n\n    def get_statevector_from_counts(self, counts, n_shots):\n        new_statevector = np.zeros_like(self.psio_grid)\n\n        for key in counts:\n            little_endian_int = int(key, 2)\n            new_statevector[little_endian_int] = counts[key]/n_shots\n        return(new_statevector)\n\n\n    def _propagate_qSOFT_real(self, backend='statevector_simulator', n_shots=1024):\n        \"\"\"\n            Function to propagate dynamics object with the qubit SOFT method.\n\n            Args:\n                backend (qiskit.Backend): qiskit backend object\n                n_shots (int): specifies the number of shots to use when\n                    executing the circuit\n\n            Example for using the Statevector Simulator backend:\n                &gt;&gt;&gt; from qiskit_aer import Aer\n                &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n                &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n        \"\"\"\n\n\n        psi_in = self.psio_grid\n        # Get initial state from qiskit routine\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits, name='c')\n        qc = QuantumCircuit(q_reg, c_reg)\n        qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n        # Now do propagation loop\n        qubit_dynamics_results = []\n        for ii in trange(len(self.tlist)):\n            circuit = self._create_QSOFT_Circuit(psio=psi_in)\n            executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n            circuit_result = executed_circuit.result()\n            measured_psi = circuit_result[0].data['meas'].get_counts()\n            self._last_measurement = measured_psi\n            psi_out = self.get_statevector_from_counts(measured_psi, n_shots)\n            psi_in = psi_out\n            qubit_dynamics_results.append(psi_out)\n            psi_in = psi_out\n\n        self.dynamics_results_qSOFT = np.asarray(qubit_dynamics_results)\n        return\n\n\n    def _construct_pauli_gate(self):\n        '''\n        Function to construct a pauli evolution gate from Hamiltonian\n        '''\n        decomposed_H = decompose(self.H_op.full())\n        H_pauli_sum  = pauli_strings_2_pauli_sum(decomposed_H)\n        prop_pauli_H = PauliEvolutionGate(operator=H_pauli_sum, time=self.dt)\n        self.pauli_prop = prop_pauli_H\n        return\n\n\n    def _construct_pauli_cirq(self, psio=None):\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits)\n        qc = QuantumCircuit(q_reg, c_reg)\n\n        qc.initialize(psio, q_reg[:], normalize=True)\n        qc.append(self.pauli_prop, q_reg)\n        self.quantum_circuit = qc\n        return(qc)\n\n\n    def propagate_qmatvec(self, backend=None, n_shots: int = 1024):\n        \"\"\"\n            Function to propagate dynamics object with the qubit matvec method.\n\n            Args:\n                backend (qiskit.Backend): qiskit backend object\n                n_shots (int): specifies the number of shots to use when\n                    executing the circuit\n\n            Example for using the Statevector Simulator backend:\n                &gt;&gt;&gt; from qiskit_aer import Aer\n                &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n                &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n        \"\"\"\n        # Create the Pauli propagator:\n        self._construct_pauli_gate()\n\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits)\n        qc = QuantumCircuit(q_reg, c_reg)\n        # Initialize state:\n        qc.initialize(self.psio_op.full().flatten(), q_reg[:], normalize=True)\n        qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n        psio_cirq = qc_result.result().get_statevector().data\n        psi_in = psio_cirq\n\n        new_qubit_dynamics_result = [psio_cirq]\n\n        for ii in trange(1, len(self.tlist)):\n            circuit = self._construct_pauli_cirq(psio=psi_in)\n            executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n            psi_out = executed_circuit.result().get_statevector().data\n            new_qubit_dynamics_result.append(psi_out)\n            psi_in = psi_out\n        self.dynamics_results_qubit = np.asarray(new_qubit_dynamics_result)\n        return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.QubitDynamicsCS._construct_pauli_gate","title":"<code>_construct_pauli_gate()</code>","text":"<p>Function to construct a pauli evolution gate from Hamiltonian</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def _construct_pauli_gate(self):\n    '''\n    Function to construct a pauli evolution gate from Hamiltonian\n    '''\n    decomposed_H = decompose(self.H_op.full())\n    H_pauli_sum  = pauli_strings_2_pauli_sum(decomposed_H)\n    prop_pauli_H = PauliEvolutionGate(operator=H_pauli_sum, time=self.dt)\n    self.pauli_prop = prop_pauli_H\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.QubitDynamicsCS._create_QSOFT_Circuit","title":"<code>_create_QSOFT_Circuit(psio=None)</code>","text":"<p>Function to construct the QSOFT Circuit.</p> <p>Parameters:</p> Name Type Description Default <code>psio</code> <code>ArrayLike</code> <p>initial state that we wish to propagate</p> <code>None</code> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def _create_QSOFT_Circuit(self, psio: npt.ArrayLike=None):\n    \"\"\"\n    Function to construct the QSOFT Circuit.\n\n    Args:\n        psio (npt.ArrayLike): initial state that we wish to propagate\n    \"\"\"\n    tgrid = self.tlist\n    time_step = self.dt\n    n_qubits = self.n_qubits\n    # Qubit-Basis Propagators\n    self.prop_PE_qubit = np.diag(np.exp(-1j*self._PE_grid/2*time_step))\n    self.prop_KE_qubit = np.diag(np.exp(-1j*self._KE_grid*time_step))\n\n    q_reg = QuantumRegister(n_qubits)\n    c_reg = ClassicalRegister(n_qubits)\n    qc = QuantumCircuit(q_reg)\n    if type(psio) == type(None):\n        qc.initialize(self._psio_grid, q_reg[:], normalize=True)\n    else:\n        qc.initialize(psio, q_reg[:], normalize=True)\n    # Define our PE and KE propagators in Qiskit-friendly manner\n    PE_cirq_op = Operator(self.prop_PE_qubit)\n    KE_cirq_op = Operator(self.prop_KE_qubit)\n    qc.append(PE_cirq_op, q_reg)\n    qc.append(QFT(self.n_qubits, do_swaps=True, inverse=False), q_reg)\n    qc.append(KE_cirq_op, q_reg)\n    qc.append(QFT(self.n_qubits, do_swaps=True, inverse=True), q_reg)\n    qc.append(PE_cirq_op, q_reg)\n    self.quantum_circuit = qc\n    return(qc)\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.QubitDynamicsCS._execute_circuit","title":"<code>_execute_circuit(QCircuit, backend=None, shots=None, real_backend=False)</code>","text":"<p>Function to replace the now-deprecated Qiskit <code>QuantumCircuit.execute()</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>QCircuit</code> <code>QuantumCircuit</code> <p>qiskit.QuantumCircuit object</p> required <code>backend</code> <code>Backend</code> <p>qiskit backend instance</p> <code>None</code> <code>shots</code> <code>int</code> <p>the number of shots to use for circuit sampling</p> <code>None</code> <p>Returns:</p> Name Type Description <code>job</code> <p>an executed quantum circuit job</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def _execute_circuit(self, QCircuit: QuantumCircuit, backend=None, shots: int = None, real_backend: bool = False):\n    \"\"\"\n        Function to replace the now-deprecated Qiskit\n        `QuantumCircuit.execute()` method.\n\n        Args:\n            QCircuit (qiskit.QuantumCircuit): qiskit.QuantumCircuit object\n            backend (qiskit.Backend): qiskit backend instance\n            shots (int): the number of shots to use for circuit sampling\n\n        Returns:\n            job: an executed quantum circuit job\n    \"\"\"\n    if shots:\n        n_shots = shots\n    else:\n        n_shots = 1024 # Use the qiskit default if not specified\n    backend_type = type(backend)\n    sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n    if backend_type == sv_type:\n        real_backend = False\n    else:\n        real_backend = True\n\n    if real_backend:\n        QCircuit.measure_all()\n        qc = transpile(QCircuit, backend=backend)\n        sampler = Sampler(backend)\n        job = sampler.run([qc], shots=n_shots)\n    else:\n        # Transpile circuit with statevector backend\n        tmp_circuit = transpile(QCircuit, backend)\n        # Run the transpiled circuit\n        job = backend.run(tmp_circuit, n_shots=shots)\n    return(job)\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.QubitDynamicsCS._propagate_qSOFT_real","title":"<code>_propagate_qSOFT_real(backend='statevector_simulator', n_shots=1024)</code>","text":"<p>Function to propagate dynamics object with the qubit SOFT method.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>qiskit backend object</p> <code>'statevector_simulator'</code> <code>n_shots</code> <code>int</code> <p>specifies the number of shots to use when executing the circuit</p> <code>1024</code> Example for using the Statevector Simulator backend <p>from qiskit_aer import Aer backend = Aer.get_backend('statevector_simulator') self.propagate_qSOFT(backend=backend)</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def _propagate_qSOFT_real(self, backend='statevector_simulator', n_shots=1024):\n    \"\"\"\n        Function to propagate dynamics object with the qubit SOFT method.\n\n        Args:\n            backend (qiskit.Backend): qiskit backend object\n            n_shots (int): specifies the number of shots to use when\n                executing the circuit\n\n        Example for using the Statevector Simulator backend:\n            &gt;&gt;&gt; from qiskit_aer import Aer\n            &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n            &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n    \"\"\"\n\n\n    psi_in = self.psio_grid\n    # Get initial state from qiskit routine\n    q_reg = QuantumRegister(self.n_qubits)\n    c_reg = ClassicalRegister(self.n_qubits, name='c')\n    qc = QuantumCircuit(q_reg, c_reg)\n    qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n    # Now do propagation loop\n    qubit_dynamics_results = []\n    for ii in trange(len(self.tlist)):\n        circuit = self._create_QSOFT_Circuit(psio=psi_in)\n        executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n        circuit_result = executed_circuit.result()\n        measured_psi = circuit_result[0].data['meas'].get_counts()\n        self._last_measurement = measured_psi\n        psi_out = self.get_statevector_from_counts(measured_psi, n_shots)\n        psi_in = psi_out\n        qubit_dynamics_results.append(psi_out)\n        psi_in = psi_out\n\n    self.dynamics_results_qSOFT = np.asarray(qubit_dynamics_results)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.QubitDynamicsCS.propagate_qSOFT","title":"<code>propagate_qSOFT(backend=None, n_shots=1024)</code>","text":"<p>Function to propagate dynamics object with the qubit SOFT method.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>qiskit backend object</p> <code>None</code> <code>n_shots</code> <code>int</code> <p>specifies the number of shots to use when executing the circuit</p> <code>1024</code> Example for using the Statevector Simulator backend <p>from qiskit_aer import Aer backend = Aer.get_backend('statevector_simulator') self.propagate_qSOFT(backend=backend)</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def propagate_qSOFT(self, backend=None, n_shots: int = 1024):\n    \"\"\"Function to propagate dynamics object with the qubit SOFT method.\n\n        Args:\n            backend (qiskit.Backend): qiskit backend object\n            n_shots (int): specifies the number of shots to use when\n                executing the circuit\n\n        Example for using the Statevector Simulator backend:\n            &gt;&gt;&gt; from qiskit_aer import Aer\n            &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n            &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n    \"\"\"\n    if backend is None:\n        print('A valid backend must be provided ')\n    backend_type = type(backend)\n    sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n    if backend_type != sv_type:\n        self._propagate_qSOFT_real(backend=backend, n_shots=n_shots)\n        return\n    else:\n\n        psi_in = self.psio_grid\n        # Get initial state from qiskit routine\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits)\n        qc = QuantumCircuit(q_reg, c_reg)\n        qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n        qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n        psio_cirq = qc_result.result().get_statevector().data\n        psi_in = psio_cirq\n        # Now do propagation loop\n        qubit_dynamics_results = [psio_cirq]\n        for ii in trange(1, len(self.tlist)):\n            circuit = self._create_QSOFT_Circuit(psio=psi_in)\n            executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n            psi_out = executed_circuit.result().get_statevector().data\n            qubit_dynamics_results.append(psi_out)\n            psi_in = psi_out\n\n        self.dynamics_results_qSOFT = np.asarray(qubit_dynamics_results)\n        return\n</code></pre>"},{"location":"qflux/Closed_Systems/cs_api/#qflux.closed_systems.QubitDynamicsCS.propagate_qmatvec","title":"<code>propagate_qmatvec(backend=None, n_shots=1024)</code>","text":"<p>Function to propagate dynamics object with the qubit matvec method.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>qiskit backend object</p> <code>None</code> <code>n_shots</code> <code>int</code> <p>specifies the number of shots to use when executing the circuit</p> <code>1024</code> Example for using the Statevector Simulator backend <p>from qiskit_aer import Aer backend = Aer.get_backend('statevector_simulator') self.propagate_qSOFT(backend=backend)</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def propagate_qmatvec(self, backend=None, n_shots: int = 1024):\n    \"\"\"\n        Function to propagate dynamics object with the qubit matvec method.\n\n        Args:\n            backend (qiskit.Backend): qiskit backend object\n            n_shots (int): specifies the number of shots to use when\n                executing the circuit\n\n        Example for using the Statevector Simulator backend:\n            &gt;&gt;&gt; from qiskit_aer import Aer\n            &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n            &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n    \"\"\"\n    # Create the Pauli propagator:\n    self._construct_pauli_gate()\n\n    q_reg = QuantumRegister(self.n_qubits)\n    c_reg = ClassicalRegister(self.n_qubits)\n    qc = QuantumCircuit(q_reg, c_reg)\n    # Initialize state:\n    qc.initialize(self.psio_op.full().flatten(), q_reg[:], normalize=True)\n    qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n    psio_cirq = qc_result.result().get_statevector().data\n    psi_in = psio_cirq\n\n    new_qubit_dynamics_result = [psio_cirq]\n\n    for ii in trange(1, len(self.tlist)):\n        circuit = self._construct_pauli_cirq(psio=psi_in)\n        executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n        psi_out = executed_circuit.result().get_statevector().data\n        new_qubit_dynamics_result.append(psi_out)\n        psi_in = psi_out\n    self.dynamics_results_qubit = np.asarray(new_qubit_dynamics_result)\n    return\n</code></pre>"},{"location":"qflux/Closed_Systems/qho_example/","title":"Your first simulation: The Quantum Harmonic Oscillator","text":"<p>In this guided tutorial, we will look at the closed-system quantum dynamics of a coherent state in a harmonic potential as implemented with <code>qflux</code>.</p> <p>We will first show how to compute the dynamics in the qubit-basis, illustrating the approach for running a quantum dynamics simulation on a qubit-based quantum device. Then, we will look at two classical implementations for computing the dynamics, as a means of validating our results.</p>"},{"location":"qflux/Closed_Systems/qho_example/#propagation-in-the-qubit-basis","title":"Propagation in the Qubit Basis","text":"<p>We begin by importing the necessary utilities from <code>qflux</code>:</p> <pre><code>import sys\n# Clone the qflux github repo to your local environment (laptop/Google Colab/etc.)\n# Then set the following line to your local copy of qflux:\nqflux_path = \"{/path/to/downloaded/repo}/qflux/src/\"\nsys.path.append(qflux_path)\nfrom qflux.closed_systems import DynamicsCS, QubitDynamicsCS\n</code></pre> <p>Now, we can instantiate our QubitDynamics object:</p> <pre><code>HO_dyn_obj = QubitDynamicsCS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)\n</code></pre> <p>Now that we have our dynamics object, we must define our discretized coordinate space and initialize our coordinate operators:</p> <pre><code>HO_dyn_obj.set_coordinate_operators(x_min=-7.0, x_max=7.0, reorder_p=True)\nHO_dyn_obj.initialize_operators()\n</code></pre> <p>Now that we've defined a grid for our simulation, we can construct our initial coherent state:</p> <pre><code>HO_dyn_obj.set_initial_state(wfn_omega=1.0)\n</code></pre> <p>And we can define our harmonic oscillator hamiltonian (built-in to <code>qflux</code>):</p> <pre><code>HO_dyn_obj.set_hamiltonian(potential_type='harmonic')\n</code></pre> <p>Now that we have defined our system parameters and initial state, we should define a propagation time. In the following, we propagate for a total time of 20.0 a.u., divided evenly into 400 evenly spaced steps.</p> <pre><code>total_time = 20.0\nN_steps    = 400\nHO_dyn_obj.set_propagation_time(total_time, N_steps)\n</code></pre> <p>Now we are ready to propagate!</p>"},{"location":"qflux/Closed_Systems/qho_example/#propagation-with-statevector-simulator","title":"Propagation with Statevector Simulator","text":"<p>Here we demonstrate how to compute the dynamics according to the qubit-SOFT method with <code>qiskit</code>'s <code>statevector_simulator</code> backend:</p> <pre><code># Now we must set the backend prior to calling propagate qSOFT\nfrom qiskit_aer import Aer\nbackend = Aer.get_backend('statevector_simulator')\nHO_dyn_obj.propagate_qSOFT(backend=backend, n_shots=1024)\n</code></pre> <p>Note: the <code>propagate_qSOFT</code> method does the following things under the hood: - Construction of the quantum circuit - Arbitrary state initialization from our grid-based coherent state - Conversion of the unitary operators from the SOFT method (see the section below for details) into Pauli gates - Application of the Quantum Fourier Transform and inverse Quantum Fourier Transform for conversion between position and momentum space - Collection of the state at each time-step of the dynamics</p>"},{"location":"qflux/Closed_Systems/qho_example/#analyzing-the-results","title":"Analyzing the Results","text":"<p>The first thing we can do is to check the state initialization in the quantum circuit formalism. To do this, we can plot initial state in the qubit basis and compare to the state in the coordinate basis:</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.figure()\nplt.plot(HO_dyn_obj.x_grid, HO_dyn_obj._PE_grid)\nplt.plot(HO_dyn_obj.x_grid,\n         np.real(HO_dyn_obj.psio_grid.conj() * HO_dyn_obj.psio_grid),\n         color='k', label=r'$\\left| \\psi_{0} \\right|^{2}$ (Grid)')\nplt.plot(HO_dyn_obj.x_grid,\n         np.real(HO_dyn_obj.dynamics_results_qubit[0].conj() *\n                 HO_dyn_obj.dynamics_results_qubit[0].conj())/HO_dyn_obj.dx,\n         marker='x', lw=0, markevery=2, label=r'$\\left| \\psi_{0} \\right|^{2}$ (Qubit)')\nplt.ylim(-.05, 1.0)\nplt.legend()\nplt.xlim(-3.5, 3.5)\nplt.xlabel(r'$x$')\nplt.tight_layout()\n</code></pre> <p></p> <p>To compare the dynamics, we can calculate and plot the expectation value over time for the qSOFT and SOFT results with the analytical expressions:</p> <pre><code>import numpy as np\nfrom qflux.closed_systems.utils import calculate_expectation_values\n\nqubit_exp_x_soft = calculate_expectation_values(HO_dyn_obj.dynamics_results_qubit, HO_dyn_obj.x_grid, dx=1)\ngrid_exp_x_soft = calculate_expectation_values(HO_dyn_obj.dynamics_results_grid, HO_dyn_obj.x_grid)\n\nqubit_exp_p_soft = calculate_expectation_values(HO_dyn_obj.dynamics_results_qubit, HO_dyn_obj.p_grid, dx=1., do_FFT=True)\ngrid_exp_p_soft = calculate_expectation_values(HO_dyn_obj.dynamics_results_grid, HO_dyn_obj.p_grid, dx=HO_dyn_obj.dx, do_FFT=True)\n\nexp_x_ana = HO_dyn_obj.xo*np.cos(HO_dyn_obj.omega*HO_dyn_obj.tlist) + (HO_dyn_obj.po/HO_dyn_obj.mass/HO_dyn_obj.omega)*np.sin(HO_dyn_obj.omega*HO_dyn_obj.tlist)\nexp_p_ana = HO_dyn_obj.po*np.cos(HO_dyn_obj.omega*HO_dyn_obj.tlist) - HO_dyn_obj.xo*HO_dyn_obj.omega*HO_dyn_obj.mass*np.sin(HO_dyn_obj.omega*HO_dyn_obj.tlist)\n\n# Plot expectation value, compare to analytic expression\nplt.figure(figsize=(9, 6.5))\nplt.plot(HO_dyn_obj.tlist, grid_exp_x_soft, label=r'$\\left\\langle x \\right\\rangle$ (SOFT)', color='dodgerblue')\nplt.plot(HO_dyn_obj.tlist, qubit_exp_x_soft, label=r'$\\left\\langle x \\right\\rangle$ (qSOFT)',\n         lw=0, marker='x', markevery=10, color='dodgerblue', ms=8, zorder=1)\nplt.plot(HO_dyn_obj.tlist, exp_x_ana, label=r'$\\left\\langle x \\right\\rangle$ (Analytic)',\n         lw=0, marker='o', markevery=10, color='dodgerblue', ms=8, fillstyle='none')\nplt.plot(HO_dyn_obj.tlist, grid_exp_p_soft, label=r'$\\left\\langle p \\right\\rangle$ (SOFT)', color='crimson')\nplt.plot(HO_dyn_obj.tlist, qubit_exp_p_soft, label=r'$\\left\\langle p \\right\\rangle$ (qSOFT)',\n         lw=0, marker='x', markevery=10, color='crimson', ms=8, zorder=1)\nplt.plot(HO_dyn_obj.tlist, exp_p_ana, label=r'$\\left\\langle p \\right\\rangle$ (Analytic)',\n         lw=0, marker='o', markevery=10, color='crimson', ms=8, fillstyle='none')\nplt.ylim(-1.55, 1.55)\n\nplt.legend(ncols=2, loc='upper center', fontsize=14)\nplt.hlines([-1, 0, 1], min(HO_dyn_obj.tlist), max(HO_dyn_obj.tlist), ls='--', lw=0.85, color='tab:grey', zorder=2)\nplt.xlim(min(HO_dyn_obj.tlist), max(HO_dyn_obj.tlist))\nplt.ylabel('Expectation Value')\nplt.xlabel('Time')\nplt.tight_layout()\n</code></pre> <p></p>"},{"location":"qflux/Closed_Systems/qho_example/#propagation-with-a-real-backend","title":"Propagation with a Real Backend","text":"<p>You can repeat the previous section and run on a real quantum device by changing the specification of the backend! Recall that we instantiated a StatevectorSimulator backend before running the dynamics calculation above. To run on a real device, we must first instantiate a backend instance using a real device. This can be done with the following code:</p> <pre><code># To use a real backend:\nfrom qiskit_ibm_runtime import QiskitRuntimeService, fake_provider\n# # If you did not previously save your credentials, use the following line:\nMY_API_TOKEN = \"INSERT_IBMQ_API_TOKEN_HERE\"\nservice = QiskitRuntimeService(channel=\"ibm_quantum\", token=MY_API_TOKEN, instance='ibm-q/open/main')\n# Save your credentials:\nservice.save_account(name='b-ibmq', token=MY_API_TOKEN, channel='ibm_quantum', overwrite=True)\nbackend = service.least_busy(simulator=False, operational=True)\n</code></pre> <p>Now, we can run the following code to do the dynamics calculation with <code>qflux</code>:</p> <pre><code>HO_dyn_obj = QubitDynamicsCS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)\nHO_dyn_obj.set_coordinate_operators(x_min=-7.0, x_max=7.0, reorder_p=True)\nHO_dyn_obj.initialize_operators()\nHO_dyn_obj.set_initial_state(wfn_omega=1.0)\n\nHO_dyn_obj.set_hamiltonian(potential_type='harmonic')\n\ntotal_time = 20.0\nN_steps    = 400\nHO_dyn_obj.set_propagation_time(total_time, N_steps)\nHO_dyn_obj.propagate_qt()\nHO_dyn_obj.propagate_SOFT()\nHO_dyn_obj.propagate_qSOFT(backend=backend, n_shots=1024)\n</code></pre>"},{"location":"qflux/Closed_Systems/qho_example/#propagation-in-the-ladder-basis","title":"Propagation in the Ladder Basis","text":"<p>We'll now show how to validate the dynamics we calculated in the previous section with classical simulations.</p> <p>When we run dynamics, we must do the following:</p> <ol> <li> <p>Define the initial state \\(\\left| \\alpha \\right\\rangle\\). In this example, our initial state is defined as a coherent state with amplitude \\(\\alpha = x_{0} + i p_{0}\\), which can be expressed in the Fock Basis as:</p> \\[ \\left| \\alpha \\right\\rangle = \\frac{\\alpha^{n}}{\\sqrt{n!}} e^{-\\frac{1}{2}\\left| \\alpha \\right|^{2}} \\left| n \\right\\rangle \\] </li> <li> <p>Define the Hamiltonian \\(H\\). In this example, our Hamiltonian is the familiar quantum harmonic oscillator Hamiltonian, defined in terms of creation and annihilation operators as:</p> \\[ H =  \\hbar \\omega \\left( \\hat{a}^{\\dagger} \\hat{a} + \\frac{1}{2} \\right) \\] </li> <li> <p>Define the propagation time step \\(t\\) and the number of time steps \\(n\\) for which to compute the wavefunction.</p> </li> <li> <p>Compute the time-evolved wavefunction at each step as:</p> \\[ \\left| \\alpha (t_{i+1}) \\right\\rangle = e^{-\\frac{i}{\\hbar} H t} \\left| \\alpha(t_{i}) \\right\\rangle \\] </li> </ol> <p>All this can be done using QFlux as follows:</p> <pre><code># Import the package and relevant modules\nimport qflux\nfrom qflux.closed_systems import DynamicsCS\n# Instantiate our Closed-Systems Dynamics Class\nqho_dyn_obj = DynamicsCS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)\n# Define our coordinate x and p operators\nqho_dyn_obj.set_coordinate_operators()\n# Initialize the ladder operators\nqho_dyn_obj.initialize_operators()\n# Define the default initial state (note that custom initialization is also supported)\nqho_dyn_obj.set_initial_state()\n# Define some parameters for the time evolution\ntotal_time = 20.0\nN_steps = 400\nqho_dyn_obj.set_propagation_time(total_time, N_steps)\n# Set the Potential/Hamiltonian for our object, in this case using the pre-defined 'harmonic' oscillator potential\nqho_dyn_obj.set_hamiltonian(potential_type='harmonic')\n# Propagate using the QuTiP sesolve method\nqho_dyn_obj.propagate_qt()\n</code></pre> <p>We can validate our result by computing and plotting the expectation values of \\(x\\) and \\(p\\) as a function of time and comparing to the analytic results:</p> <pre><code>import qutip as qt\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Compute expectation values &lt;x&gt; and &lt;p&gt;\nexp_x_qt = qt.expect(qho_dyn_obj.x_op, qho_dyn_obj.dynamics_results_op.states)\nexp_p_qt = qt.expect(qho_dyn_obj.p_op, qho_dyn_obj.dynamics_results_op.states)\n\nexp_x_ana = [ qho_dyn_obj.xo*np.cos(qho_dyn_obj.omega*t) + (qho_dyn_obj.po/qho_dyn_obj.mass/qho_dyn_obj.omega)*np.sin(qho_dyn_obj.omega*t) for t in qho_dyn_obj.tlist]\nexp_p_ana = [ qho_dyn_obj.po*np.cos(qho_dyn_obj.omega*t) -qho_dyn_obj.xo*qho_dyn_obj.omega*qho_dyn_obj.mass*np.sin(qho_dyn_obj.omega*t)  for t in qho_dyn_obj.tlist]\n\n# Plot the final result\nplt.figure(figsize=(9, 6.5))\nplt.plot(qho_dyn_obj.tlist, exp_x_qt, label=r'$\\left\\langle x \\right\\rangle$ (QuTiP)', color='dodgerblue')\nplt.plot(qho_dyn_obj.tlist, exp_x_ana, label=r'$\\left\\langle x \\right\\rangle$ (Analytic)',\n         lw=0, marker='x', markevery=10, color='dodgerblue', ms=8)\nplt.plot(qho_dyn_obj.tlist, exp_p_qt, label=r'$\\left\\langle p \\right\\rangle$ (QuTiP)', color='crimson')\nplt.plot(qho_dyn_obj.tlist, exp_p_ana, label=r'$\\left\\langle p \\right\\rangle$ (Analytic)',\n         lw=0, marker='x', markevery=10, color='crimson', ms=8)\n\nplt.ylim(-1.55, 1.55)\n\nplt.legend(ncols=2, loc='upper center')\nplt.hlines([-1, 0, 1], min(qho_dyn_obj.tlist), max(qho_dyn_obj.tlist), ls='--', lw=0.85, color='tab:grey', zorder=2)\n</code></pre> <p></p> <p>Hopefully the agreement in this plot convinces you that we're doing something correct!</p>"},{"location":"qflux/Closed_Systems/qho_example/#propagation-in-the-coordinate-basis","title":"Propagation in the Coordinate Basis","text":"<p>We can also propagate a wavefunction in a coordinate-grid representation using the so-called Split-Operator Fourier Transform (SOFT) method.</p> <p>\\(\\renewcommand{\\intertext}[1]{\\\\\\ \\textrm{#1}\\\\}\\)</p> <p>Here, we compute the time-evolution of a wavepacket defined in the position basis (\\(\\psi(x)\\)) according to the Split-Operator Fourier Transform (SOFT) method. This differs slightly from the approach utilized in the last section in the following ways:</p> <ul> <li>As mentioned above, we will describe the wavefunction in terms of the position. To do this, we must define a closed range of positions \\(x\\) and momenta \\(p\\) and discretize over some finite number of points (analagous to the finite number of Fock states considered above).</li> <li>We will compute the time evolution as:</li> </ul> \\[ \\left| \\psi (t) \\right\\rangle =  e^{- \\frac{i}{\\hbar} {H} t} \\left| \\psi(0) \\right\\rangle \\] <p>Writing \\(H\\) in terms of Kinetic and Potential energy \\(H = T + V\\):</p> \\[\\begin{align*}         \\left| \\psi (t) \\right\\rangle &amp;\\approx \\lim\\limits_{N\\to\\infty} \\left[e^{\\frac{-ip^2t}{2m\\hbar N}}\\ e^{\\frac{-i{V}({x})t}{\\hbar N}}\\right]^N \\space |\\psi(0)\\rangle \\\\                                   &amp;\\approx\\lim\\limits_{N\\to\\infty} \\left[e^{\\frac{-i{V}({x})t}{2\\hbar N}}\\space e^{\\frac{-ip^2t}{2m\\hbar N}}\\space e^{\\frac{-i{V}({x})t}{2\\hbar N}}\\right]^N \\space |\\psi(0)\\rangle     \\intertext{Inserting closure and writing in the plane-wave basis: }      \\left| \\psi (x, t) \\right\\rangle &amp;= \\int d x_0 \\space \\langle x_t | e^{\\frac{-i\u0124t}{\\hbar}} | x_0 \\rangle \\space \\langle x_0 | \\psi(0) \\rangle \\end{align*}\\] <p>Propagation for a single timestep is then:</p> \\[\\psi(x,\\frac{t_{i+1}}{N}) = \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} e^{\\frac{-iV(x)t}{2\\hbar N}} }^\\textrm{P.E. Propagator} \\ \\cdot \\ \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} { \\int \\frac{dp}{\\sqrt{2\\pi\\hbar}}  \\   e^{\\frac{-ipx}{\\hbar}}} }^\\textrm{Inverse Fourier Transform} \\ \\cdot \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} \\ e^{\\frac{-ip^2t}{2m\\hbar N}}}^\\textrm{K.E. Propagator} \\ \\cdot \\ \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} {\\int \\frac{dx}{\\sqrt{2\\pi\\hbar}} \\  e^{\\frac{ipx}{\\hbar}} }}^\\textrm{Fourier Transform} \\ \\cdot \\ \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}}\\ e^{\\frac{-iV(x)t}{2\\hbar N}} }^\\textrm{P.E. Propagator} \\ \\cdot \\ \\psi(x,t_{i})\\] <p>The Fourier and inverse Fourier transforms are used to convert between the position and momentum basis. To translate the formula above, the algorithm will consist of 5 steps per iteration:</p> <ol> <li>Apply a half step of the potential energy propagator to the initial state.</li> <li>Fourier transform into the momentum basis.</li> <li>Apply a full step of the kinetic energy propagator on the momentum basis.</li> <li>Inverse Fourier transform back into the coordinate basis.</li> <li>Apply the second half step of the potential energy propagator.</li> </ol> <p>This is can be done in QFlux with the following code:</p> <pre><code># Instantiate our Closed-Systems Dynamics Class\nqho_dyn_obj = QFlux_CS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)\n# Define our coordinate x and p operators\nqho_dyn_obj.set_coordinate_operators()\n# Initialize the ladder operators\nqho_dyn_obj.initialize_operators()\n# Define the default initial state (note that custom initialization is also supported)\nqho_dyn_obj.set_initial_state()\n# Define some parameters for the time evolution\ntotal_time = 20.0\nN_steps = 400\nqho_dyn_obj.set_propagation_time(total_time, N_steps)\n# Set the Potential/Hamiltonian for our object, in this case using the pre-defined 'harmonic' oscillator potential\nqho_dyn_obj.set_hamiltonian(potential_type='harmonic')\n# Propagate using the QuTiP sesolve method\nqho_dyn_obj.propagate_qt()\n# Propagate with SOFT and QuTiP\nqho_dyn_obj.propagate_SOFT()\n</code></pre>"},{"location":"qflux/Closed_Systems/spinchain/","title":"Simulation of a Spin-Chain System","text":""},{"location":"qflux/Closed_Systems/spinchain/#motivation","title":"Motivation","text":"<p>This section demonstrates the practical considerations for perfoming dynamical evolution of an Hamiltonian written in the basis of Pauli matrices using a qubit-based quantum computer framework. The chosen Hamiltonian can be used to describe the chemical process of electron transfer across a chromophore chain, with the onsite parameters describing the strength of the electronic affinity at each chromophore and off-site couplings describing the barrier for transferring an electron between adjacent sites.</p> <p></p> <p>A problem of practical interest that could be modelled by this method would be a functionalized graphene nanoribbon, where alternating sites contain radical character (Nano Lett. 2022, 22, 1, 164\u2013171).</p> <p></p> <p>The stability of the radical character at each site can be described by the on-site parameter (\\(\\Omega _n\\)) and the coupling between sites (\\(J _{n,n+1}\\)) governed by the properties of the linker regions containing the diketone groups. These parameters can be tuned by synthetic design of each component part of the nanoribbon.</p> \\[\\begin{align} H=  \\sum_{n=0}^{N-1} \\hbar \\Omega _n \\sigma_n ^z - \\dfrac{1}{2} \\sum_{n=0}^{N-2} \\big(J_{n,n+1}^x \\hat{\\sigma}_{n}^x \\hat{\\sigma}_{n+1}^x + J_{n,n+1}^y \\hat{\\sigma}_{n}^y \\hat{\\sigma}_{n+1}^y + J_{n,n+1}^z \\hat{\\sigma}_{n}^z \\hat{\\sigma}_{n+1}^z \\big) \\end{align}\\] <p>Protocol for Hamiltonian evolution in a quantum computer framework:</p> <ol> <li>Construct Hamiltonian operator (sum of tensor product of Pauli matrices)</li> <li>Construct Trotter approximation of time-evolution operator (\\(e^{-i\\hat{H}t}\\))</li> <li>Construct circuit corresponding to time-evolution operator</li> <li>Construct circuit for initial state</li> <li>Combine the initial state and time-evolution circuits</li> <li>Execute combined circuit</li> <li>Measure final state</li> <li>Computing observables with Hadamard test (correlation function and observables)</li> </ol>"},{"location":"qflux/Closed_Systems/spinchain/#model-hamiltonian-and-parameters","title":"Model Hamiltonian and Parameters","text":"<p>Here we use as an example the Hamiltonian for the Heisenberg model, defined as follows:</p> \\[\\begin{align} H=  \\sum_{n=0}^{N-1} \\hbar \\Omega _n \\sigma_n ^z - \\dfrac{1}{2} \\sum_{n=0}^{N-2} \\big(J_{n,n+1}^x \\hat{\\sigma}_{n}^x \\hat{\\sigma}_{n+1}^x + J_{n,n+1}^y \\hat{\\sigma}_{n}^y \\hat{\\sigma}_{n+1}^y + J_{n,n+1}^z \\hat{\\sigma}_{n}^z \\hat{\\sigma}_{n+1}^z \\big) \\end{align}\\] <p>where the coupling elements are described in terms of the \\(\\sigma _x, \\sigma _y, \\sigma _z\\) (Pauli X, Y and Z) matrices with a coupling associated with each type of interaction term for each site/pair of sites. We consider the following parameters, as used in the publication Non-Markovian decay beyond the Fermi Golden Rule: Survival Collapse of the polarization in spin chains.(but with reduced number of spin sites):</p> \\[\\begin{align}     N &amp;= 3 \\\\     \\hbar \\Omega _0 &amp;= 0.65 \\\\     \\hbar \\Omega _n &amp;= 1.0, \\; n &gt; 0 \\\\     J_{0,1}^x = J_{1,0}^y &amp;= 0.75 \\\\     J_{n,n+1}^x = J_{n,n+1}^y &amp;= 1.0, \\; n &gt; 0  \\\\     J_{n,n+1}^z &amp;= 0, \\; \\forall n \\\\ \\end{align}\\] <p>for a chain of \\(N=3\\) spins and an initial state with the first spin up, \\(| \\uparrow \\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\), and the remaining spins down, \\(| \\downarrow \\rangle = \\begin{bmatrix} 0 \\\\ 1\\end{bmatrix}\\). Although the dynamics of this Hamiltonian can be simulated in a classical computer, we could also use quantum computer to simulate this same problem. One way to do so is by harnessing Qiskit, a python library containing functions that ease the simulation of the problem in quantum device framework.</p>"},{"location":"qflux/Closed_Systems/spinchain/#statevector-simulation","title":"Statevector Simulation","text":"<pre><code>from qflux.closed_systems.spin_propagators import * \nfrom qflux.closed_systems.hamiltonians import * \nfrom qflux.closed_systems.spin_dynamics_oo import * \n\nnum_q = 3\nevolution_timestep = 0.1\nn_trotter_steps = 1\nhamiltonian_coefficients = [[0.75 / 2, 0.75 / 2, 0.0, 0.65]] + [[0.5, 0.5, 0.0, 1.0]\n                            for _ in range(num_q - 1)]\ninitial_state = \"011\"  # Specify the initial state as a binary string\n\ncsimulation = SpinDynamicsS(\n                            num_q,\n                            evolution_timestep,\n                            n_trotter_steps,\n                            hamiltonian_coefficients\n                            )\ncsimulation.run_dynamics(nsteps=250, state_string=initial_state)\ncsimulation.save_results(f\"{num_q}_spin_chain\")\ncsimulation.plot_results(f\"{num_q}_spin_chain_statevector\")\n</code></pre>"},{"location":"qflux/Closed_Systems/spinchain/#quantum-circuit-simulation-with-hadamard-test","title":"Quantum Circuit Simulation with Hadamard Test","text":"<pre><code>num_q = 3\nevolution_timestep = 0.1\nn_trotter_steps = 1\nhamiltonian_coefficients = [[0.75 / 2, 0.75 / 2, 0.0, 0.65]] + [[0.5, 0.5, 0.0, 1.0]\n                            for _ in range(num_q - 1)]\ninitial_state = \"011\"  # Specify the initial state as a binary string\n\nqsimulation = SpinDynamicsH(\n                            num_q,\n                            evolution_timestep,\n                            n_trotter_steps,\n                            hamiltonian_coefficients\n                            )\nqsimulation.run_simulation(state_string=initial_state, total_time=25, num_shots=100)\nqsimulation.save_results('hadamard_test')\nqsimulation.plot_results('hadamard_test')\n</code></pre>"},{"location":"qflux/GQME/","title":"Open Systems Documentation and User Guide","text":"<p>This section includes documentation and tutorials focused on illustrating the usage and versatility of the <code>qflux.gqme</code> module. </p>"},{"location":"qflux/GQME/#overview","title":"Overview","text":"<p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/GQME/#examples-and-introductory-concepts","title":"Examples and Introductory Concepts","text":"<p>Before we look at doing Quantum Dynamics on a quantum computer, we'll start out by looking at some ways that we can do quantum dynamics on a classical computer! This is an important step as it will familiarize you with the general ingredients of a quantum dynamics simulation and will also provide us with a means of validating the results obtained from a quantum computer.</p>"},{"location":"qflux/Open_Systems/","title":"Open Systems Documentation and User Guide","text":"<p>This section includes documentation and tutorials focused on illustrating the usage and versatility of the <code>qflux.open_systems</code> module. </p>"},{"location":"qflux/Open_Systems/#overview","title":"Overview","text":"<p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/Open_Systems/#examples-and-introductory-concepts","title":"Examples and Introductory Concepts","text":"<p>Before we look at doing Quantum Dynamics on a quantum computer, we'll start out by looking at some ways that we can do quantum dynamics on a classical computer! This is an important step as it will familiarize you with the general ingredients of a quantum dynamics simulation and will also provide us with a means of validating the results obtained from a quantum computer.</p> <ul> <li>Tutorial</li> <li>API Documentation</li> </ul>"},{"location":"qflux/Open_Systems/open_systems/","title":"Tutorial on quantum algorithm with the Lindblad Master Equation","text":"<p>Here, we provide the code for a general quantum algorithm simulating open quantum dynamics on IBM quantum Aer simulator.</p>"},{"location":"qflux/Open_Systems/open_systems/#the-spin-12-system","title":"The Spin-1/2 system","text":""},{"location":"qflux/Open_Systems/open_systems/#classical-simulation","title":"Classical simulation","text":"<pre><code>import qflux.open_systems.params as pa\nfrom qflux.open_systems.numerical_methods import DynamicsOS\nfrom qflux.open_systems.quantum_simulation import QubitDynamicsOS\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n##===========Classical Simulation\n#============set the Hamiltonian and initial state\n# The Spin-1/2 system Hamiltonian\nHsys = 2 * np.pi * 0.1 * pa.X\n\n# The collapse operator and damping rate of Spin-1/2 system\ngamma = 0.05\nc_ops = np.sqrt(gamma)*pa.X\n\n# Initial density matrix\nrho0 = np.outer(pa.spin_up, pa.spin_up.conj())\n\n# Time array for simulation\ntime_arr = np.linspace(0, (250 - 1) * 0.1, 250)\n\n#=============instantiation\nspin1_puresys = DynamicsOS(Nsys=2, Hsys=Hsys, rho0=rho0)\nspin1_dissipative = DynamicsOS(Nsys=2, Hsys=Hsys, rho0=rho0, c_ops = [c_ops])\n\n#=============propagation\n# QuTiP Propagation for the pure system Liouville equation (for comparison)\nexpec_vals_qutip_Liouv = spin1_puresys.propagate_qt(time_arr=time_arr, observable=pa.Z)\n\n#matrix exponential propagation\nresult_matrix_exp = spin1_dissipative.propagate_matrix_exp(time_arr=time_arr, observable=pa.Z)\n\n# QuTiP Propagation for the Lindblad equation\nexpec_vals_qutip_Lindblad = spin1_dissipative.propagate_qt(time_arr=time_arr, observable=pa.Z)\n</code></pre> <p>We can plot the results to show agreement between matrix-vector multiplication, Lindblad propagation with QuTiP and highlight the difference between those approaches and propagation with the Liouville approach:</p> <pre><code>#==============plot\nplt.figure(figsize=(6,2))\nplt.plot(time_arr, result_matrix_exp.expect,'b-', label = \"Matrix Exponential\")\nplt.plot(time_arr, expec_vals_qutip_Lindblad[0],'ko',markersize=4,markevery=4, label = \"QuTiP_Lindblad\")\nplt.plot(time_arr, expec_vals_qutip_Liouv[0],'r-', label = \"QuTiP_Liouville\")\nplt.xlabel('time',fontsize=15)\nplt.ylabel('&lt;$\\sigma^z$&gt;(t)',fontsize=15)\nplt.legend(loc = 'upper right')\nplt.show()\n</code></pre> <p></p>"},{"location":"qflux/Open_Systems/open_systems/#quantum-simulation-of-the-spin-12-system-amplitude-channel-damping","title":"Quantum Simulation of the Spin-1/2 system: Amplitude-channel damping","text":"<pre><code>##================Quantum Simulation: Amplitude damping channel\n# System Hamiltonian\nHsys = 0.0 * pa.I\n\n# The collapse operator and damping rate\ngamma = 1.52e9*1E-12 # the spontaneous emission rate, ps^-1\nc_ops = np.sqrt(gamma)*pa.sigmap\n\n# Initial density matrix\nrho0_sdam = np.array([[1/4,1/4],[1/4,3/4]],dtype=np.complex128)\n\ntime_sdam = np.arange(0, 1000, 1) #time array, from t=0 to t=1000 ps\n\n#=============instantiation\nspin1_sdam = QubitDynamicsOS(rep='Density', Nsys=2, Hsys=Hsys, rho0=rho0_sdam, c_ops = [c_ops])\n#set qubit state to measurement\nspin1_sdam.set_count_str(['000','011'])\n#set the dilation method, which can be 'Sz-Nagy' or 'SVD' or 'SVD-Walsh'\nspin1_sdam.set_dilation_method('SVD')\n\n#============quantum simulation\nPop_qc = spin1_sdam.qc_simulation_vecdens(time_sdam)\n\n#compare to classical\nres_sdam_classical = spin1_sdam.propagate_matrix_exp(time_sdam, observable=pa.Z, Is_store_state = True)\n\nPop_Mexp = np.zeros_like(Pop_qc)\nfor i in range(len(time_sdam)):\n    Pop_Mexp[i,0] = res_sdam_classical.density_matrix[i][0,0].real\n    Pop_Mexp[i,1] = res_sdam_classical.density_matrix[i][1,1].real\n</code></pre> <p>And plotting the results shows agreement with a benchmarking calculation:</p> <pre><code>#============plot\nplt.figure(figsize=(6,2))\nplt.plot(time_sdam,Pop_qc[:,0],'r-',label=\"quantum,|0&gt;\")\nplt.plot(time_sdam,Pop_Mexp[:,0],'ko',markersize=5,markevery=40,label=\"benchmark,|0&gt;\")\nplt.plot(time_sdam,Pop_qc[:,1],'b-',label=\"quantum,|1&gt;\")\nplt.plot(time_sdam,Pop_Mexp[:,1],'yo',markersize=5,markevery=40,label=\"benchmark,|1&gt;\")\nplt.xlabel('time (ps)',fontsize=15)\nplt.ylabel('$P(t)$',fontsize=15)\nplt.legend(loc = 'upper right')\n</code></pre> <p></p>"},{"location":"qflux/Open_Systems/open_systems/#spin-chain","title":"Spin-Chain","text":""},{"location":"qflux/Open_Systems/open_systems/#set-the-hamiltonian-and-initial-state","title":"Set the Hamiltonian and initial state","text":"<pre><code>#============set the Hamiltonian and initial state\n#the system Hamiltonian parameter\nnsite = 3 #this states how many spins in the simulation\nNsys_sc = 2**nsite #this is the dimension of the Hilbert space\nOmegai_list = [0.65, 1.0, 1.0]\nJix_list = [0.75, 1.0]\nJiy_list = [0.75, 1.0]\nJiz_list = [0.0, 0.0]\n\n#Hamiltonian in pauli string basis\nH_pauli_str = {'ZII':Omegai_list[0], 'IZI':Omegai_list[1], 'IIZ':Omegai_list[2], \\\n               'XXI':-0.5*Jix_list[0], 'IXX':-0.5*Jix_list[1], \\\n               'YYI':-0.5*Jiy_list[0], 'IYY':-0.5*Jiy_list[1], \\\n               'ZZI':-0.5*Jiz_list[0], 'IZZ':-0.5*Jiz_list[1]   }\n\n#system hamiltonian\nHsys = tb.pauli_to_ham(H_pauli_str, 3)\n\n\n#set up the initial state at [up,down,down...]\ninit_state = pa.spin_up\nfor i in range(nsite-1):\n  init_state = np.kron(init_state,pa.spin_down)\n\n#set up the initial density matrix according to initial state\nrho0_sc = np.zeros((Nsys_sc,Nsys_sc),dtype=np.complex128)\nrho0_sc += np.outer(init_state,init_state.conj())\n\n#time array for simulation\ntime_arr = np.linspace(0, (250 - 1) * 0.1, 250)\n\n#============set the collapse operator\nL_sc = []\n#The lindblad damping rate\nGamma1 = [0.016]*nsite\nGamma2 = [0.0523]*nsite\n\nfor isite in range(nsite):\n  #Lindbladian for type 1\n  res = 1.0\n  for j in range(nsite):\n    if(j==isite):\n      res = np.kron(res,pa.sigmam)*np.sqrt(Gamma1[isite])\n    else:\n      res = np.kron(res,pa.I)\n  L_sc.append(res)\n\n  #Lindbladian for type 2\n  res = 1.0\n  for j in range(nsite):\n    if(j==isite):\n      res = np.kron(res,pa.sigmap@pa.sigmam)*np.sqrt(Gamma2[isite])\n    else:\n      res = np.kron(res,pa.I)\n  L_sc.append(res)\n</code></pre>"},{"location":"qflux/Open_Systems/open_systems/#classical-simulation_1","title":"Classical Simulation","text":"<pre><code>##===========Classical Simulation\n#=============instantiation\nspin_chain_puresys =  DynamicsOS(Nsys=Nsys_sc, Hsys=Hsys, rho0=rho0_sc)\nspin_chain_opensys =  DynamicsOS(Nsys=Nsys_sc, Hsys=Hsys, rho0=rho0_sc, c_ops = L_sc)\n\n#=============propagation\n# QuTiP Propagation for the pure system Liouville equation (for comparison)\nresult_qutip_Liouv = spin_chain_puresys.propagate_qt(time_arr=time_arr, observable=rho0_sc)\n\n#matrix exponential propagation\nresult_matrix_exp = spin_chain_opensys.propagate_matrix_exp(time_arr=time_arr, observable=rho0_sc)\n\n# QuTiP Propagation for the Lindblad equation\nresult_qutip_Lindblad = spin_chain_opensys.propagate_qt(time_arr=time_arr, observable=rho0_sc)\n\nAs_matrix_exp = np.sqrt(result_matrix_exp.expect[:])\nAs_qutip = np.sqrt(result_qutip_Lindblad[0][:])\nAs_qutip_liouv = np.sqrt(result_qutip_Liouv[0][:])\n</code></pre> <p>And we can plot the results:</p> <pre><code>#==============plot\nplt.figure(figsize=(6,2))\nplt.plot(time_arr,As_matrix_exp,'b-', label=\"Matrix Exponential\")\nplt.plot(time_arr,As_qutip,'ko',markersize=4,markevery=4,label=\"QuTiP_Lindblad\")\nplt.plot(time_arr,As_qutip_liouv,'r-',label=\"Pure System\")\nplt.xlabel('time',fontsize=15)\nplt.ylabel('$A_s$(t)',fontsize=15)\nplt.legend(loc = 'upper right')\n</code></pre> <p></p>"},{"location":"qflux/Open_Systems/open_systems/#quantum-simulation","title":"Quantum Simulation","text":"<pre><code>##===========Quantum Simulation\nqspin_chain = QubitDynamicsOS(rep='Density',Nsys=Nsys_sc, Hsys=Hsys, rho0=rho0_sc, c_ops = L_sc)\nqspin_chain.set_count_str(['0011011'])\n\nres_qc_1k = qspin_chain.qc_simulation_vecdens(time_arr,shots=1000)\nres_qc_1w = qspin_chain.qc_simulation_vecdens(time_arr,shots=10000)\n\nAs_qc_1k = np.sqrt(res_qc_1k)\nAs_qc_1w = np.sqrt(res_qc_1w)\n</code></pre> <p>And we can plot the results:</p> <pre><code>#==============plot\nplt.figure(figsize=(6,2))\nplt.plot(time_arr,As_qc_1k[:],'r-',label=f\"quantum,counts={1000}\")\nplt.plot(time_arr,As_qc_1w[:],'b-',label=f\"quantum,counts={10000}\")\nplt.plot(time_arr,As_qutip,'ko',markersize=4,markevery=4,label=\"QuTiP benchmark\")\nplt.xlabel('Time',fontsize=15)\nplt.ylabel('$A_s$(t)',fontsize=15)\nplt.legend(loc = 'upper right')\n</code></pre> <p></p>"},{"location":"qflux/Open_Systems/open_systems/#the-double-well","title":"The Double Well","text":""},{"location":"qflux/Open_Systems/open_systems/#setting-things-up","title":"Setting Things Up","text":"<pre><code>from qflux.open_systems.numerical_methods import DVR_grid\n\n#=============set up the double well in the grid point representation\ndef pot_doublewell(x, f=0.0367493, a0=0.0, a1=0.429, a2=-1.126, a3=-0.143, a4=0.563):\n    # A-T pair double-well potential in Hartrees (x is in Bohr)\n    xi = x/1.9592\n    return f*(a0 + a1*xi + a2*xi**2 + a3*xi**3 + a4*xi**4)\n\nmass0 = 1836.15\nbeta = pa.au2joule/(pa.bolz*300) #1/(kT) in a.u. units\nomega = 0.00436 #the frequency associate with the right well\nkappa = 1/(10/pa.au2fs)\nnth = 1/(np.exp(beta*omega)-1)\n\ndw_grid = DVR_grid(xmin = -4.0, xmax = 4.0, Ngrid = 1024, mass = mass0)\n\ndw_grid.set_potential(pot_doublewell)\n</code></pre>"},{"location":"qflux/Open_Systems/open_systems/#visualizing-eigenstates-of-the-double-well","title":"Visualizing Eigenstates of the Double Well","text":"<pre><code>#=============The eigen_state\nNeig = 50\neneg_DW,psi_DW = dw_grid.get_eig_state(Neig)\n#========plot the eigenenergy and the distribution\nxgrid = dw_grid.xgrid\npot_arr = dw_grid.potential\n\n#distribution\ndis = []\nfor i in range(Neig):\n  dis.append(abs(psi_DW[:,i])**2)\n\nx_arr1 = {}\neig_arr1 = {}\ndis_plot = {}\n\nfor i in range(Neig):\n  x_arr1[i]=[]\n  eig_arr1[i] = []\n  dis_plot[i] = []\n  for j in range(len(xgrid)):\n    if(abs(dis[i][j])&gt;1E-2):\n      x_arr1[i].append(xgrid[j])\n      eig_arr1[i].append(eneg_DW[i])\n      dis_plot[i].append(dis[i][j])\n  dis_plot[i] = np.array(dis_plot[i])\n\n#plot\nplt.figure(figsize=(10, 5))\nplt.subplot(121)\nplt.plot(xgrid,pot_arr,'k')\n\nconst = 0.0025\nfor i in range(6):\n  plt.plot(x_arr1[i],eig_arr1[i],label=rf'$\\phi_{{{i+1}}}$')\n  #plt.plot(x_arr1[i],(dis_plot[i]*const+eneg_DW[i]))\n  plt.fill_between(x_arr1[i], (dis_plot[i]*const+eneg_DW[i]), eig_arr1[i],alpha=0.5)\nplt.ylim((-0.032, 0.0075))\nplt.xlabel('x (Bohr)',fontsize=15)\nplt.ylabel('Energy (a.u.)',fontsize=15)\nplt.legend(loc = 'lower right')\n\nplt.subplot(122)\nplt.plot(xgrid,pot_arr,'k')\nfor i in range(6,12):\n  #plt.plot(x_arr1[i],(dis_plot[i]*const+eneg_DW[i]))\n  plt.plot(x_arr1[i],eig_arr1[i],label=rf'$\\phi_{{{i+1}}}$')\n  plt.fill_between(x_arr1[i], (dis_plot[i]*const+eneg_DW[i]), eig_arr1[i],alpha=0.5)\n\nplt.subplots_adjust(wspace=0.3)\nplt.ylim((-0.032, 0.0075))\nplt.xlabel('x (Bohr)',fontsize=15)\nplt.ylabel('Energy (a.u.)',fontsize=15)\nplt.legend(loc = 'lower right')\nplt.show()\n#=================\n</code></pre>"},{"location":"qflux/Open_Systems/open_systems/#express-the-double-well-in-terms-of-eigenstate-basis","title":"Express the double well in terms of eigenstate basis","text":"<pre><code>#==================Express the operators in terms of eigenstate basis===========\npsik_DW = np.zeros((dw_grid.Ngrid,Neig),dtype=np.complex128)\nfor i in range(Neig):\n    psik_DW[:,i] = dw_grid.x2k_wave(psi_DW[:,i])\n\n#hamiltonian\nH_dw = np.diag(eneg_DW)\n\n#The operator in the eigenstate\nxmat_eig = tb.trans_basis_diag(dw_grid.xgrid, Neig, psi_DW)*dw_grid.dx\npmat_eig = tb.trans_basis_diag(dw_grid.kgrid, Neig, psik_DW)*dw_grid.dk\n\n#creation/annihilation operator\namat_eig = xmat_eig.copy()*np.sqrt(mass0*omega/2)+1j*pmat_eig.copy()/np.sqrt(mass0*omega*2)\nadegmat_eig = xmat_eig.copy()*np.sqrt(mass0*omega/2)-1j*pmat_eig.copy()/np.sqrt(mass0*omega*2)\n\n#define the population on the left/right well and transform to eigen state basis\nx_barrier = 0.37321768\nP_R = np.heaviside(xgrid-x_barrier,1)\nP_L = 1 - np.heaviside(xgrid-x_barrier,1)\n\nP_R_eig = tb.trans_basis_diag(P_R, Neig, psi_DW)*dw_grid.dx\nP_L_eig = tb.trans_basis_diag(P_L, Neig, psi_DW)*dw_grid.dx\n\n#initial density matrix\nini_occu = np.zeros(Neig,dtype=np.complex128)\nini_occu[5] = 1.0\nrho0 = np.outer(ini_occu,ini_occu.conj())\n</code></pre>"},{"location":"qflux/Open_Systems/open_systems/#classical-simulation_2","title":"Classical Simulation","text":"<pre><code>#==================classical simulation============================\n#propogate using QuTiP\ngamma1 = np.sqrt(kappa*(nth+1))\ngamma2 = np.sqrt(kappa*(nth))\n\ntime_qtp = np.linspace(0,1000/pa.au2fs,20000)\n\n# Double_Well with different eigenstates truncation\ndw_eig = {}\nresult_qtp = {}\nfor N_eig_use in [20,30,40]:\n    c_ops = [gamma1*amat_eig[:N_eig_use,:N_eig_use], gamma2*adegmat_eig[:N_eig_use,:N_eig_use]]\n    dw_eig[N_eig_use] = DynamicsOS(Nsys = N_eig_use, Hsys = H_dw[:N_eig_use,:N_eig_use], \\\n                                      rho0 = rho0[:N_eig_use,:N_eig_use], c_ops = c_ops)\n\n    obs = [P_R_eig[:N_eig_use,:N_eig_use], P_L_eig[:N_eig_use,:N_eig_use]]\n    result_qtp[N_eig_use] = dw_eig[N_eig_use].propagate_qt(time_qtp, obs, progress_bar=True)\n</code></pre> <pre><code>#this section will approximate take 10 minutes\n#propagate using matrix exponential propagation\nN_eig_use=30\nc_ops = [gamma1*amat_eig[:N_eig_use,:N_eig_use], gamma2*adegmat_eig[:N_eig_use,:N_eig_use]]\nobservable = P_R_eig[:N_eig_use,:N_eig_use]\n\ntime_short = np.linspace(0,1000/pa.au2fs,30) #compare to QuTiP time scale\nresult_s = dw_eig[N_eig_use].propagate_matrix_exp(time_short, observable, Is_show_step=True)\n\ntime_long = np.linspace(0,20000/pa.au2fs,60) #long time propagation\nresult_dw_l = dw_eig[N_eig_use].propagate_matrix_exp(time_long, observable, \\\n                                Is_store_state = True, Is_show_step=True, Is_Gt=True)\n</code></pre> <p>And we can plot the populations for our classical simulation results:</p> <pre><code>#======================plot the classical results======================\nfig, axs = plt.subplots(2, 1, figsize=(6, 7))\naxs[0].plot(time_qtp*pa.au2fs,result_qtp[20][0],'r-',label = 'QuTiP-Neig20')\naxs[0].plot(time_qtp*pa.au2fs,result_qtp[30][0],'b-',label = 'QuTiP-Neig30')\naxs[0].plot(time_qtp*pa.au2fs,result_qtp[40][0],'ko',markersize=4,markevery=400,label = 'QuTiP-Neig40')\naxs[0].set_xlabel('t (fs)',fontsize=15)\naxs[0].set_ylabel('Population',fontsize=15)\naxs[0].legend(loc = 'upper right')\n\n#plt.figure(figsize=(6,3))\naxs[1].plot(time_qtp*pa.au2fs,result_qtp[30][0],'b-',label = 'QuTiP')\naxs[1].plot(time_short*pa.au2fs,result_s.expect[:],'ko',label = 'Matrix Exponential')\naxs[1].set_xlabel('t (fs)',fontsize=15)\naxs[1].set_ylabel('Population',fontsize=15)\naxs[1].legend(loc = 'upper right')\n\nplt.tight_layout()\n</code></pre> <p></p> <p>We can also plot the distribution over time:</p> <pre><code>#plot the distribution\nplt.plot(xgrid,dis_list[0],'b',label='t=0 fs')\nplt.plot(xgrid,dis_list[1],'y',label=rf'$t={{{int(time_long[20]*pa.au2fs)}}}$ fs')\nplt.plot(xgrid,dis_list[2],'g',label=rf'$t={{{int(time_long[40]*pa.au2fs)}}}$ fs')\nplt.plot(xgrid,dis_list[3],'r',label=rf'$t={{{int(time_long[59]*pa.au2fs)}}}$ fs')\nplt.plot(xgrid,pot_arr*10,'k')\nplt.xlabel('x (Bohr)',fontsize=15)\nplt.ylabel('distribution',fontsize=15)\nplt.legend(loc = 'upper right')\nplt.show()\n</code></pre> <p></p>"},{"location":"qflux/Open_Systems/open_systems/#quantum-simulation_1","title":"Quantum Simulation","text":"<pre><code>from qflux.open_systems.quantum_simulation import expand\n\n##===============Quantum Simulation ====================================\ndim_dw = 32\n\n# initial state of the double-well in the dilated space\nini_occu = np.zeros(dim_dw,dtype=np.complex128)\nini_occu[5] = 1.0\nrho0 = np.outer(ini_occu,ini_occu.conj())\n\n#hamiltonian\nHsys = H_dw[:dim_dw,:dim_dw]\n\n#collapse operator and observable\nc_ops = [gamma1*amat_eig[:dim_dw,:dim_dw], gamma2*adegmat_eig[:dim_dw,:dim_dw]]\nobservable = P_R_eig[:dim_dw,:dim_dw]\n\n#extract the propagator from result of classical simulation,\n#and expand to match the dimension of qubit space\n#For saving calculation, only choose some time points\nilarge = 5\nnsteps = int(len(time_long)/ilarge)\ntime_qdw = np.zeros(nsteps)\nGprop_dw = []\n\nfor i0 in range(nsteps):\n    i = i0*ilarge\n    org_dim = result_dw_l.density_matrix[i].shape[0]\n    Gprop_dw.append(expand(result_dw_l.Gprop[i],org_dim,dim_dw))\n\n    time_qdw[i0] = time_long[i]\n\n#double well instance\ndw_quantum = QubitDynamicsOS(rep='Kraus', Nsys=dim_dw, Hsys=Hsys, rho0=rho0, c_ops = c_ops)\ndw_quantum.set_observable(observable)\n\n#running the quantum simulation\nP_dw_qc = dw_quantum.qc_simulation_kraus(time_qdw, shots=2000,  Gprop = Gprop_dw, tolk = 1E-2, tolo = 5E-3)\n</code></pre> <p>We can then plot the results:</p> <pre><code>#=================plot=========================\nplt.figure(figsize=(6,3))\nplt.plot(time_long*pa.au2fs,result_dw_l.expect,'k-',label = 'Matrix Exponential')\nplt.plot(time_qdw*pa.au2fs,P_dw_qc,'ro',label = 'quantum simulation')\nplt.xlabel('t (fs)',fontsize=15)\nplt.ylabel('Population',fontsize=15)\nplt.legend(loc = 'upper right')\nplt.show()\n</code></pre> <p></p>"},{"location":"qflux/Open_Systems/os_api/","title":"Open Systems Module","text":""},{"location":"qflux/Open_Systems/os_api/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>open_systems</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/Open_Systems/os_api/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/Open_Systems/os_api/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/Open_Systems/os_api/#source-code","title":"Source Code","text":""},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems","title":"<code>qflux.open_systems</code>","text":""},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DynamicsOS","title":"<code>DynamicsOS</code>","text":"<p>Class for open-system dynamics (Lindblad equation).</p> <p>This class provides methods to simulate open-system dynamics described by the Lindblad equation.</p> <p>Attributes:</p> Name Type Description <code>Nsys</code> <code>int</code> <p>System Hilbert Space Dimension.</p> <code>Hsys</code> <code>ndarray</code> <p>Hamiltonian of the system (shape (N, N)).</p> <code>rho0</code> <code>ndarray</code> <p>Initial density matrix (shape (N, N)).</p> <code>c_ops</code> <code>List[ndarray]</code> <p>List of collapse operators (each of shape (N, N)).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>class DynamicsOS:\n    \"\"\"Class for open-system dynamics (Lindblad equation).\n\n    This class provides methods to simulate open-system dynamics described by the Lindblad equation.\n\n    Attributes:\n        Nsys (int): System Hilbert Space Dimension.\n        Hsys (np.ndarray): Hamiltonian of the system (shape (N, N)).\n        rho0 (np.ndarray): Initial density matrix (shape (N, N)).\n        c_ops (List[np.ndarray]): List of collapse operators (each of shape (N, N)).\n    \"\"\"\n\n    def __init__(\n        self,\n        Nsys: int,\n        Hsys: np.ndarray,\n        rho0: np.ndarray,\n        c_ops: Optional[List[np.ndarray]] = None\n    ) -&gt; None:\n        \"\"\"\n        Initialize the DynamicsOS instance.\n\n        Args:\n            Nsys (int): System Hilbert Space Dimension.\n            Hsys (np.ndarray): Hamiltonian of the system.\n            rho0 (np.ndarray): Initial density matrix.\n            c_ops (Optional[List[np.ndarray]]): List of collapse operators. Defaults to an empty list.\n        \"\"\"\n        if c_ops is None:\n            c_ops = []\n        self.Nsys: int = Nsys\n        self.Hsys: np.ndarray = Hsys\n        self.rho0: np.ndarray = rho0\n        self.c_ops: List[np.ndarray] = c_ops\n\n    def Gt_matrix_expo(self, time_arr: List[float], Is_show_step: bool = False) -&gt; List[np.ndarray]:\n        \"\"\"\n        Compute the propagator of the Lindblad equation using the matrix exponential.\n\n        The propagator is computed by exponentiating the Liouvillian operator defined by the\n        system Hamiltonian and collapse operators.\n\n        Args:\n            time_arr (List[float]): Array of time values for the simulation.\n            Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n\n        Returns:\n            List[np.ndarray]: List of propagators corresponding to each time in `time_arr`.\n        \"\"\"\n        ident_h: np.ndarray = np.eye(self.Nsys, dtype=np.complex128)\n\n        # Build the A matrix for time-derivation of the vectorized density matrix.\n        Amat: np.ndarray = -1j * (np.kron(self.Hsys, ident_h) - np.kron(ident_h, self.Hsys.T))\n        for i in range(len(self.c_ops)):\n            Amat += 0.5 * (\n                2.0 * np.kron(self.c_ops[i], self.c_ops[i].conj())\n                - np.kron(ident_h, (self.c_ops[i].T @ self.c_ops[i].conj()))\n                - np.kron((self.c_ops[i].T.conj() @ self.c_ops[i]), ident_h)\n            )\n\n        G_prop: List[np.ndarray] = []\n        for i, t in enumerate(time_arr):\n            if Is_show_step:\n                print(\"step\", i, \"time\", t)\n            Gt: np.ndarray = LA.expm(Amat * t)\n            G_prop.append(Gt)\n        return G_prop\n\n    def propagate_matrix_exp(\n        self,\n        time_arr: List[float],\n        observable: np.ndarray,\n        Is_store_state: bool = False,\n        Is_show_step: bool = False,\n        Is_Gt: bool = False,\n    ) -&gt; Any:\n        \"\"\"\n        Solve the Lindblad equation using matrix exponential.\n\n        This method computes the propagator, evolves the initial density matrix, and calculates\n        the expectation value of the observable over time. Optionally, it stores the evolved density matrices.\n\n        Args:\n            time_arr (List[float]): Time array for dynamic simulation.\n            observable (np.ndarray): Observable matrix for which the expectation value is computed.\n            Is_store_state (bool, optional): If True, stores the density matrices at each time step.\n                                             Defaults to False.\n            Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n            Is_Gt (bool, optional): If True, includes the propagators in the result. Defaults to False.\n\n        Returns:\n            Result: An object with the following attributes:\n                - expect (List[float]): List of expectation values over time.\n                - density_matrix (List[np.ndarray], optional): List of density matrices (if `Is_store_state` is True).\n                - Gprop (List[np.ndarray], optional): List of propagators (if `Is_Gt` is True).\n        \"\"\"\n\n        class Result:\n            \"\"\"Class for storing propagation results.\"\"\"\n            def __init__(self, store_state: bool, include_Gt: bool) -&gt; None:\n                self.expect: List[float] = []\n                if store_state:\n                    self.density_matrix: List[np.ndarray] = []\n                if include_Gt:\n                    self.Gprop: Optional[List[np.ndarray]] = None\n\n        result = Result(Is_store_state, Is_Gt)\n\n        # Compute the propagator of the Lindblad equation.\n        G_prop: List[np.ndarray] = self.Gt_matrix_expo(time_arr, Is_show_step)\n        if Is_Gt:\n            result.Gprop = G_prop\n\n        # Initialize the vectorized density matrix.\n        vec_rho0: np.ndarray = self.rho0.reshape(self.Nsys**2)\n\n        for i, _ in enumerate(time_arr):\n            vec_rhot: np.ndarray = G_prop[i] @ vec_rho0\n            # Reshape back to density matrix form.\n            rhot: np.ndarray = vec_rhot.reshape(self.Nsys, self.Nsys)\n\n            if Is_store_state:\n                result.density_matrix.append(rhot)\n            result.expect.append(np.trace(rhot @ observable).real)\n\n        return result\n\n    def propagate_qt(self, time_arr: List[float], observable: Any, **kwargs: Any) -&gt; List[float]:\n        \"\"\"\n        Propagate the system using QuTiP's `mesolve` function.\n\n        This method solves the Lindblad master equation using QuTiP's `mesolve` to compute the expectation\n        values of the observable over time.\n\n        Args:\n            time_arr (List[float]): Time array for dynamic simulation.\n            observable (Any): Observable operator(s) for which the expectation value is computed.\n                              Can be a single operator or a list of operators.\n            **kwargs: Additional keyword arguments to pass to `mesolve`.\n\n        Returns:\n            List[float]: List of expectation values of the observable over time.\n        \"\"\"\n        c_ops: List[Qobj] = [Qobj(c_op) for c_op in self.c_ops]\n\n        if isinstance(observable, list):\n            obs = [Qobj(op) for op in observable]\n        else:\n            obs = Qobj(observable)\n\n        result = mesolve(Qobj(self.Hsys), Qobj(self.rho0), time_arr, c_ops, obs, **kwargs)\n        return result.expect\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DynamicsOS.Gt_matrix_expo","title":"<code>Gt_matrix_expo(time_arr, Is_show_step=False)</code>","text":"<p>Compute the propagator of the Lindblad equation using the matrix exponential.</p> <p>The propagator is computed by exponentiating the Liouvillian operator defined by the system Hamiltonian and collapse operators.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Array of time values for the simulation.</p> required <code>Is_show_step</code> <code>bool</code> <p>If True, prints the current simulation step. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List[np.ndarray]: List of propagators corresponding to each time in <code>time_arr</code>.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def Gt_matrix_expo(self, time_arr: List[float], Is_show_step: bool = False) -&gt; List[np.ndarray]:\n    \"\"\"\n    Compute the propagator of the Lindblad equation using the matrix exponential.\n\n    The propagator is computed by exponentiating the Liouvillian operator defined by the\n    system Hamiltonian and collapse operators.\n\n    Args:\n        time_arr (List[float]): Array of time values for the simulation.\n        Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n\n    Returns:\n        List[np.ndarray]: List of propagators corresponding to each time in `time_arr`.\n    \"\"\"\n    ident_h: np.ndarray = np.eye(self.Nsys, dtype=np.complex128)\n\n    # Build the A matrix for time-derivation of the vectorized density matrix.\n    Amat: np.ndarray = -1j * (np.kron(self.Hsys, ident_h) - np.kron(ident_h, self.Hsys.T))\n    for i in range(len(self.c_ops)):\n        Amat += 0.5 * (\n            2.0 * np.kron(self.c_ops[i], self.c_ops[i].conj())\n            - np.kron(ident_h, (self.c_ops[i].T @ self.c_ops[i].conj()))\n            - np.kron((self.c_ops[i].T.conj() @ self.c_ops[i]), ident_h)\n        )\n\n    G_prop: List[np.ndarray] = []\n    for i, t in enumerate(time_arr):\n        if Is_show_step:\n            print(\"step\", i, \"time\", t)\n        Gt: np.ndarray = LA.expm(Amat * t)\n        G_prop.append(Gt)\n    return G_prop\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DynamicsOS.__init__","title":"<code>__init__(Nsys, Hsys, rho0, c_ops=None)</code>","text":"<p>Initialize the DynamicsOS instance.</p> <p>Parameters:</p> Name Type Description Default <code>Nsys</code> <code>int</code> <p>System Hilbert Space Dimension.</p> required <code>Hsys</code> <code>ndarray</code> <p>Hamiltonian of the system.</p> required <code>rho0</code> <code>ndarray</code> <p>Initial density matrix.</p> required <code>c_ops</code> <code>Optional[List[ndarray]]</code> <p>List of collapse operators. Defaults to an empty list.</p> <code>None</code> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def __init__(\n    self,\n    Nsys: int,\n    Hsys: np.ndarray,\n    rho0: np.ndarray,\n    c_ops: Optional[List[np.ndarray]] = None\n) -&gt; None:\n    \"\"\"\n    Initialize the DynamicsOS instance.\n\n    Args:\n        Nsys (int): System Hilbert Space Dimension.\n        Hsys (np.ndarray): Hamiltonian of the system.\n        rho0 (np.ndarray): Initial density matrix.\n        c_ops (Optional[List[np.ndarray]]): List of collapse operators. Defaults to an empty list.\n    \"\"\"\n    if c_ops is None:\n        c_ops = []\n    self.Nsys: int = Nsys\n    self.Hsys: np.ndarray = Hsys\n    self.rho0: np.ndarray = rho0\n    self.c_ops: List[np.ndarray] = c_ops\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DynamicsOS.propagate_matrix_exp","title":"<code>propagate_matrix_exp(time_arr, observable, Is_store_state=False, Is_show_step=False, Is_Gt=False)</code>","text":"<p>Solve the Lindblad equation using matrix exponential.</p> <p>This method computes the propagator, evolves the initial density matrix, and calculates the expectation value of the observable over time. Optionally, it stores the evolved density matrices.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Time array for dynamic simulation.</p> required <code>observable</code> <code>ndarray</code> <p>Observable matrix for which the expectation value is computed.</p> required <code>Is_store_state</code> <code>bool</code> <p>If True, stores the density matrices at each time step.                              Defaults to False.</p> <code>False</code> <code>Is_show_step</code> <code>bool</code> <p>If True, prints the current simulation step. Defaults to False.</p> <code>False</code> <code>Is_Gt</code> <code>bool</code> <p>If True, includes the propagators in the result. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Any</code> <p>An object with the following attributes: - expect (List[float]): List of expectation values over time. - density_matrix (List[np.ndarray], optional): List of density matrices (if <code>Is_store_state</code> is True). - Gprop (List[np.ndarray], optional): List of propagators (if <code>Is_Gt</code> is True).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def propagate_matrix_exp(\n    self,\n    time_arr: List[float],\n    observable: np.ndarray,\n    Is_store_state: bool = False,\n    Is_show_step: bool = False,\n    Is_Gt: bool = False,\n) -&gt; Any:\n    \"\"\"\n    Solve the Lindblad equation using matrix exponential.\n\n    This method computes the propagator, evolves the initial density matrix, and calculates\n    the expectation value of the observable over time. Optionally, it stores the evolved density matrices.\n\n    Args:\n        time_arr (List[float]): Time array for dynamic simulation.\n        observable (np.ndarray): Observable matrix for which the expectation value is computed.\n        Is_store_state (bool, optional): If True, stores the density matrices at each time step.\n                                         Defaults to False.\n        Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n        Is_Gt (bool, optional): If True, includes the propagators in the result. Defaults to False.\n\n    Returns:\n        Result: An object with the following attributes:\n            - expect (List[float]): List of expectation values over time.\n            - density_matrix (List[np.ndarray], optional): List of density matrices (if `Is_store_state` is True).\n            - Gprop (List[np.ndarray], optional): List of propagators (if `Is_Gt` is True).\n    \"\"\"\n\n    class Result:\n        \"\"\"Class for storing propagation results.\"\"\"\n        def __init__(self, store_state: bool, include_Gt: bool) -&gt; None:\n            self.expect: List[float] = []\n            if store_state:\n                self.density_matrix: List[np.ndarray] = []\n            if include_Gt:\n                self.Gprop: Optional[List[np.ndarray]] = None\n\n    result = Result(Is_store_state, Is_Gt)\n\n    # Compute the propagator of the Lindblad equation.\n    G_prop: List[np.ndarray] = self.Gt_matrix_expo(time_arr, Is_show_step)\n    if Is_Gt:\n        result.Gprop = G_prop\n\n    # Initialize the vectorized density matrix.\n    vec_rho0: np.ndarray = self.rho0.reshape(self.Nsys**2)\n\n    for i, _ in enumerate(time_arr):\n        vec_rhot: np.ndarray = G_prop[i] @ vec_rho0\n        # Reshape back to density matrix form.\n        rhot: np.ndarray = vec_rhot.reshape(self.Nsys, self.Nsys)\n\n        if Is_store_state:\n            result.density_matrix.append(rhot)\n        result.expect.append(np.trace(rhot @ observable).real)\n\n    return result\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DynamicsOS.propagate_qt","title":"<code>propagate_qt(time_arr, observable, **kwargs)</code>","text":"<p>Propagate the system using QuTiP's <code>mesolve</code> function.</p> <p>This method solves the Lindblad master equation using QuTiP's <code>mesolve</code> to compute the expectation values of the observable over time.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Time array for dynamic simulation.</p> required <code>observable</code> <code>Any</code> <p>Observable operator(s) for which the expectation value is computed.               Can be a single operator or a list of operators.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to <code>mesolve</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: List of expectation values of the observable over time.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def propagate_qt(self, time_arr: List[float], observable: Any, **kwargs: Any) -&gt; List[float]:\n    \"\"\"\n    Propagate the system using QuTiP's `mesolve` function.\n\n    This method solves the Lindblad master equation using QuTiP's `mesolve` to compute the expectation\n    values of the observable over time.\n\n    Args:\n        time_arr (List[float]): Time array for dynamic simulation.\n        observable (Any): Observable operator(s) for which the expectation value is computed.\n                          Can be a single operator or a list of operators.\n        **kwargs: Additional keyword arguments to pass to `mesolve`.\n\n    Returns:\n        List[float]: List of expectation values of the observable over time.\n    \"\"\"\n    c_ops: List[Qobj] = [Qobj(c_op) for c_op in self.c_ops]\n\n    if isinstance(observable, list):\n        obs = [Qobj(op) for op in observable]\n    else:\n        obs = Qobj(observable)\n\n    result = mesolve(Qobj(self.Hsys), Qobj(self.rho0), time_arr, c_ops, obs, **kwargs)\n    return result.expect\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS","title":"<code>QubitDynamicsOS</code>","text":"<p>               Bases: <code>DynamicsOS</code></p> <p>Class for simulating quantum dynamics using either vectorized density matrix or Kraus operator representations.</p> <p>This class provides methods to initialize state vectors, construct quantum circuits, and perform quantum simulations using Qiskit backends.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>class QubitDynamicsOS(DynamicsOS):\n    \"\"\"\n    Class for simulating quantum dynamics using either vectorized density matrix or Kraus operator representations.\n\n    This class provides methods to initialize state vectors, construct quantum circuits,\n    and perform quantum simulations using Qiskit backends.\n    \"\"\"\n\n    def __init__(self, rep: str = 'Density', **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize a QubitDynamicsOS instance.\n\n        Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed.\n        Additional keyword arguments are passed to the base DynamicsOS class.\n\n        Args:\n            rep (str, optional): Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.\n            **kwargs: Additional keyword arguments for the DynamicsOS initializer.\n        \"\"\"\n        super().__init__(**kwargs)\n\n        if rep == 'Density':\n            # Vectorized density matrix representation\n            self.rep: str = 'Density'\n            self.Nqb: int = int(np.log2(self.Nsys**2))\n        elif rep == 'Kraus':\n            # Kraus operator representation\n            self.rep = 'Kraus'\n            self.Nqb = int(np.log2(self.Nsys))\n\n        # The counting qubits bit string and observable matrix are initialized to None.\n        self.count_str: Optional[List[str]] = None\n        self.observable: Optional[np.ndarray] = None\n\n        # Default dilation method for quantum simulation.\n        self.dilation_method: str = 'Sz-Nagy'\n\n    def set_dilation_method(self, method: str) -&gt; None:\n        \"\"\"\n        Set the dilation method for quantum simulation.\n\n        Args:\n            method (str): The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.\n        \"\"\"\n        self.dilation_method = method\n\n    def set_count_str(self, count_str: List[str]) -&gt; None:\n        \"\"\"\n        Set the counting bit string for measurement.\n\n        Args:\n            count_str (List[str]): The counting bit string.\n        \"\"\"\n        self.count_str = count_str\n\n    def set_observable(self, observable: np.ndarray) -&gt; None:\n        \"\"\"\n        Set the observable for the quantum simulation.\n\n        Args:\n            observable (np.ndarray): The observable matrix.\n        \"\"\"\n        self.observable = observable\n\n    def init_statevec_vecdens(self) -&gt; Tuple[np.ndarray, float]:\n        \"\"\"\n        Initialize the state vector from the initial density operator using vectorized representation.\n\n        The initial density matrix is reshaped into a vector and normalized.\n\n        Returns:\n            Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm\n            of the original vectorized density matrix.\n        \"\"\"\n        vec_rho0 = self.rho0.reshape(self.Nsys**2)\n        norm0 = LA.norm(vec_rho0, 2)\n        statevec = vec_rho0 / norm0\n        return statevec, norm0\n\n    def init_statevec_Kraus(self, tol: float = 1e-6) -&gt; Tuple[List[np.ndarray], List[float]]:\n        \"\"\"\n        Initialize state vectors from the initial density operator using the Kraus operator representation.\n\n        The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues\n        below the specified tolerance are ignored.\n\n        Args:\n            tol (float, optional): Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.\n\n        Returns:\n            Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of\n            corresponding probabilities.\n        \"\"\"\n        eigenvalues, eigenvectors = LA.eigh(self.rho0)\n        statevec: List[np.ndarray] = []\n        prob: List[float] = []\n        for i in range(len(eigenvalues) - 1, -1, -1):\n            if abs(eigenvalues[i]) &lt; tol:\n                break\n            prob.append(eigenvalues[i])\n            statevec.append(eigenvectors[:, i])\n        return statevec, prob\n\n    def _get_qiskit_observable(self, Isdilate: bool = False, tol: float = 5e-3) -&gt; SparsePauliOp:\n        \"\"\"\n        Prepare and return the Qiskit observable operator.\n\n        Converts the observable matrix to its Pauli representation and returns a SparsePauliOp.\n\n        Args:\n            Isdilate (bool, optional): Flag indicating whether to use the dilated observable.\n                Defaults to False.\n            tol (float, optional): Tolerance for the Pauli decomposition. Defaults to 5e-3.\n\n        Returns:\n            SparsePauliOp: The Qiskit representation of the observable.\n        \"\"\"\n        if self.observable is None:\n            print('Error: observable is None')\n\n        if Isdilate:\n            num_qubits = self.Nqb + 1\n            Obs_mat = np.zeros((2 * self.Nsys, 2 * self.Nsys), dtype=np.complex128)\n            Obs_mat[:self.Nsys, :self.Nsys] = self.observable[:self.Nsys, :self.Nsys]\n        else:\n            num_qubits = self.Nqb\n            Obs_mat = self.observable\n\n        Obs_paulis_dic = tb.ham_to_pauli(Obs_mat, num_qubits, tol=tol)\n\n        # Prepare the Qiskit observable from the Pauli strings of the observable matrix.\n        data: List[str] = []\n        coef: List[float] = []\n        for key in Obs_paulis_dic:\n            data.append(key)\n            coef.append(Obs_paulis_dic[key])\n        obs_q = SparsePauliOp(data, coef)\n        return obs_q\n\n    def qc_simulation_kraus(\n        self,\n        time_arr: List[float],\n        shots: int = 1024,\n        Kraus: Optional[Dict[int, List[np.ndarray]]] = None,\n        Gprop: Optional[List[np.ndarray]] = None,\n        tolk: float = 1e-5,\n        tolo: float = 1e-5,\n        **kwargs: Any\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform quantum simulation using the Kraus operator representation.\n\n        This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach.\n        It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator,\n        and accumulates the measurement results.\n\n        Args:\n            time_arr (List[float]): List of time steps for simulation.\n            shots (int, optional): Number of shots for each measurement. Defaults to 1024.\n            Kraus (Optional[Dict[int, List[np.ndarray]]], optional): Dictionary mapping time step index to a list of Kraus operators.\n                If None, Kraus operators are generated from the propagator. Defaults to None.\n            Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n                If None, it will be calculated. Defaults to None.\n            tolk (float, optional): Tolerance for generating Kraus operators. Defaults to 1e-5.\n            tolo (float, optional): Tolerance for observable decomposition. Defaults to 1e-5.\n            **kwargs: Additional keyword arguments for propagator calculation.\n\n        Returns:\n            np.ndarray: Array containing the quantum simulation results.\n        \"\"\"\n        nsteps = len(time_arr)\n\n        # Generate Kraus operators if not provided.\n        if Kraus is None:\n            Kraus = {}\n            if Gprop is None:\n                print('Calculating the propagator')\n                Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n            print('Generating the Kraus operators')\n            for i in range(nsteps):\n                print('At step', i, 'of', nsteps)\n                Kraus[i] = gen_Kraus_list(Gprop[i], self.Nsys, tol=tolk)\n        print('Kraus operator generation complete')\n\n        # Perform Qiskit simulation using the Estimator.\n        estimator = Estimator()\n\n        statevec, prob = self.init_statevec_Kraus()\n        n_inistate = len(statevec)\n        print('Number of initial states in the density matrix:', n_inistate)\n        print('Probabilities:', prob)\n\n        # Obtain the Qiskit observable.\n        obs_q = self._get_qiskit_observable(Isdilate=True, tol=tolo)\n\n        print('Starting quantum simulation')\n        result_simulation = np.zeros(nsteps, dtype=np.float64)\n\n        for i in range(nsteps):\n            print('Simulation step', i, 'of', nsteps)\n            current_kraus_list = Kraus[i]\n            print('Number of Kraus operators:', len(current_kraus_list))\n            for kraus_op in current_kraus_list:\n                for istate in range(n_inistate):\n                    qc = self._create_circuit(kraus_op, statevec[istate], Isscale=False)\n                    result = estimator.run(qc, obs_q, shots=shots).result()\n                    result_simulation[i] += result.values[0] * prob[istate]\n\n        return result_simulation\n\n    def qc_simulation_vecdens(\n        self,\n        time_arr: List[float],\n        shots: int = 1024,\n        backend: Any = AerSimulator(),\n        Gprop: Optional[List[np.ndarray]] = None,\n        **kwargs: Any\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform quantum simulation using the vectorized density matrix representation.\n\n        This method simulates the quantum system dynamics over a series of time steps by constructing circuits\n        based on the vectorized density matrix representation, performing measurements, and processing the results.\n\n        Args:\n            time_arr (List[float]): List of time steps for simulation.\n            shots (int, optional): Number of measurement shots. Defaults to 1024.\n            backend (Any, optional): Quantum simulation backend. Defaults to AerSimulator().\n            Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n                If None, it will be calculated. Defaults to None.\n            **kwargs: Additional keyword arguments for propagator calculation.\n\n        Returns:\n            np.ndarray: Array containing the quantum simulation results.\n        \"\"\"\n        if Gprop is None:\n            Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n\n        nsteps = len(time_arr)\n\n        if self.count_str is None:\n            print(\"Error: count_str is not assigned\")\n\n        n_bitstr = len(self.count_str)\n        statevec, norm0 = self.init_statevec_vecdens()\n        result = np.zeros((nsteps, n_bitstr), dtype=np.float64)\n\n        for i in range(nsteps):\n            if i % 100 == 0:\n                print('Quantum simulation step', i)\n            Gt = Gprop[i]\n            circuit, norm = self._create_circuit(Gt, statevec, Isscale=True)\n            circuit.measure(range(self.Nqb + 1), range(self.Nqb + 1))\n            if self.dilation_method == 'SVD-Walsh':\n                circuit = transpile(circuit, backend)\n            counts = backend.run(circuit, shots=shots).result().get_counts()\n            for j in range(n_bitstr):\n                bitstr = self.count_str[j]\n                if bitstr in counts:\n                    result[i, j] = np.sqrt(counts[bitstr] / shots) * norm * norm0\n                else:\n                    print('At time', i, 'with shots =', shots, \"no counts for\", bitstr)\n\n        return result\n\n    def _create_circuit(\n        self,\n        array: np.ndarray,\n        statevec: Union[np.ndarray, List[np.ndarray]],\n        Isscale: bool = True\n    ) -&gt; QuantumCircuit:\n        \"\"\"\n        Construct and return the quantum circuit.\n\n        This method wraps the call to the dilation circuit construction function.\n\n        Args:\n            array (np.ndarray): Array used for circuit construction (e.g., propagator or Kraus operator).\n            statevec (Union[np.ndarray, List[np.ndarray]]): State vector(s) to be used in the circuit.\n            Isscale (bool, optional): Flag indicating whether scaling should be applied. Defaults to True.\n\n        Returns:\n            QuantumCircuit: The constructed quantum circuit.\n        \"\"\"\n        return dc.construct_circuit(self.Nqb, array, statevec, method=self.dilation_method, Isscale=Isscale)\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.__init__","title":"<code>__init__(rep='Density', **kwargs)</code>","text":"<p>Initialize a QubitDynamicsOS instance.</p> <p>Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed. Additional keyword arguments are passed to the base DynamicsOS class.</p> <p>Parameters:</p> Name Type Description Default <code>rep</code> <code>str</code> <p>Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.</p> <code>'Density'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the DynamicsOS initializer.</p> <code>{}</code> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def __init__(self, rep: str = 'Density', **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize a QubitDynamicsOS instance.\n\n    Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed.\n    Additional keyword arguments are passed to the base DynamicsOS class.\n\n    Args:\n        rep (str, optional): Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.\n        **kwargs: Additional keyword arguments for the DynamicsOS initializer.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    if rep == 'Density':\n        # Vectorized density matrix representation\n        self.rep: str = 'Density'\n        self.Nqb: int = int(np.log2(self.Nsys**2))\n    elif rep == 'Kraus':\n        # Kraus operator representation\n        self.rep = 'Kraus'\n        self.Nqb = int(np.log2(self.Nsys))\n\n    # The counting qubits bit string and observable matrix are initialized to None.\n    self.count_str: Optional[List[str]] = None\n    self.observable: Optional[np.ndarray] = None\n\n    # Default dilation method for quantum simulation.\n    self.dilation_method: str = 'Sz-Nagy'\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS._create_circuit","title":"<code>_create_circuit(array, statevec, Isscale=True)</code>","text":"<p>Construct and return the quantum circuit.</p> <p>This method wraps the call to the dilation circuit construction function.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>Array used for circuit construction (e.g., propagator or Kraus operator).</p> required <code>statevec</code> <code>Union[ndarray, List[ndarray]]</code> <p>State vector(s) to be used in the circuit.</p> required <code>Isscale</code> <code>bool</code> <p>Flag indicating whether scaling should be applied. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QuantumCircuit</code> <code>QuantumCircuit</code> <p>The constructed quantum circuit.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def _create_circuit(\n    self,\n    array: np.ndarray,\n    statevec: Union[np.ndarray, List[np.ndarray]],\n    Isscale: bool = True\n) -&gt; QuantumCircuit:\n    \"\"\"\n    Construct and return the quantum circuit.\n\n    This method wraps the call to the dilation circuit construction function.\n\n    Args:\n        array (np.ndarray): Array used for circuit construction (e.g., propagator or Kraus operator).\n        statevec (Union[np.ndarray, List[np.ndarray]]): State vector(s) to be used in the circuit.\n        Isscale (bool, optional): Flag indicating whether scaling should be applied. Defaults to True.\n\n    Returns:\n        QuantumCircuit: The constructed quantum circuit.\n    \"\"\"\n    return dc.construct_circuit(self.Nqb, array, statevec, method=self.dilation_method, Isscale=Isscale)\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS._get_qiskit_observable","title":"<code>_get_qiskit_observable(Isdilate=False, tol=0.005)</code>","text":"<p>Prepare and return the Qiskit observable operator.</p> <p>Converts the observable matrix to its Pauli representation and returns a SparsePauliOp.</p> <p>Parameters:</p> Name Type Description Default <code>Isdilate</code> <code>bool</code> <p>Flag indicating whether to use the dilated observable. Defaults to False.</p> <code>False</code> <code>tol</code> <code>float</code> <p>Tolerance for the Pauli decomposition. Defaults to 5e-3.</p> <code>0.005</code> <p>Returns:</p> Name Type Description <code>SparsePauliOp</code> <code>SparsePauliOp</code> <p>The Qiskit representation of the observable.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def _get_qiskit_observable(self, Isdilate: bool = False, tol: float = 5e-3) -&gt; SparsePauliOp:\n    \"\"\"\n    Prepare and return the Qiskit observable operator.\n\n    Converts the observable matrix to its Pauli representation and returns a SparsePauliOp.\n\n    Args:\n        Isdilate (bool, optional): Flag indicating whether to use the dilated observable.\n            Defaults to False.\n        tol (float, optional): Tolerance for the Pauli decomposition. Defaults to 5e-3.\n\n    Returns:\n        SparsePauliOp: The Qiskit representation of the observable.\n    \"\"\"\n    if self.observable is None:\n        print('Error: observable is None')\n\n    if Isdilate:\n        num_qubits = self.Nqb + 1\n        Obs_mat = np.zeros((2 * self.Nsys, 2 * self.Nsys), dtype=np.complex128)\n        Obs_mat[:self.Nsys, :self.Nsys] = self.observable[:self.Nsys, :self.Nsys]\n    else:\n        num_qubits = self.Nqb\n        Obs_mat = self.observable\n\n    Obs_paulis_dic = tb.ham_to_pauli(Obs_mat, num_qubits, tol=tol)\n\n    # Prepare the Qiskit observable from the Pauli strings of the observable matrix.\n    data: List[str] = []\n    coef: List[float] = []\n    for key in Obs_paulis_dic:\n        data.append(key)\n        coef.append(Obs_paulis_dic[key])\n    obs_q = SparsePauliOp(data, coef)\n    return obs_q\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.init_statevec_Kraus","title":"<code>init_statevec_Kraus(tol=1e-06)</code>","text":"<p>Initialize state vectors from the initial density operator using the Kraus operator representation.</p> <p>The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues below the specified tolerance are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of</p> <code>List[float]</code> <p>corresponding probabilities.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def init_statevec_Kraus(self, tol: float = 1e-6) -&gt; Tuple[List[np.ndarray], List[float]]:\n    \"\"\"\n    Initialize state vectors from the initial density operator using the Kraus operator representation.\n\n    The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues\n    below the specified tolerance are ignored.\n\n    Args:\n        tol (float, optional): Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.\n\n    Returns:\n        Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of\n        corresponding probabilities.\n    \"\"\"\n    eigenvalues, eigenvectors = LA.eigh(self.rho0)\n    statevec: List[np.ndarray] = []\n    prob: List[float] = []\n    for i in range(len(eigenvalues) - 1, -1, -1):\n        if abs(eigenvalues[i]) &lt; tol:\n            break\n        prob.append(eigenvalues[i])\n        statevec.append(eigenvectors[:, i])\n    return statevec, prob\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.init_statevec_vecdens","title":"<code>init_statevec_vecdens()</code>","text":"<p>Initialize the state vector from the initial density operator using vectorized representation.</p> <p>The initial density matrix is reshaped into a vector and normalized.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm</p> <code>float</code> <p>of the original vectorized density matrix.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def init_statevec_vecdens(self) -&gt; Tuple[np.ndarray, float]:\n    \"\"\"\n    Initialize the state vector from the initial density operator using vectorized representation.\n\n    The initial density matrix is reshaped into a vector and normalized.\n\n    Returns:\n        Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm\n        of the original vectorized density matrix.\n    \"\"\"\n    vec_rho0 = self.rho0.reshape(self.Nsys**2)\n    norm0 = LA.norm(vec_rho0, 2)\n    statevec = vec_rho0 / norm0\n    return statevec, norm0\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.qc_simulation_kraus","title":"<code>qc_simulation_kraus(time_arr, shots=1024, Kraus=None, Gprop=None, tolk=1e-05, tolo=1e-05, **kwargs)</code>","text":"<p>Perform quantum simulation using the Kraus operator representation.</p> <p>This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach. It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator, and accumulates the measurement results.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>List of time steps for simulation.</p> required <code>shots</code> <code>int</code> <p>Number of shots for each measurement. Defaults to 1024.</p> <code>1024</code> <code>Kraus</code> <code>Optional[Dict[int, List[ndarray]]]</code> <p>Dictionary mapping time step index to a list of Kraus operators. If None, Kraus operators are generated from the propagator. Defaults to None.</p> <code>None</code> <code>Gprop</code> <code>Optional[List[ndarray]]</code> <p>Propagator matrix (or list of matrices) for simulation. If None, it will be calculated. Defaults to None.</p> <code>None</code> <code>tolk</code> <code>float</code> <p>Tolerance for generating Kraus operators. Defaults to 1e-5.</p> <code>1e-05</code> <code>tolo</code> <code>float</code> <p>Tolerance for observable decomposition. Defaults to 1e-5.</p> <code>1e-05</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for propagator calculation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array containing the quantum simulation results.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def qc_simulation_kraus(\n    self,\n    time_arr: List[float],\n    shots: int = 1024,\n    Kraus: Optional[Dict[int, List[np.ndarray]]] = None,\n    Gprop: Optional[List[np.ndarray]] = None,\n    tolk: float = 1e-5,\n    tolo: float = 1e-5,\n    **kwargs: Any\n) -&gt; np.ndarray:\n    \"\"\"\n    Perform quantum simulation using the Kraus operator representation.\n\n    This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach.\n    It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator,\n    and accumulates the measurement results.\n\n    Args:\n        time_arr (List[float]): List of time steps for simulation.\n        shots (int, optional): Number of shots for each measurement. Defaults to 1024.\n        Kraus (Optional[Dict[int, List[np.ndarray]]], optional): Dictionary mapping time step index to a list of Kraus operators.\n            If None, Kraus operators are generated from the propagator. Defaults to None.\n        Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n            If None, it will be calculated. Defaults to None.\n        tolk (float, optional): Tolerance for generating Kraus operators. Defaults to 1e-5.\n        tolo (float, optional): Tolerance for observable decomposition. Defaults to 1e-5.\n        **kwargs: Additional keyword arguments for propagator calculation.\n\n    Returns:\n        np.ndarray: Array containing the quantum simulation results.\n    \"\"\"\n    nsteps = len(time_arr)\n\n    # Generate Kraus operators if not provided.\n    if Kraus is None:\n        Kraus = {}\n        if Gprop is None:\n            print('Calculating the propagator')\n            Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n        print('Generating the Kraus operators')\n        for i in range(nsteps):\n            print('At step', i, 'of', nsteps)\n            Kraus[i] = gen_Kraus_list(Gprop[i], self.Nsys, tol=tolk)\n    print('Kraus operator generation complete')\n\n    # Perform Qiskit simulation using the Estimator.\n    estimator = Estimator()\n\n    statevec, prob = self.init_statevec_Kraus()\n    n_inistate = len(statevec)\n    print('Number of initial states in the density matrix:', n_inistate)\n    print('Probabilities:', prob)\n\n    # Obtain the Qiskit observable.\n    obs_q = self._get_qiskit_observable(Isdilate=True, tol=tolo)\n\n    print('Starting quantum simulation')\n    result_simulation = np.zeros(nsteps, dtype=np.float64)\n\n    for i in range(nsteps):\n        print('Simulation step', i, 'of', nsteps)\n        current_kraus_list = Kraus[i]\n        print('Number of Kraus operators:', len(current_kraus_list))\n        for kraus_op in current_kraus_list:\n            for istate in range(n_inistate):\n                qc = self._create_circuit(kraus_op, statevec[istate], Isscale=False)\n                result = estimator.run(qc, obs_q, shots=shots).result()\n                result_simulation[i] += result.values[0] * prob[istate]\n\n    return result_simulation\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.qc_simulation_vecdens","title":"<code>qc_simulation_vecdens(time_arr, shots=1024, backend=AerSimulator(), Gprop=None, **kwargs)</code>","text":"<p>Perform quantum simulation using the vectorized density matrix representation.</p> <p>This method simulates the quantum system dynamics over a series of time steps by constructing circuits based on the vectorized density matrix representation, performing measurements, and processing the results.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>List of time steps for simulation.</p> required <code>shots</code> <code>int</code> <p>Number of measurement shots. Defaults to 1024.</p> <code>1024</code> <code>backend</code> <code>Any</code> <p>Quantum simulation backend. Defaults to AerSimulator().</p> <code>AerSimulator()</code> <code>Gprop</code> <code>Optional[List[ndarray]]</code> <p>Propagator matrix (or list of matrices) for simulation. If None, it will be calculated. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for propagator calculation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array containing the quantum simulation results.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def qc_simulation_vecdens(\n    self,\n    time_arr: List[float],\n    shots: int = 1024,\n    backend: Any = AerSimulator(),\n    Gprop: Optional[List[np.ndarray]] = None,\n    **kwargs: Any\n) -&gt; np.ndarray:\n    \"\"\"\n    Perform quantum simulation using the vectorized density matrix representation.\n\n    This method simulates the quantum system dynamics over a series of time steps by constructing circuits\n    based on the vectorized density matrix representation, performing measurements, and processing the results.\n\n    Args:\n        time_arr (List[float]): List of time steps for simulation.\n        shots (int, optional): Number of measurement shots. Defaults to 1024.\n        backend (Any, optional): Quantum simulation backend. Defaults to AerSimulator().\n        Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n            If None, it will be calculated. Defaults to None.\n        **kwargs: Additional keyword arguments for propagator calculation.\n\n    Returns:\n        np.ndarray: Array containing the quantum simulation results.\n    \"\"\"\n    if Gprop is None:\n        Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n\n    nsteps = len(time_arr)\n\n    if self.count_str is None:\n        print(\"Error: count_str is not assigned\")\n\n    n_bitstr = len(self.count_str)\n    statevec, norm0 = self.init_statevec_vecdens()\n    result = np.zeros((nsteps, n_bitstr), dtype=np.float64)\n\n    for i in range(nsteps):\n        if i % 100 == 0:\n            print('Quantum simulation step', i)\n        Gt = Gprop[i]\n        circuit, norm = self._create_circuit(Gt, statevec, Isscale=True)\n        circuit.measure(range(self.Nqb + 1), range(self.Nqb + 1))\n        if self.dilation_method == 'SVD-Walsh':\n            circuit = transpile(circuit, backend)\n        counts = backend.run(circuit, shots=shots).result().get_counts()\n        for j in range(n_bitstr):\n            bitstr = self.count_str[j]\n            if bitstr in counts:\n                result[i, j] = np.sqrt(counts[bitstr] / shots) * norm * norm0\n            else:\n                print('At time', i, 'with shots =', shots, \"no counts for\", bitstr)\n\n    return result\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.set_count_str","title":"<code>set_count_str(count_str)</code>","text":"<p>Set the counting bit string for measurement.</p> <p>Parameters:</p> Name Type Description Default <code>count_str</code> <code>List[str]</code> <p>The counting bit string.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_count_str(self, count_str: List[str]) -&gt; None:\n    \"\"\"\n    Set the counting bit string for measurement.\n\n    Args:\n        count_str (List[str]): The counting bit string.\n    \"\"\"\n    self.count_str = count_str\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.set_dilation_method","title":"<code>set_dilation_method(method)</code>","text":"<p>Set the dilation method for quantum simulation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_dilation_method(self, method: str) -&gt; None:\n    \"\"\"\n    Set the dilation method for quantum simulation.\n\n    Args:\n        method (str): The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.\n    \"\"\"\n    self.dilation_method = method\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.QubitDynamicsOS.set_observable","title":"<code>set_observable(observable)</code>","text":"<p>Set the observable for the quantum simulation.</p> <p>Parameters:</p> Name Type Description Default <code>observable</code> <code>ndarray</code> <p>The observable matrix.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_observable(self, observable: np.ndarray) -&gt; None:\n    \"\"\"\n    Set the observable for the quantum simulation.\n\n    Args:\n        observable (np.ndarray): The observable matrix.\n    \"\"\"\n    self.observable = observable\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid","title":"<code>DVR_grid</code>","text":"<p>Class for Discrete Variable Representation (DVR) grid methods.</p> <p>This class handles grid-based representations for systems where the potential is expressed on grid points.</p> <p>Attributes:</p> Name Type Description <code>Ngrid</code> <code>int</code> <p>Number of grid points.</p> <code>xmin</code> <code>float</code> <p>Minimum value of the grid.</p> <code>xmax</code> <code>float</code> <p>Maximum value of the grid.</p> <code>mass</code> <code>float</code> <p>Mass of the particle.</p> <code>xgrid</code> <code>ndarray</code> <p>Array of grid points in position space.</p> <code>dx</code> <code>float</code> <p>Spacing between grid points.</p> <code>dk</code> <code>float</code> <p>Spacing in momentum space.</p> <code>kgrid</code> <code>ndarray</code> <p>Array of grid points in momentum space.</p> <code>ak2</code> <code>ndarray</code> <p>Kinetic energy array in momentum space.</p> <code>hamk</code> <code>ndarray</code> <p>Kinetic Hamiltonian matrix in position space.</p> <code>potential</code> <code>Optional[ndarray]</code> <p>Potential energy array on the grid.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>class DVR_grid:\n    \"\"\"Class for Discrete Variable Representation (DVR) grid methods.\n\n    This class handles grid-based representations for systems where the potential is expressed on grid points.\n\n    Attributes:\n        Ngrid (int): Number of grid points.\n        xmin (float): Minimum value of the grid.\n        xmax (float): Maximum value of the grid.\n        mass (float): Mass of the particle.\n        xgrid (np.ndarray): Array of grid points in position space.\n        dx (float): Spacing between grid points.\n        dk (float): Spacing in momentum space.\n        kgrid (np.ndarray): Array of grid points in momentum space.\n        ak2 (np.ndarray): Kinetic energy array in momentum space.\n        hamk (np.ndarray): Kinetic Hamiltonian matrix in position space.\n        potential (Optional[np.ndarray]): Potential energy array on the grid.\n    \"\"\"\n\n    def __init__(self, xmin: float, xmax: float, Ngrid: int, mass: float) -&gt; None:\n        \"\"\"\n        Initialize the DVR_grid instance.\n\n        Args:\n            xmin (float): Minimum x-value.\n            xmax (float): Maximum x-value.\n            Ngrid (int): Number of grid points.\n            mass (float): Mass of the particle.\n        \"\"\"\n        self.Ngrid: int = Ngrid\n        self.xmin: float = xmin\n        self.xmax: float = xmax\n        self.mass: float = mass\n\n        # Set up the position grid.\n        self.xgrid: np.ndarray = np.array([])\n        self._set_xgrid()\n        self.dx: float = self.xgrid[1] - self.xgrid[0]\n\n        # Set up the momentum grid.\n        self.dk: float = 2.0 * np.pi / (self.Ngrid * self.dx)\n        self.kgrid: np.ndarray = np.array([])\n        self.ak2: np.ndarray = np.array([])  # Kinetic energy array.\n        self.hamk: np.ndarray = np.array([])  # Kinetic Hamiltonian matrix.\n        self._set_kinet_ham()\n\n        # Potential energy array (to be set later).\n        self.potential: Optional[np.ndarray] = None\n\n    def _set_xgrid(self) -&gt; None:\n        \"\"\"\n        Set up the position space grid.\n\n        Initializes the `xgrid` attribute using a linear space between `xmin` and `xmax`.\n        \"\"\"\n        self.xgrid = np.linspace(self.xmin, self.xmax, self.Ngrid)\n\n    def set_potential(self, func_pot: Callable[[float], float]) -&gt; None:\n        \"\"\"\n        Set up the potential energy array on the grid.\n\n        Args:\n            func_pot (Callable[[float], float]): Function that returns the potential value at a given x.\n        \"\"\"\n        self.potential = np.zeros_like(self.xgrid)\n        for i in range(self.Ngrid):\n            self.potential[i] = func_pot(self.xgrid[i])\n\n    def _set_kinet_ham(self) -&gt; None:\n        \"\"\"\n        Set up the kinetic Hamiltonian matrix in position space.\n\n        This method computes the momentum grid and the corresponding kinetic energy values,\n        and constructs the kinetic Hamiltonian matrix in position space using a Fourier transform.\n        \"\"\"\n        self.kgrid = np.zeros(self.Ngrid, dtype=np.float64)\n        self.ak2 = np.zeros(self.Ngrid, dtype=np.float64)\n\n        coef_k: float = pa.hbar**2 / (2.0 * self.mass)\n\n        for i in range(self.Ngrid):\n            if i &lt; self.Ngrid // 2:\n                self.kgrid[i] = i * self.dk\n            else:\n                self.kgrid[i] = -(self.Ngrid - i) * self.dk\n            self.ak2[i] = coef_k * self.kgrid[i]**2\n\n        akx0: np.ndarray = sfft.ifft(self.ak2)\n        self.hamk = np.zeros((self.Ngrid, self.Ngrid), dtype=np.complex128)\n\n        for i in range(self.Ngrid):\n            for j in range(self.Ngrid):\n                if i &lt; j:\n                    self.hamk[i, j] = akx0[i - j].conj()\n                else:\n                    self.hamk[i, j] = akx0[i - j]\n\n    def get_eig_state(self, Nstate: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Get the eigenstates for the potential in x-space.\n\n        Args:\n            Nstate (int): Number of eigenstates to output.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: A tuple containing:\n                - Eigenvalues (np.ndarray) for the first `Nstate` states.\n                - Eigenvectors (np.ndarray) for the first `Nstate` states, normalized by sqrt(dx).\n        \"\"\"\n        Mata: np.ndarray = self.hamk.copy()\n        for i in range(self.Ngrid):\n            Mata[i, i] += self.potential[i]\n\n        val, arr = LA.eigh(Mata)\n        return val[:Nstate], arr[:, :Nstate] / np.sqrt(self.dx)\n\n    def x2k_wave(self, psi: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform the wavefunction from position space to momentum space.\n\n        Args:\n            psi (np.ndarray): Wavefunction in position space.\n\n        Returns:\n            np.ndarray: Wavefunction in momentum space.\n        \"\"\"\n        return tb.x2k_wave(self.dx, psi)\n\n    def k2x_wave(self, psik: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform the wavefunction from momentum space to position space.\n\n        Args:\n            psik (np.ndarray): Wavefunction in momentum space.\n\n        Returns:\n            np.ndarray: Wavefunction in position space.\n        \"\"\"\n        return tb.k2x_wave(self.dx, psik)\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid.__init__","title":"<code>__init__(xmin, xmax, Ngrid, mass)</code>","text":"<p>Initialize the DVR_grid instance.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>Minimum x-value.</p> required <code>xmax</code> <code>float</code> <p>Maximum x-value.</p> required <code>Ngrid</code> <code>int</code> <p>Number of grid points.</p> required <code>mass</code> <code>float</code> <p>Mass of the particle.</p> required Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def __init__(self, xmin: float, xmax: float, Ngrid: int, mass: float) -&gt; None:\n    \"\"\"\n    Initialize the DVR_grid instance.\n\n    Args:\n        xmin (float): Minimum x-value.\n        xmax (float): Maximum x-value.\n        Ngrid (int): Number of grid points.\n        mass (float): Mass of the particle.\n    \"\"\"\n    self.Ngrid: int = Ngrid\n    self.xmin: float = xmin\n    self.xmax: float = xmax\n    self.mass: float = mass\n\n    # Set up the position grid.\n    self.xgrid: np.ndarray = np.array([])\n    self._set_xgrid()\n    self.dx: float = self.xgrid[1] - self.xgrid[0]\n\n    # Set up the momentum grid.\n    self.dk: float = 2.0 * np.pi / (self.Ngrid * self.dx)\n    self.kgrid: np.ndarray = np.array([])\n    self.ak2: np.ndarray = np.array([])  # Kinetic energy array.\n    self.hamk: np.ndarray = np.array([])  # Kinetic Hamiltonian matrix.\n    self._set_kinet_ham()\n\n    # Potential energy array (to be set later).\n    self.potential: Optional[np.ndarray] = None\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid._set_kinet_ham","title":"<code>_set_kinet_ham()</code>","text":"<p>Set up the kinetic Hamiltonian matrix in position space.</p> <p>This method computes the momentum grid and the corresponding kinetic energy values, and constructs the kinetic Hamiltonian matrix in position space using a Fourier transform.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def _set_kinet_ham(self) -&gt; None:\n    \"\"\"\n    Set up the kinetic Hamiltonian matrix in position space.\n\n    This method computes the momentum grid and the corresponding kinetic energy values,\n    and constructs the kinetic Hamiltonian matrix in position space using a Fourier transform.\n    \"\"\"\n    self.kgrid = np.zeros(self.Ngrid, dtype=np.float64)\n    self.ak2 = np.zeros(self.Ngrid, dtype=np.float64)\n\n    coef_k: float = pa.hbar**2 / (2.0 * self.mass)\n\n    for i in range(self.Ngrid):\n        if i &lt; self.Ngrid // 2:\n            self.kgrid[i] = i * self.dk\n        else:\n            self.kgrid[i] = -(self.Ngrid - i) * self.dk\n        self.ak2[i] = coef_k * self.kgrid[i]**2\n\n    akx0: np.ndarray = sfft.ifft(self.ak2)\n    self.hamk = np.zeros((self.Ngrid, self.Ngrid), dtype=np.complex128)\n\n    for i in range(self.Ngrid):\n        for j in range(self.Ngrid):\n            if i &lt; j:\n                self.hamk[i, j] = akx0[i - j].conj()\n            else:\n                self.hamk[i, j] = akx0[i - j]\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid._set_xgrid","title":"<code>_set_xgrid()</code>","text":"<p>Set up the position space grid.</p> <p>Initializes the <code>xgrid</code> attribute using a linear space between <code>xmin</code> and <code>xmax</code>.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def _set_xgrid(self) -&gt; None:\n    \"\"\"\n    Set up the position space grid.\n\n    Initializes the `xgrid` attribute using a linear space between `xmin` and `xmax`.\n    \"\"\"\n    self.xgrid = np.linspace(self.xmin, self.xmax, self.Ngrid)\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid.get_eig_state","title":"<code>get_eig_state(Nstate)</code>","text":"<p>Get the eigenstates for the potential in x-space.</p> <p>Parameters:</p> Name Type Description Default <code>Nstate</code> <code>int</code> <p>Number of eigenstates to output.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: A tuple containing: - Eigenvalues (np.ndarray) for the first <code>Nstate</code> states. - Eigenvectors (np.ndarray) for the first <code>Nstate</code> states, normalized by sqrt(dx).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def get_eig_state(self, Nstate: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Get the eigenstates for the potential in x-space.\n\n    Args:\n        Nstate (int): Number of eigenstates to output.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: A tuple containing:\n            - Eigenvalues (np.ndarray) for the first `Nstate` states.\n            - Eigenvectors (np.ndarray) for the first `Nstate` states, normalized by sqrt(dx).\n    \"\"\"\n    Mata: np.ndarray = self.hamk.copy()\n    for i in range(self.Ngrid):\n        Mata[i, i] += self.potential[i]\n\n    val, arr = LA.eigh(Mata)\n    return val[:Nstate], arr[:, :Nstate] / np.sqrt(self.dx)\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid.k2x_wave","title":"<code>k2x_wave(psik)</code>","text":"<p>Transform the wavefunction from momentum space to position space.</p> <p>Parameters:</p> Name Type Description Default <code>psik</code> <code>ndarray</code> <p>Wavefunction in momentum space.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Wavefunction in position space.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def k2x_wave(self, psik: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform the wavefunction from momentum space to position space.\n\n    Args:\n        psik (np.ndarray): Wavefunction in momentum space.\n\n    Returns:\n        np.ndarray: Wavefunction in position space.\n    \"\"\"\n    return tb.k2x_wave(self.dx, psik)\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid.set_potential","title":"<code>set_potential(func_pot)</code>","text":"<p>Set up the potential energy array on the grid.</p> <p>Parameters:</p> Name Type Description Default <code>func_pot</code> <code>Callable[[float], float]</code> <p>Function that returns the potential value at a given x.</p> required Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def set_potential(self, func_pot: Callable[[float], float]) -&gt; None:\n    \"\"\"\n    Set up the potential energy array on the grid.\n\n    Args:\n        func_pot (Callable[[float], float]): Function that returns the potential value at a given x.\n    \"\"\"\n    self.potential = np.zeros_like(self.xgrid)\n    for i in range(self.Ngrid):\n        self.potential[i] = func_pot(self.xgrid[i])\n</code></pre>"},{"location":"qflux/Open_Systems/os_api/#qflux.open_systems.DVR_grid.x2k_wave","title":"<code>x2k_wave(psi)</code>","text":"<p>Transform the wavefunction from position space to momentum space.</p> <p>Parameters:</p> Name Type Description Default <code>psi</code> <code>ndarray</code> <p>Wavefunction in position space.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Wavefunction in momentum space.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def x2k_wave(self, psi: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform the wavefunction from position space to momentum space.\n\n    Args:\n        psi (np.ndarray): Wavefunction in position space.\n\n    Returns:\n        np.ndarray: Wavefunction in momentum space.\n    \"\"\"\n    return tb.x2k_wave(self.dx, psi)\n</code></pre>"},{"location":"qflux/Variational_Methods/var_api/","title":"Variational Methods  Module","text":""},{"location":"qflux/Variational_Methods/var_api/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>variational_methods</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/Variational_Methods/var_api/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/Variational_Methods/var_api/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/Variational_Methods/var_api/#source-code","title":"Source Code","text":""},{"location":"qflux/Variational_Methods/var_api/#qflux.variational_methods","title":"<code>qflux.variational_methods</code>","text":""},{"location":"qflux/Variational_Methods/variational_methods/","title":"Variational Methods  Module","text":""},{"location":"qflux/Variational_Methods/variational_methods/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>variational_methods</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/Variational_Methods/variational_methods/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/Variational_Methods/variational_methods/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/Variational_Methods/variational_methods/#source-code","title":"Source Code","text":""},{"location":"qflux/Variational_Methods/variational_methods/#qflux.variational_methods","title":"<code>qflux.variational_methods</code>","text":""}]}