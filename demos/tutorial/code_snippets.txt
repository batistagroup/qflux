\noindent\begin{codeInput}{python}{QFlux Simulation using Runge-Kutta Integration/SOFT}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/Part_I_qflux.ipynb}{\faIcon{external-link-alt}}}{package_RK_SOFT}
from QFlux.Closed_Systems import QFlux_CS

qho_dyn_obj = QFlux_CS_qubits(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=0.2)
qho_dyn_obj.set_coordinate_operators()
qho_dyn_obj.initialize_operators()
qho_dyn_obj.set_initial_state(wfn_omega=0.2)

total_time = 20.0
N_steps    = 400

qho_dyn_obj.set_propagation_time(total_time, N_steps)
qho_dyn_obj.set_hamiltonian(potential_type='harmonic')
qho_dyn_obj.propagate_qt()
qho_dyn_obj.propagate_SOFT()
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{SOFT Operators for Harmonic Oscillator}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{soft_operators}
import numpy as np

def get_harmonic_potential(x, x_0=0.0, mass=1, omega=1):
    return mass * omega**2 * (x - x_0)**2 / 2

def get_kinetic_energy(p, mass=1):
    return  p**2/2/mass

# operators
Vx_harm = get_harmonic_potential(xgrid)
K_harm = get_kinetic_energy(pgrid, mass)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{SOFT Propagation}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{soft_ex}
import numpy as np
from tqdm.notebook import trange

def get_propagator_on_grid(operator_grid, tau, hbar=1):
    # operator_grid: a numpy array, expressing the operator on a grid
    # tau: the time step for propagation (in atomic units of time)
    return np.exp(-1.0j * operator_grid * tau / hbar)

def do_SOFT_propagation(psi, K_prop, V_prop):
    # np.fft.fft and np.fft.ifft requires specific ordering of outputs/inputs
    psi_t_position_grid = V_prop * psi
    psi_t_momentum_grid = K_prop * np.fft.fft(psi_t_position_grid, norm="ortho")
    psi_t = V_prop * np.fft.ifft(psi_t_momentum_grid, norm="ortho")
    return psi_t

tmin = 0.0
tmax = 20.0
N_tsteps = 400

# grid preparation and spacing
tgrid = np.linspace(tmin, tmax, N_tsteps)
tau = tgrid[1] - tgrid[0]

print("For ", tmax, " a.u. using a timestep of ",tau," a.u.")

V_prop = get_propagator_on_grid(Vx_harm/2, tau)
K_prop = get_propagator_on_grid(K_harm, tau)

propagated_states_harm = [psi_0]
psi_t = psi_0
for tstep_idx in trange(len(tgrid)):
    psi_t = do_SOFT_propagation(psi_t, K_prop, V_prop)
    propagated_states_harm.append(psi_t)

propagated_states_harm = np.array(propagated_states_harm)[:-1]
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Harmonic oscillator expectation values}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{soft_harm_plot}
def position_expectation_value(xgrid, psi):
    dx = xgrid[1]-xgrid[0]
    return dx*np.real(np.sum(xgrid * np.conjugate(psi) * psi))

def momentum_expectation_value(dx,pgrid, psi):
    psip = np.fft.fft(psi)
    return dx*np.real(np.sum(pgrid * np.conjugate(psip) * psip))/len(psi)

avxgrid_harm_soft = [position_expectation_value(xgrid,propagated_states_harm[i]) for i in range(len(propagated_states_harm))]
dx = xgrid[1]-xgrid[0]
avpgrid_harm_soft = [momentum_expectation_value(dx,pgrid,propagated_states_harm[i]) for i in range(len(propagated_states_harm))]

avxgrid_harm_ana = [ x_0*np.cos(omega*t) + (p_0/mass/omega)*np.sin(omega*t) for t in tgrid]
avpgrid_harm_ana = [ -x_0*omega*mass*np.sin(omega*t) + p_0*np.cos(omega*t) for t in tgrid]

fig, ax = plt.subplots()
ax.plot(tgrid, avxgrid_harm_ana, '-', color='blue',label='<x> analytical', zorder=0)
ax.plot(tgrid[::4], avxgrid_harm_soft[::4], 'o', color='blue',label='<x> SOFT', zorder=0, markeredgecolor='blue', fillstyle='full', markerfacecolor='white')
ax.plot(tgrid, avpgrid_harm_ana, '-', color='red',label='<p> analytical')
ax.plot(tgrid[::4], avpgrid_harm_soft[::4], 'o', color='red',label='<p> SOFT', markeredgecolor='red', fillstyle='full', markerfacecolor='white', zorder=0)

ax.axhline(-1, ls='--', lw=0.5, color='black', alpha=0.5)
ax.axhline( 0, ls='--', lw=0.5, color='black', alpha=0.5)
ax.axhline( 1, ls='--', lw=0.5, color='black', alpha=0.5)
ax.set_xlabel('time, a.u.', fontsize=14)
ax.set_ylabel('Expectation value', fontsize=14)
ax.tick_params(labelsize=12, grid_alpha=0.5)
plt.ylim(-1.5,2)
plt.legend(fontsize=12,loc='upper center', ncol=2)
plt.show()
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Installing Qiskit and Importing  Packages}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{qiskit_packages}
!pip install qiskit
!pip install qiskit-ibm-runtime
!pip install qiskit-aer
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import axes
from tqdm.notebook import trange
import scipy.linalg as LA
from qiskit.circuit.library import QFT
from qiskit_aer import Aer
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit.quantum_info.operators import Operator
from qiskit_ibm_runtime import QiskitRuntimeService, Options, SamplerV2
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum Circuit of a Bell State}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{Bell_state}
from qiskit_aer import Aer
from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_histogram

# Create a quantum circuit with 2 qubits and 2 classical bits
qc = QuantumCircuit(2, 2)

# Apply Hadamard gate to the first qubit
qc.h(0)

# Apply CNOT gate with qubit 0 as control and qubit 1 as target
qc.cx(0, 1)

# Measure the qubits
qc.measure([0, 1], [0, 1])

# Visualize the circuit
print(qc.draw())

# Simulate the circuit
simulator = Aer.get_backend('aer_simulator')
compiled_circuit = transpile(qc, simulator)
result = simulator.run(compiled_circuit).result()

# Get the measurement results
counts = result.get_counts()
plot_histogram(counts)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{1D PES for A-T tautomerization}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{AT_potential}
def get_doublewell_potential(x, x0=1.9592, f=ev2au, a0=0.0, a1=0.429, a2=-1.126, a3=-0.143, a4=0.563):
    # A-T pair double-well potential in Hartrees (x is in Bohr)
    xi = x/x0
    return f*(a0 + a1*xi + a2*xi**2 + a3*xi**3 + a4*xi**4)

def get_doublewell_potential_second_deriv(x, x0=1.9592, f=ev2au, a0=0.0, a1=0.429, a2=-1.126, a3=-0.143, a4=0.563):
    # A-T pair double-well potential in Hartrees (x is in Bohr)
    return f*(2*a2/x0**2 + 6*a3*x/x0**3 + 12*a4*x**2/x0**4)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{QFlux Simulation using QSOFT}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/Part_I_qflux.ipynb}{\faIcon{external-link-alt}}}{package_QSOFT}
from QFlux.Closed_Systems import QFlux_CS_qubits
from ../utils import get_proton_mass, convert_fs_to_au

proton_mass = get_proton_mass()
x0      = 1.9592
N_steps = 3000

omega = np.sqrt(get_doublewell_potential_second_deriv(x0)/proton_mass)
AT_dyn_obj  = QFlux_CS_qubits(n_basis=128, xo=1.5*x0, mass=proton_mass, omega=omega)

AT_dyn_obj.set_coordinate_operators(x_min=-4.0, x_max=4.0)
AT_dyn_obj.initialize_operators()
AT_dyn_obj.set_initial_state(wfn_omega=omega)

total_time = convert_fs_to_au(30.0)
AT_dyn_obj.set_propagation_time(total_time, N_steps)
AT_dyn_obj.set_hamiltonian(potential_type='quartic')
# frequency corresponding to the right well (in atomic units)
AT_dyn_obj.propagate_SOFT()
AT_dyn_obj.propagate_qt()
AT_dyn_obj.propagate_qSOFT()
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Gaussian initial wavepacket}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{AT_initial}
# initial coherent state in the right well centered at x/x0 = 1.5
x_0 = 1.5*x0
p_0 = 0.0
psi_0 = get_coherent_state(xgrid, p_0, x_0, mass, omega)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Preparation of potential and kinetic split propagators}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{AT_propagators}
x0 = 1.9592
xmin = -4.
xmax = 4.
Nq = 6 # number of qubits
N_xpts = 2**Nq

# mass of the proton in units of electron mass
mass = mass_proton

# frequency corresponding to the right well (in atomic units)
omega = np.sqrt(get_doublewell_potential_second_deriv(x0)/mass)

# grid preparation and spacing
xgrid = get_xgrid(xmin, xmax, N_xpts)
pgrid = get_pgrid(xmin, xmax, N_xpts, reorder=True)

dx = xgrid[1] - xgrid[0]
dp = pgrid[1] - pgrid[0]

VV = get_doublewell_potential(xgrid) - get_doublewell_potential(x0) - omega/2

tmin = 0.0
tmax = 30.0*fs2au
iterations = 3000

# time grid preparation and spacing
tgrid = np.linspace(tmin, tmax, iterations)
time_step = tgrid[1] - tgrid[0]

# propagators (note that potential energy is divided by two)
VVd_prop = np.diag(np.exp(-1j*VV/2*time_step))
KEd_prop = np.diag(np.exp(-1j*pgrid**2/2/mass*time_step)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum SOFT Circuit Preparation}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{AT_qubits_circuit}
import scipy.linalg as LA
from qiskit.circuit.library import QFT
from qiskit_aer import Aer
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit.quantum_info.operators import Operator
from qiskit_ibm_runtime import QiskitRuntimeService, Options, SamplerV2
from tqdm.notebook import trange

# Initialize an Empty Circuit
nqubits = Nq
q_reg = QuantumRegister(nqubits)
c_reg = ClassicalRegister(nqubits)
qc = QuantumCircuit(q_reg)

qc.initialize(psi_0, q_reg[:],normalize=True)

for k in trange(iterations):
    bound_op = Operator(V_prop)
    qc.append(bound_op, q_reg)
    qc.append(QFT(d,do_swaps=True,inverse=False),q_reg)
    bound_op = Operator(K_prop)
    qc.append(bound_op, q_reg)
    qc.append(QFT(d,do_swaps=True,inverse=True),q_reg)
    bound_op = Operator(V_prop)
    qc.append(bound_op, q_reg)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum SOFT circuit execution}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{AT_circuit_execute}
from qiskit import QuantumCircuit, transpile
from qiskit_aer import Aer

def execute(QCircuit, backend=None, shots=None):
    '''
        Function to replace the now-deprecated Qiskit
        `QuantumCircuit.execute()` method.

        Input:
          - `QCircuit`: qiskit.QuantumCircuit object
          - `Backend`: qiskit.Backend instance
          - `shots`: int specifying the number of shots
    '''
    # Transpile circuit with statevector backend
    tmp_circuit = transpile(QCircuit, backend)
    # Run the transpiled circuit
    if shots:
        job = backend.run(tmp_circuit, n_shots=shots)
    else:
        job = backend.run(tmp_circuit)
    return(job)

backend = Aer.get_backend('statevector_simulator')
executed_circuit = execute(qc, backend=backend, shots=1024)

psin = executed_circuit.result().get_statevector().data
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Classical SOFT Benchmark}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{AT_benchmark}
# SOFT propagation
propagated_states = [psi_0]
psi_t = psi_0

for tstep_idx in trange(len(tgrid)):
    psi_t = do_SOFT_propagation(psi_t, K_prop, V_prop)
    propagated_states.append(psi_t)

propagated_states = np.array(propagated_states)[:-1]
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Plotting initial and final wavefunctions}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{AT_qubits_plot}
# Visualization
from scipy.interpolate import interp1d

x_dense = np.linspace(xgrid[0], xgrid[-1], 512)
f_interp = interp1d(xgrid, get_prob_density(propagated_states[-1]), kind='cubic')
rho_interp = f_interp(x_dense)

fig, ax = plt.subplots()
ax.plot(xgrid, Vx_DW - get_doublewell_potential(x0) - omega/2, '-',color='black',label='A-T pair potential')
ax.plot(xgrid, 0.04*np.real(get_prob_density(psi_0)),'--',color='red',label='Initial coherent state')
ax.plot(x_dense, 0.04*rho_interp,'-',color='blue',label='(SOFT) State at t = 30 fs',zorder=0,markeredgecolor='blue',fillstyle='full',markerfacecolor='white')
ax.plot(xgrid, 0.04*np.real(psin.conj()*psin/dx),'o',color='blue',label='(Qiskit) State at t = 30 fs', markevery=1, alpha=0.25)
ax.axhline(0, lw=0.5, color='black', alpha=1.0)
ax.axvline(-x0, lw=0.5, color='black', alpha=0.5)
ax.axvline(x0, lw=0.5, color='black', alpha=0.5)
ax.axvline(x0*1.5, lw=0.5, color='red', alpha=0.5)
ax.set_xlabel('x, Bohr',fontsize=14)
ax.set_ylabel('Energy, Hartrees',fontsize=14)
ax.tick_params(labelsize=12, grid_alpha=0.5)
plt.ylim(-0.03,0.07)
plt.legend(fontsize=12,loc='upper center')
plt.show()
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum Circuit for \( e^{-i t Z \otimes \cdots \otimes Z} \)}{\href{https://colab.research.google.com/githubbatistagroup/qflux/blob/master/demos/tutorial/Part_I_appendixA.ipynb}{\faIcon{external-link-alt}}}{expZs}
from qiskit import QuantumCircuit, QuantumRegister

def exp_all_z(circuit, quantum_register, pauli_indexes, control_qubit=None, t=1):
    """
    Implements \( e^{-i t Z \otimes \cdots \otimes Z} \) on specified qubits.
    
    Args:
        circuit (QuantumCircuit): The circuit to modify.
        quantum_register (QuantumRegister): Register containing target qubits.
        pauli_indexes (list): Indices of qubits where \( Z \) acts.
        control_qubit (Qubit, optional): Optional control qubit for conditional application.
        t (float): Evolution time.
    
    Returns:
        QuantumCircuit: Updated circuit with the operation applied.
    """
    if control_qubit and control_qubit.register not in circuit.qregs:
        circuit.add_register(control_qubit.register)

    if not pauli_indexes:
        if control_qubit:
            circuit.p(t, control_qubit)  # Phase gate
        return circuit

    # Parity computation
    for i in range(len(pauli_indexes) - 1):
        circuit.cx(quantum_register[pauli_indexes[i]], quantum_register[pauli_indexes[i + 1]])

    # Apply phase rotation
    target = quantum_register[pauli_indexes[-1]]
    angle = -2 * t
    if control_qubit:
        circuit.crz(angle, control_qubit, target)
    else:
        circuit.rz(angle, target)

    # Uncompute parity
    for i in reversed(range(len(pauli_indexes) - 1)):
        circuit.cx(quantum_register[pauli_indexes[i]], quantum_register[pauli_indexes[i + 1]])

    return circuit
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum Circuit for \( e^{-i t P} \)}{\href{https://colab.research.google.com/githubbatistagroup/qflux/blob/master/demos/tutorial/Part_I_appendixA.ipynb}{\faIcon{external-link-alt}}}{expP}
import numpy as np
from qiskit import QuantumCircuit, QuantumRegister

def exp_pauli(pauli, quantum_register, control_qubit=None, t=1):
    """
    Implements \( e^{-i t P} \) for a Pauli string \( P \).
    
    Args:
        pauli (str): Pauli string (e.g., "XIZY").
        quantum_register (QuantumRegister): Target register.
        control_qubit (Qubit, optional): Optional control qubit.
        t (float): Evolution time.
    
    Returns:
        QuantumCircuit: Circuit implementing the Pauli evolution.
    """
    if len(pauli) != len(quantum_register):
        raise ValueError("Pauli string length must match register size.")
    
    pauli_indexes = []
    pre_circuit = QuantumCircuit(quantum_register)
    
    for i, op in enumerate(pauli):
        if op == 'I':
            continue
        elif op == 'X':
            pre_circuit.h(i)
            pauli_indexes.append(i)
        elif op == 'Y':
            pre_circuit.rx(np.pi/2, i)
            pauli_indexes.append(i)
        elif op == 'Z':
            pauli_indexes.append(i)
        else:
            raise ValueError(f"Invalid Pauli operator '{op}' at position {i}.")
    
    circuit = QuantumCircuit(quantum_register)
    circuit.compose(pre_circuit, inplace=True)
    circuit = exp_all_z(circuit, quantum_register, pauli_indexes, control_qubit, t)
    circuit.compose(pre_circuit.inverse(), inplace=True)
    return circuit
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum Circuit for \( e^{-i H t} \)}{\href{https://colab.research.google.com/githubbatistagroup/qflux/blob/master/demos/tutorial/Part_I_appendixA.ipynb}{\faIcon{external-link-alt}}}{expH}
from qiskit import QuantumCircuit, QuantumRegister

def hamiltonian_simulation(hamiltonian, quantum_register=None, control_qubit=None, t=1, trotter_number=1):
    """
    Implements \( e^{-i H t} \) using first-order Trotterization.
    
    Args:
        hamiltonian (dict): Pauli terms with coefficients (e.g., {"ZZ": 0.5, "XX": 0.3}).
        quantum_register (QuantumRegister, optional): Target register.
        control_qubit (Qubit, optional): Optional control qubit.
        t (float): Simulation time.
        trotter_number (int): Number of Trotter steps.
    
    Returns:
        QuantumCircuit: Trotterized Hamiltonian evolution circuit.
    """
    if not hamiltonian:
        raise ValueError("Hamiltonian must contain at least one term.")
    
    n_qubits = len(next(iter(hamiltonian)))
    if quantum_register is None:
        quantum_register = QuantumRegister(n_qubits)
    
    delta_t = t / trotter_number
    circuit = QuantumCircuit(quantum_register)
    
    for pauli_str, coeff in hamiltonian.items():
        term_circuit = exp_pauli(pauli_str, quantum_register, control_qubit, coeff * delta_t)
        circuit.compose(term_circuit, inplace=True)
    
    full_circuit = QuantumCircuit(quantum_register)
    for _ in range(trotter_number):
        full_circuit.compose(circuit, inplace=True)
    
    return full_circuit
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Test Code for Hamiltonian Simulation}{\href{https://colab.research.google.com/githubbatistagroup/qflux/blob/master/demos/tutorial/Part_I_appendixA.ipynb}{\faIcon{external-link-alt}}}{testexpH}
from qiskit_aer import Aer
from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_histogram

# Initialize circuit
qr=QuantumRegister(2)
qc = QuantumCircuit(qr)

# Define Hamiltonian: H = 0.5 * ZZ + 0.3 * YY
hamiltonian = {
    "ZZ": 0.5,
    "YY": 0.3,
}
# Build the Hamiltonian evolution circuit
t = np.pi / 4  # evolution time
trotter_steps = 1
U = hamiltonian_simulation(hamiltonian, quantum_register=qr, t=t, trotter_number=trotter_steps)

# Initialize a uniform superposition, add propagator and measurements
qc.h(qr)
qc.append(U,qr)
qc.measure_all()

# Simulate circuit
sim = Aer.get_backend("aer_simulator")
qobj = transpile(qc, sim)
result = sim.run(qobj).result()
counts = result.get_counts()
# Plot the result
print("Measurement counts:", counts)

# Draw circuit
qc.decompose().draw()
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{2-site Heisenberg spin chain Hamiltonian and propagator}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{spin_chain_2_Hamiltonian}
J = 1
h0 = -0.5
h1 = 0.5
X = np.array([[0,1],[1,0]], dtype = complex)
Y = np.array([[0,1j],[1j,0]], dtype = complex)
Z = np.array([[1,0],[0,-1]], dtype = complex)
I = np.array([[1,0],[0,1]], dtype = complex)
H = 0.5*(h0*np.kron(Z, I) + h1*np.kron(I, Z)) + J/4*(np.kron(X, X) + np.kron(Y, Y) + np.kron(Z, Z))
U = LA.expm(-1j * H)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Classical propagation of 2-site Heisenberg chain}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{spin_chain_2_propagation}
psi_init = np.array([1,0,0,0],dtype = complex)
psi_fin = U @ psi_init
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum circuit for the 2-site Heisenberg chain propagation--initiation}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{spin_chain_2_quantum_circuit_init}
qreg=QuantumRegister(2) # qreg is filled with two qubits
creg=ClassicalRegister(2) # creg is filled with two classical bits
entangler=QuantumCircuit(qreg,creg) # we put together our qreg and creg to make our Quantum Circuit, called entangler here.
#entangler.initialize(psi_init)  #Not necessary since we start at |00>
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum circuit for the 2-site Heisenberg chain propagation--gate construction}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{spin_chain_2_quantum_circuit_construction}
U_gate = Operator(U)
entangler.append(U_gate,[0,1])
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum circuit for the 2-site Heisenberg chain propagation--measurement}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{spin_chain_2_quantum_circuit_measurement}
# measure the first qubit and record it in the first classical bit
entangler.measure(0,0)
entangler.measure(1,1)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Accessing IBM account from API token}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{IBM_account_token}
from qiskit_ibm_runtime import QiskitRuntimeService

try:
    # Save an IBM Quantum account.
    # https://docs.quantum.ibm.com/api/qiskit-ibm-runtime
    QiskitRuntimeService.save_account(channel="ibm_quantum", token="MY_IBM_QUANTUM_TOKEN")
    QiskitRuntimeService.load_account()
    use_IBMQ = True
except:
    print('No API token provided')
    use_IBMQ = False
    pass
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Run dynamics with QASM simulator}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{dynamics_QASM}
if use_IBMQ:
    service = QiskitRuntimeService()
    options = Options()
    backend = service.backend("ibmq_qasm_simulator")
    sampler = Sampler(options=options, backend=backend)
    job = sampler.run(circuits=entangler, shots=2000)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Execute Quantum Circuit on QASM simulator}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{dynamics_QASM_measure}
if use_IBMQ:
    qasm_result = np.zeros((4,))
    qasm_result[0] = job.result().quasi_dists[0][0]
    qasm_result[3] = job.result().quasi_dists[0][3]
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Execute Quantum Circuit on Quantum Hardware}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{dynamics_QASM_measure_2}
if use_IBMQ:
    backend = service.backend("ibm_osaka")
    sampler = Sampler(options=options, backend=backend)
    job = sampler.run(circuits=entangler, shots=2000)
    real_result = np.zeros((4,))
    real_result[0] = job.result().quasi_dists[0][0]
    real_result[1] = job.result().quasi_dists[0][1]
    real_result[2] = job.result().quasi_dists[0][2]
    real_result[3] = job.result().quasi_dists[0][3]
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{QFlux Simulation for Spin Chain using Statevector}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/Part_I_qflux.ipynb}{\faIcon{external-link-alt}}}{package_spinchain_statevector}
from QFlux.Closed_Systems.spin_dynamics_oo import QuantumDynamicsClassicalSimulation

num_q = 3
evolution_timestep = 0.1
n_trotter_steps = 1
hamiltonian_coefficients = [[0.75 / 2, 0.75 / 2, 0.0, 0.65]] + [
    [0.5, 0.5, 0.0, 1.0] for _ in range(num_q - 1)
]
initial_state = "011"  # Specify the initial state as a binary string

csimulation = QuantumDynamicsClassicalSimulation(
    num_q,
    evolution_timestep,
    n_trotter_steps,
    hamiltonian_coefficients,
)
csimulation.run_dynamics(nsteps=250, state_string=initial_state)
csimulation.save_results(f"{num_q}_spin_chain")
csimulation.plot_results(f"{num_q}_spin_chain_statevector")
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Heisenberg Hamiltonian for site $n$}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{heisenberg}
from qiskit.quantum_info import SparsePauliOp

def get_hamiltonian_n_site_terms(n, coeff, n_qubits):
    '''
        Assembles each term in the Hamiltonian based on their Pauli string
        representation and multiplying by the respective coefficient.
    '''
    XX_coeff = coeff[0]
    YY_coeff = coeff[1]
    ZZ_coeff = coeff[2]
    Z_coeff = coeff[3]

    XX_term = SparsePauliOp(("I" * n + "XX" + "I" * (n_qubits - 2 - n)))
    XX_term *= XX_coeff
    YY_term = SparsePauliOp(("I" * n + "YY" + "I" * (n_qubits - 2 - n)))
    YY_term *= YY_coeff
    ZZ_term = SparsePauliOp(("I" * n + "ZZ" + "I" * (n_qubits - 2 - n)))
    ZZ_term *= ZZ_coeff
    Z_term = SparsePauliOp(("I" * n + "Z" + "I" * (n_qubits - 1 - n)))
    Z_term *= Z_coeff

    return (XX_term + YY_term + ZZ_term + Z_term)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Heisenberg Hamiltonian for $N$ Sites}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{heisenberg2}
def get_heisenberg_hamiltonian(n_qubits, coeff=None):
    '''
    Constructs the Heisenberg Hamiltonian for an N-site spin chain.

    H = \sum _i ^N h_z Z_i
        + \sum _i ^{N-1} (h_xx X_iX_{i+1}
            + h_yy Y_iY_{i+1}
            + h_zz Z_iZ_{i+1}
            )

    Parameters:
        n_qubits (int): Number of spins/qubits.
        coeff (list of lists, optional): A list of sublists containing the coefficients
            [XX, YY, ZZ, Z] for each site. The last sublist contains only the Z component.
            Defaults to uniform coefficients if not provided.

    Returns:
        list: Two components of the Hamiltonian (even and odd terms).
    '''

    # Three qubits because for 2 we get H_O = 0
    assert n_qubits >= 3

    if coeff == None:
        'Setting default values for the coefficients'
        coeff = [[1.0, 1.0, 1.0, 1.0] for i in range(n_qubits)]

    # Even terms of the Hamiltonian
    # (summing over individual pair-wise elements)
    H_E = sum((get_hamiltonian_n_site_terms(i, coeff[i], n_qubits)
               for i in range(0, n_qubits-1, 2)))

    # Odd terms of the Hamiltonian
    # (summing over individual pair-wise elements)
    H_O = sum((get_hamiltonian_n_site_terms(i, coeff[i], n_qubits)
               for i in range(1, n_qubits-1, 2)))

    # adding final Z term at the Nth site
    final_term = SparsePauliOp("I" * (n_qubits - 1) + "Z")
    final_term *= coeff[n_qubits-1][3]
    if (n_qubits % 2) == 0:
        H_E += final_term
    else:
        H_O += final_term

    # Returns the list of the two sets of terms
    return [H_E, H_O]
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Heisenberg Hamiltonian 3 Sites}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{printXX_ham}
num_q = 3
# XX YY ZZ, Z
ham_coeffs = ([[0.75/2, 0.75/2, 0.0, 0.65]]+
              [[0.5, 0.5, 0.0, 1.0] for _ in range(num_q-1)])

spin_chain_hamiltonian = get_heisenberg_hamiltonian(num_q, ham_coeffs)

print('Hamiltonian (even and odd components):',spin_chain_hamiltonian)
print('Combined Hamiltonian:', sum(spin_chain_hamiltonian))
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Trotterized Time Evolution Operator}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{trotter_time_evo}
from qiskit.circuit.library import PauliEvolutionGate
from qiskit.synthesis import SuzukiTrotter
from qiskit import QuantumCircuit, QuantumRegister
import numpy as np
from itertools import groupby
import re

def get_time_evolution_operator(num_qubits, tau, trotter_steps, coeff=None):
    '''
    Generates the Trotterized time-evolution operator for a Heisenberg spin chain
        
        Inputs:
            num_qubits (int): number of qubits, which should be equal to the
                number of spins in the chain
            evo_time (float): time parameter in time-evolution operator
            trotter_steps (int): number of time steps for the Suzuki-Trotter
                decomposition
            coeff (list of lists): parameters for each term in the Hamiltonian
                for each site ie ([[XX0, YY0, ZZ0, Z0], [XX1, YY1, ZZ1, Z1], ...])
        Returns:
            evo_op.definition: Trotterized time-evolution operator
    '''
    # Heisenberg_hamiltonian = [H_E, H_O]
    heisenberg_hamiltonian = get_heisenberg_hamiltonian(num_qubits, coeff)

    # e^ (-i*H*evo_time), with Trotter decomposition
    # exp[(i*evo_time)*(IIIIXXIIII + IIIIYYIIII + IIIIZZIIII + IIIIZIIIII)]
    evo_op = PauliEvolutionGate(heisenberg_hamiltonian, tau,
                                synthesis=SuzukiTrotter(order=2,
                                reps=trotter_steps))
    return evo_op.definition

num_shots = 100
num_q = 3
evolution_timestep = 0.1
n_trotter_steps = 1
# XX YY ZZ, Z
ham_coeffs = ([[0.75/2, 0.75/2, 0.0, 0.65]]
                + [[0.5, 0.5, 0.0, 1.0]
                for i in range(num_q-1)])
time_evo_op = get_time_evolution_operator(
    num_qubits=num_q, tau=evolution_timestep,
    trotter_steps=n_trotter_steps, coeff=ham_coeffs)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Sorting Terms by Interaction order}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{sort_interaction_terms}
def find_string_pattern(pattern, string):
    match_list = []
    for m in re.finditer(pattern, string):
        match_list.append(m.start())
    return match_list

def sort_Pauli_by_symmetry(ham):
    # Separates a qiskit PauliOp object terms into 1 and 2-qubit
    # operators. Furthermore, 2-qubit operators are separated according
    # to the parity of the index first non-identity operation.
    one_qubit_terms = []
    two_qubit_terms = []
    # separating the one-qubit from two-qubit terms
    for term in ham:
        matches = find_string_pattern('X|Y|Z', str(term.paulis[0]))
        pauli_string = term.paulis[0]
        coeff = np.real(term.coeffs[0])
        str_tag = pauli_string.to_label().replace('I', '')
        if len(matches) == 2:
            two_qubit_terms.append((pauli_string, coeff, matches, str_tag))
        elif len(matches) == 1:
            one_qubit_terms.append((pauli_string, coeff, matches, str_tag))

    # sorting the two-qubit terms according to index on which they act
    two_qubit_terms = sorted(two_qubit_terms, key=lambda x: x[2])
    # separating the even from the odd two-qubit terms
    even_two_qubit_terms = list(filter(lambda x: not x[2][0]%2, two_qubit_terms))
    odd_two_qubit_terms = list(filter(lambda x: x[2][0]%2, two_qubit_terms))

    even_two_qubit_terms = [list(v) for i, v in groupby(even_two_qubit_terms, lambda x: x[2][0])]
    odd_two_qubit_terms = [list(v) for i, v in groupby(odd_two_qubit_terms, lambda x: x[2][0])]

    return one_qubit_terms, even_two_qubit_terms, odd_two_qubit_terms
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Circuit for Exponential of 1-Qubit Pauli Term}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{Circuit for Exponential of 1-Qubit Pauli Term}
def generate_circ_pattern_1qubit(circ, term, delta_t):
    coeff = 2 * term[1] * delta_t
    if term[3] == 'X':
        circ.rx(coeff, term[2])
    elif term[3] == 'Y':
        circ.ry(coeff, term[2])
    elif term[3] == 'Z':
        circ.rz(coeff, term[2])
    return circ
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Circuit for Exponential of 2-Qubit Pauli Term}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{Circuit for Exponential of 2-Qubit Pauli Term}
def generate_circ_pattern_2qubit(circ, term, delta_t):

    # wires to which to apply the operation
    wires = term[0][2]

    # angles to parameterize the circuit,
    # based on exponential argument
    if any('XX' in sublist for sublist in term):
        g_phi = ( 2 * (-1) * term[0][1] * delta_t - np.pi / 2)
    else:
        g_phi = - np.pi / 2
    if any('YY' in sublist for sublist in term):
        g_lambda = (np.pi/2 - 2 * (-1) * term[1][1] * delta_t)
    else:
        g_lambda = np.pi/2
    if any('ZZ' in sublist for sublist in term):
        g_theta = (np.pi/2 - 2 * (-1) * term[2][1] * delta_t)
    else:
        g_theta = np.pi/2

    # circuit
    circ.rz(-np.pi/2, wires[1])
    circ.cx(wires[1], wires[0])
    circ.rz(g_theta, wires[0])
    circ.ry(g_phi, wires[1])
    circ.cx(wires[0], wires[1])
    circ.ry(g_lambda, wires[1])
    circ.cx(wires[1], wires[0])
    circ.rz(np.pi/2, wires[0])
    return circ
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Manual Trotterization of Propagator}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{manual_trotterization_function}
def get_manual_Trotter(num_q, pauli_ops, timestep, n_trotter=1,
                       trotter_type='basic', reverse_bits=True):
    # sorts the Pauli strings according to qubit number they affect and symmetry
    one_q, even_two_q, odd_two_q = sort_Pauli_by_symmetry(pauli_ops)
    # scales the timestep according to the number of trotter steps
    timestep_even_two_q = timestep / n_trotter
    timestep_odd_two_q = timestep / n_trotter
    timestep_one_q = timestep / n_trotter
    # symmetric places 1/2 of one_q and odd_two_q before and after even_two_q
    if trotter_type == 'symmetric':
        timestep_odd_two_q /= 2
        timestep_one_q /= 2
    # constructs circuits for each segment of the operators
    qc_odd_two_q, qc_even_two_q, qc_one_q = QuantumCircuit(num_q), QuantumCircuit(num_q), QuantumCircuit(num_q)
    for i in even_two_q:
        qc_even_two_q = generate_circ_pattern_2qubit(qc_even_two_q, i, timestep_even_two_q)
    for i in odd_two_q:
        qc_odd_two_q = generate_circ_pattern_2qubit(qc_odd_two_q, i, timestep_odd_two_q)
    for i in one_q:
        qc_one_q = generate_circ_pattern_1qubit(qc_one_q, i, timestep_one_q)
    # assembles the circuit for Trotter decomposition of exponential
    qr = QuantumRegister(num_q)
    qc = QuantumCircuit(qr)
    if trotter_type == 'basic':
        qc = qc.compose(qc_even_two_q)
        qc = qc.compose(qc_odd_two_q)
        qc = qc.compose(qc_one_q)
    elif trotter_type == 'symmetric':
        qc = qc.compose(qc_one_q)
        qc = qc.compose(qc_odd_two_q)
        qc = qc.compose(qc_even_two_q)
        qc = qc.compose(qc_odd_two_q)
        qc = qc.compose(qc_one_q)
    # repeats the single_trotter circuit several times to match n_trotter
    for i in range(n_trotter-1):
        qc = qc.compose(qc)
    if reverse_bits:
        return qc.reverse_bits()
    else:
        return qc
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Manual Trotter Circuits}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{manual_trotter_circuits}
spin_chain_hamiltonian = get_heisenberg_hamiltonian(num_q, ham_coeffs)

spin_chain_hamiltonian = sum(spin_chain_hamiltonian)
print(get_manual_Trotter(num_q, spin_chain_hamiltonian, 0.1).draw())
print(get_manual_Trotter(num_q, spin_chain_hamiltonian, 0.1, n_trotter=2).draw())
print(get_manual_Trotter(num_q, spin_chain_hamiltonian, 0.1, trotter_type='symmetric').draw())
print(get_manual_Trotter(num_q, spin_chain_hamiltonian, 0.1, n_trotter=2, trotter_type='symmetric').draw())
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum Circuit Initialization}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{cirq_initialization}
from qiskit import QuantumCircuit
from qiskit import QuantumRegister, ClassicalRegister
from qiskit import transpile

# specifying a quantum register with specific number of qubits
qr = QuantumRegister(num_q)
# classical register used for measurement of qubits
cr = ClassicalRegister(num_q)
# quantum circuit combining quantum and classical registers
qc = QuantumCircuit(qr, cr) # instantiated here
qc.draw(style='iqp')
print(qc)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Quantum Circuit for Vacuum State Initialization}
{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{vacuum_init}

# specifying initial state by flipping qubit states
for qubit_idx in range(num_q):
    if qubit_idx == 0:
        # generate only one spin-up at first qubit
        qc.id(qubit_idx)
    else:
        # make all other spins have the spin-down state
        qc.x(qubit_idx)
qc.barrier()
qc.draw(style='iqp')
print(qc)

# checking the initial state
device = Aer.get_backend('statevector_simulator')
qc_init_state = execute(qc, backend=device).result()
qc_init_state = qc_init_state.get_statevector()
print(qc_init_state)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{State Initialization: Amplitude Encoding}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{state_init_amplitude}
qr_init = QuantumRegister(num_qubits)
qc_init = QuantumCircuit(qr_init)
qc_init.initialize('011', qr_init[:])
qc.append(qc_init)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Applying Time Evolution Operator to Circuit}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{time_evo_circuit}
# generating the time evolution operator for a specific set of
# hamiltonian parameters and timestep
time_evo_op = get_time_evolution_operator(num_qubits=num_q,
        tau=evolution_timestep,
        trotter_steps=n_trotter_steps,
        coeff=ham_coeffs)

# appending the Hamiltonian evolution to the circuit
qc.append(time_evo_op, list(range(num_q)))
qc.barrier()
qc.draw(style='iqp')
print(qc)

# Depth check
print('Depth of the circuit is', qc.depth())
# transpiled circuit to statevector simulator
qct = transpile(qc, device, optimization_level=2)
qct.decompose().decompose()
qct.draw(style='iqp')
print(qct)

print('Depth of the circuit after transpilation is '
        f'{qct.depth()}')
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Execution of Quantum Experiment}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{quan_sim}
import numpy as np
from qiskit import QuantumCircuit, QuantumRegister
from qiskit_aer import Aer

def qsolve_statevector(psin, qc):
    '''
        Performs iterative quantum state propagation using a statevector simulator. The initial state is the statevector from the prior iteration:

        | \psi _t \rangle  = e^{i*\tau*H/hbar} e^{i*\tau*H/hbar} ... | \psi _0 \rangle
        -> | \psi _t \rangle  = e^{i*\tau*H/hbar} | \psi _{t-\tau} \rangle

        
        Args:
            psin (array): Initial quantum state.
            qc (QuantumCircuit): Circuit representing the time evolution operator.

        Returns:
            psin (statevector): final statevector after execution
    '''
    # Determining number of qubits from the length of the state vector
    n=np.size(psin)
    num_qubits=int(np.log2(np.size(psin)))
    # Circuit preparation
    qreg = QuantumRegister(num_qubits)
    circ = QuantumCircuit(qreg)
    
    circ.initialize(psin,qreg)
    circ.barrier()
    # for i in range(0,100):
    circ.append(qc, qreg)
    circ.barrier()
    
    # Circuit execution
    device = Aer.get_backend('statevector_simulator')
    psin = execute(circ, backend=device).result()
    return psin.get_statevector()
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Statevector Experiment}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{statevector_quan_sim}
# Qubit basis states
zero_state = np.array([[1],[0]])
one_state = np.array([[0],[1]])

# Prepare an initial state (e.g., |011>), as follows
psin = zero_state # for the first spin
# iterates over the remaining spins, by performing
# Kronecker Product
for i in range(num_q-1):
    psin = np.kron(psin, one_state)
psin0 = psin.flatten()
print(psin0)

# time evolution operator
time_evo_op = get_time_evolution_operator(num_qubits=num_q,
        tau=evolution_timestep,
        trotter_steps=n_trotter_steps,
        coeff=ham_coeffs)
# number of steps for which to propagate
# (totaling 25 units of time)
nsteps = 250
psin_list = []
psin_list.append(psin0)
correlation_list = []

# Perform propagation by statevector re-initialization
for k in trange(nsteps):
    #print(f'Running dynamics step {k}')
    if k > 0:
        psin = qsolve_statevector(psin_list[-1], time_evo_op)
        # removes the last initial state to save memory
        psin_list.pop()
        # stores the new initial state
        psin_list.append(psin)
    correlation_list.append(np.vdot(psin_list[-1],psin0))

time = np.arange(0, evolution_timestep*(nsteps),
                 evolution_timestep)
np.save(f'{num_q}_spin_chain_time', time)
sa_observable = np.abs(correlation_list)
np.save(f'{num_q}_spin_chain_SA_obs', sa_observable)

# Plot survival amplitude
plt.plot(time, sa_observable, '-o')
plt.xlabel('Time')
plt.ylabel('Absolute Value of Survival Amplitude, '
           r'$\left|\langle \psi | \psi \rangle \right|$')
plt.xlim((min(time), max(time)))
plt.yscale('log')
plt.legend()
plt.show()
\end{codeInput}
---------------------------------------------------------
% \begin{codeInput}{python}{Execution of Quantum Experiment}{\href{https://www.google.com/}{\faIcon{external-link-alt}}}{quan_sim}
% backend =   AerSimulator(method='statevector')
% from qiskit import IBMQ

% IBMQ.save_account('TOKEN')
% IBMQ.load_account() # Load account from disk

% print(IBMQ.providers())    # List all available providers
% provider = IBMQ.get_provider(hub='ibm-q')
% print(provider.backends())

% backend = provider.backend.ibmq_belem

% qc.measure(range(num_q), range(num_q))

% qct = transpile(qc, backend, optimization_level=2)

% qct_run = execute(qct, backend, shots=1000).result()
% qct_run_counts = qct_run.get_counts()
% \end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Pauli Matrix Decomposition - Utility Function}
{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}
{\faIcon{external-link-alt}}}{pauli_decomp_utils}
def nested_kronecker_product(pauli_str):
    '''
    Computes the Kronecker Product for a given Pauli string (i.e., the pauli_str = 'ZZX' becomes the kronecker product Z Z X).

    Args:
        pauli_str (str): A string representation of Pauli matrices (e.g., 'ZZX').

    Returns:
        np.array: Resulting matrix after applying the Kronecker product.
    '''
    import numpy as np
    X = np.array([[0,1],[1,0]])
    Y = np.array([[0,complex(0,-1)],[complex(0,1),0]])
    Z = np.array([[1,0],[0,-1]])
    I = Z@Z
    
    # Define a dictionary with the four Pauli matrices:
    pms = {'I': I,'X': X,'Y': Y,'Z': Z}

    result = np.eye(1)  # Start with identity (size 1)
    for char in range(len(pauli_str)):
     result = np.kron(result,pms[pauli_str[char]])
     
    return result
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Pauli Matrix Decomposition}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{pauli_decomp}
def decompose(Ham_arr, tol=1E-5):
    '''
    Decomposes a Hamiltonian matrix into a sum of Pauli strings.

    Args:
        Ham_arr (np.array): The input Hamiltonian matrix.
        tol (float): Tolerance for small coefficients (default: 1E-5).

    Returns:
        dict: Dictionary mapping Pauli strings to their coefficients.
    '''
    import numpy as np
    import itertools

    pauli_keys = ['I','X','Y','Z'] # Keys of the dictionary

    nqb = int(np.log2(Ham_arr.shape[0])) # Determine the numnber of qubits

    # Generate all possible Pauli strings
    sigma_combinations = list(itertools.product(pauli_keys, repeat=nqb))

    result = {} # Initialize an empty dictionary to the results
    for ii in range(len(sigma_combinations)):
        pauli_str = ''.join(sigma_combinations[ii])

        # Compute the Kronecker product of the corresponding Pauli matrices
        tmp_p_matrix = nested_kronecker_product(pauli_str)

        # Compute the coefficient using the Hilbert-Schmidt inner product
        a_coeff = (1/(2**nqb)) * np.trace(tmp_p_matrix @ Ham_arr)

        # Store only non-negligible coefficients
        if abs(a_coeff) > tol:
            result[pauli_str] = a_coeff.real

    return result 
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{QFlux Simulation for Spin Chain using Hadamard Test}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/Part_I_qflux.ipynb}{\faIcon{external-link-alt}}}{package_spinchain_hadamard}
from QFlux.Closed_Systems.spin_dynamics_oo import QuantumDynamicsQuantumSimulation

num_q = 3
evolution_timestep = 0.1
n_trotter_steps = 1
hamiltonian_coefficients = [[0.75 / 2, 0.75 / 2, 0.0, 0.65]] + [
[0.5, 0.5, 0.0, 1.0] for _ in range(num_q - 1)
]
initial_state = "011"  # Specify the initial state as a binary string

qsimulation = QuantumDynamicsQuantumSimulation(
num_q,
evolution_timestep,
n_trotter_steps,
hamiltonian_coefficients,
)
qsimulation.run_simulation(state_string=initial_state, total_time=25, num_shots=100)
qsimulation.save_results('hadamard_test')
qsimulation.plot_results('hadamard_test')
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Hadamard Test Function}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{hadamard_test_function}
import numpy as np
from qiskit_aer import Aer
from qiskit import QuantumCircuit
from qiskit import QuantumRegister, ClassicalRegister

def get_hadamard_test(num_q, initial_state, control_operation,
                      control_repeats=0, imag_expectation=False):

    # Create circuit with quantum and classical registers
    qr_hadamard = QuantumRegister(num_q+1)
    cr_hadamard = ClassicalRegister(1)
    qc_hadamard = QuantumCircuit(qr_hadamard, cr_hadamard) # instantiated here

    # Initialize the computation qubits
    qc_hadamard.append(initial_state, qr_hadamard[1:]) # initial psi
    qc_hadamard.barrier()

    # Hadamard test on the ancilla qubit
    qc_hadamard.h(0)
    if imag_expectation:
        qc_hadamard.p(-np.pi/2, 0) # qc_hadamard.s(0).inverse() may be equivalent

    # iterates over the number of times the control operation should be added
    for i in range(control_repeats):
        qc_hadamard.append(control_operation, qr_hadamard[:])
    qc_hadamard.h(0)
    qc_hadamard.barrier()

    # Measuring the ancilla
    qc_hadamard.measure(0,0)

    return qc_hadamard
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Hadamard Test Post-Processing}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{hadamard_post}
def get_spin_correlation(counts):
    qubit_to_spin_map = {
        '0': 1,
        '1': -1,
    }
    total_counts = 0
    values_list = []
    for k,v in counts.items():
        values_list.append(qubit_to_spin_map[k] * v)
        total_counts += v
    # print(values_list)
    average_spin = (sum(values_list)) / total_counts
    return average_spin
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Hadamard Test Execution}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{hadamard_test_initialization}
# IMPORTANT: Use qasm_simulator to obtain meaningful statistics
simulator = Aer.get_backend('qasm_simulator')

num_q = 3
n_trotter_steps = 1
# XX YY ZZ, Z
hamiltonian_coefficients = ([[0.75/2, 0.75/2, 0.0, 0.65]]
                            + [[0.5, 0.5, 0.0, 1.0]
                                for i in range(num_q-1)])

num_shots = 100 # increase to check for convergence

evolution_timestep = 0.1
total_time = 25
time_range = np.arange(0, total_time+evolution_timestep,
                       evolution_timestep)

# time evolution operator
time_evo_op = get_time_evolution_operator(num_qubits=num_q,
        tau=evolution_timestep,
        trotter_steps=n_trotter_steps,
        coeff=hamiltonian_coefficients)

controlled_time_evo_op = time_evo_op.control()
print(controlled_time_evo_op.decompose())

init_state_list = '1' + '0' * (num_q-1)
init_circ = get_initialization(num_q, init_state_list)
init_circ.draw(style='iqp')
print(init_circ)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Hadamard Test Execution}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{hadamard_execution}
# it takes >1hr for 3 spins, with the parameters defined above
# lists t store observables
real_amp_list = []
imag_amp_list = []
for idx,time in enumerate(time_range):
    print(f'Running dynamics step {idx}')
    # Real component ------------------------------
    qc_had_real = get_hadamard_test(num_q, init_circ,
                                    controlled_time_evo_op,
                                    control_repeats=idx,
                                    imag_expectation=False)
    had_real_counts = get_circuit_execution_counts(
            qc_had_real, simulator, n_shots=num_shots)
    real_amplitude = get_spin_correlation(had_real_counts)
    real_amp_list.append(real_amplitude)

    # Imag component ------------------------------
    qc_had_imag = get_hadamard_test(num_q, init_circ,
                                    controlled_time_evo_op,
                                    control_repeats=idx,
                                    imag_expectation=True)
    had_imag_counts = get_circuit_execution_counts(
            qc_had_imag, simulator, n_shots=num_shots)
    imag_amplitude = get_spin_correlation(had_imag_counts)
    imag_amp_list.append(imag_amplitude)
    print(f'Finished step {idx}, where '
          f'Re = {real_amplitude:.3f} '
          f'Im = {imag_amplitude:.3f}')

    real_amp_array = np.array(real_amp_list)
    imag_amp_array = np.array(imag_amp_list)

np_abs_correlation_with_hadamard_test = np.abs(real_amp_array + 1j*imag_amp_array)

# plotting the data
plt.plot(time_range, np_abs_correlation_with_hadamard_test,
         '.', label='Hadamard Test')

sa_statevector = np.load(f'data/{num_q}_spin_chain_SA_obs.npy')
time = np.load(f'{num_q}_spin_chain_time.npy')
plt.plot(time, sa_statevector, '-', label='Statevector')

plt.xlabel('Time')
plt.ylabel('Absolute Value of Survival Amplitude')
plt.legend()
plt.show()
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Variational Quantum Eigensolver
}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I_appendixA.ipynb}{\faIcon{external-link-alt}}}{vqe_algorithm}
# -- Install Qiskit and Supporting Packages --
!pip install -qqq qiskit
!pip install -qqq qiskit-aer         # provides simulators

# -- Imports --
# - EfficientSU2: A parameterized quantum circuit (ansatz) often used in VQE.
# - SparsePauliOp: Efficient representation of Hamiltonians in terms of Pauli strings.
# - StatevectorEstimator: Estimates expectation values (ideal, noiseless backend).
import numpy as np
from scipy.optimize import minimize
from qiskit.circuit.library import EfficientSU2
from qiskit.primitives import StatevectorEstimator
from qiskit.quantum_info import SparsePauliOp

# --- Define the Hamiltonian ---
# H = 0.5 * Z_0 + 0.5 * Z_1 + 0.2 * X_0 * X_1
hamiltonian = SparsePauliOp.from_list([("ZI", 0.5), ("IZ", 0.5), ("XX", 0.2)])

# --- Initialize the Estimator Primitive ---
# StatevectorEstimator: Ideal, noiseless estimator using statevectors (no sampling noise). Computes expectation value exactly.
estimator = StatevectorEstimator()

# --- Define the Ansatz ---
# Use EfficientSU2 as a general-purpose parameterized ansatz. EfficientSU2 is expressive and hardware-efficient, using layers of single-qubit rotations and entangling gates.
ansatz = EfficientSU2(num_qubits=hamiltonian.num_qubits)

# --- Define the Energy Evaluation Function ---
# Given parameters params, assigns them to the ansatz circuit and evaluates the expectation value of the Hamiltonian. Returns the energy to the optimizer. Includes basic exception handling for robustness.
def energy(params, ansatz, hamiltonian, estimator):
    """Evaluate energy for given ansatz parameters."""
    try:
        result = estimator.run([(ansatz, hamiltonian, params)]).result()
        energy_estimate = result[0].data.evs
        print(f"Energy: {energy_estimate}")
        return energy_estimate
    except Exception as e:
        print(f"Estimator failed: {e}")
        return np.inf

# --- Initialize Parameters ---
# Random initialization of ansatz parameters in the full 0–2\pi range. Good starting point for global exploration of energy landscape.
initial_params = np.random.uniform(0, 2 * np.pi, size=ansatz.num_parameters)

# --- Classical Optimization ---
# Minimize energy using COBYLA, a derivative-free classical optimizer. Minimizes the energy function over the variational parameters. Hybrid quantum-classical loop: quantum subroutine evaluates energy, classical subroutine updates parameters.
opt_result = minimize(
    energy,
    initial_params,
    args=(ansatz, hamiltonian, estimator),
    method="COBYLA",
    options={"maxiter": 200, "disp": True}
)

# --- Output Results ---
# Outputs the final optimized parameters and estimated ground state energy.
final_params = opt_result.x
final_energy = energy(final_params, ansatz, hamiltonian, estimator)
     
print(f"\nFinal Optimized Energy: {final_energy}")
print(f"Optimized Parameters: {final_params}")
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Variation Quantum Real Time Evolution}{\href{https://colab.research.google.com/githubbatistagroup/qflux/blob/master/demos/tutorial/Part_I_appendixA.ipynb}{\faIcon{external-link-alt}}}{VQ_time_evolution}
# --- Imports and Setups ---
'''
Modules:
- VarQRTE: Variational algorithm to simulate real-time dynamics.
- ExcitationPreserving: A standard ansatz that preserves the number of excitations.
- RealMcLachlanPrinciple: Defines the variational principle used for time evolution.
- StatevectorEstimator: Estimates expectation values for pure quantum states.
- SparsePauliOp: Efficient representation of Hamiltonians.
'''
import numpy as np
from qiskit_algorithms import VarQRTE, TimeEvolutionProblem
from qiskit.circuit.library import ExcitationPreserving
from qiskit_algorithms.time_evolvers.variational import RealMcLachlanPrinciple
from qiskit import QuantumCircuit
from qiskit.primitives import StatevectorEstimator
from qiskit.quantum_info import SparsePauliOp

# --- Define the Evolution Settings ---
'''Sets up the evolution method and estimator.
    Simulates real-time evolution over 5.0 units of time in steps of 0.2.'''
var_principle = RealMcLachlanPrinciple()
estimator = StatevectorEstimator()
total_time = 5.0                    # Total time for evolution
evolution_timestep = 0.2         # Time step size

# --- Define the Hamiltonian ---
'''Two-qubit Hamiltonian with local Z fields on each qubit and XX coupling'''
hamiltonian = SparsePauliOp.from_list([("ZI", 0.5), ("IZ", 0.5), ("XX", 0.2)])

# --- Define Initial State ---
'''Constructs a circuit that prepares initial state |10⟩ by applying an X gate to qubit 0.'''
def init_circ():
    qc = QuantumCircuit(2, 0)
    qc.x(0)  # initial state is |10>
    return qc

# --- Define the Ansatz Circuit ---
'''Uses ExcitationPreserving ansatz, which is suitable for problems that conserve particle number (like quantum chemistry).
    Composes this ansatz on top of the initial state |10⟩, meaning this ansatz evolves that state.
    Starts with all variational parameters initialized to zero.'''
params = [np.array([0.0 for i in range(5)])]
ansatz = ExcitationPreserving(num_qubits=2, entanglement="linear", reps=1)
ansatz = init_circ().compose(ansatz)

# --- Time Evolution ---
'''Define the problem and pass it to the VarQRTE solver.
    Evolves the variational parameters step-by-step in time.
    At the end, params contains the final variational parameters representing the evolved state.'''
evolution_problem = TimeEvolutionProblem(hamiltonian, total_time)
qrte = VarQRTE(ansatz, params[0][:], variational_principle=var_principle,
               estimator=estimator,
               num_timesteps=int(total_time / evolution_timestep),
)
evolved_params = qrte.evolve(evolution_problem).parameter_values

# --- Reconstruct the Final State ---
'''Substitutes the final optimized parameters into the ansatz circuit to get the quantum circuit that prepares the final evolved state.
    Prints the resulting quantum circuit.'''
evolved_circ = ansatz.assign_parameters(evolved_params[-1])
print(evolved_circ)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Python Functions for the State Preparation algorithm}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{state_prep_functions}
import numpy as np
from scipy.linalg import block_diag

def compute_bloch_angles(c0, c1):
    """
    Computes the Bloch sphere angles (thetha, phi) for a given qubit state represented as a superposition, c0*|0> + c1*|1>.
    """
    norm = np.sqrt(np.abs(c0)**2 + np.abs(c1)**2)
    alpha = c0/norm
    beta  = c1/norm
    theta = 2 * np.arccos(np.abs(alpha))
    phi = np.angle(beta*np.conjugate(alpha)/np.abs(beta)/np.abs(alpha))
    return theta, phi

def rz_matrix(phi):
    """
    Returns the R_z(phi) rotation matrix which represents a rotation around the Z-axis by an angle phi.
    """
    return np.array([
        [np.exp(-1j*phi/2), 0],
        [0, np.exp(1j*phi/2)]
    ])

def ry_matrix(theta):
    """
    Returns the R_y(theta) rotation matrix, representing a rotation around the Y-axis by angle theta.
    """
    return np.array([
        [np.cos(theta/2), -np.sin(theta / 2)],
        [np.sin(theta/2), np.cos(theta / 2)]
    ])

def is_power_of_two(n):
    """
    Checks whether the input integer `n` is a power of two.
    """
    return n > 0 and (n & (n - 1)) == 0
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Python Function for Quantum Multiplexor}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{quantum_multiplexor_functions_1}
def multiplexor_matrix(n, vector, bit=0):
    """
    Constructs the multiplexor matrix R^(n), which applies controlled rotations based on n-1 control qubits.

    Parameters:
    - n (int): Number of qubits.
    - vector (numpy.ndarray): A numpy array with 2**n components       representing the quantum state.
    - bit (int, optional): Value (0 or 1) of the desired unentangled   bit. 
      Defaults to 0.

    Returns:
    - numpy.ndarray: The multiplexor matrix implementing the controlled transformation.
    """
    # Ensure bit is either 0 or 1
    bit = int(bool(bit))

    multiplexor = None  # Placeholder for the block diagonal matrix
    
    for i in np.arange(0,2**n,2):
        c0 = vector[i]
        c1 = vector[i+1]
        theta, phi = compute_bloch_angles(c0, c1)
        r_z = rz_matrix(-phi)
        r_y = ry_matrix(bit*np.pi-theta)
        r = r_y @ r_z
        if i==0:
            multiplexor = block_diag(r)
        else:
            multiplexor = block_diag(multiplexor,r)
    return multiplexor
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Python Functions for Quantum Multiplexors}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{quantum_multiplexor_functions_2}
def rotate_to_vacuum_matrix(vector_input):
    """
    Computes the transformation matrix that maps a given quantum state 
    (specified by `vector_input`) to the vacuum state |00...0>.

    Parameters:
    - vector_input (numpy.ndarray): A 1D numpy array representing the quantum state.
      The size of `vector_input` must be a power of 2.

    Returns:
    - numpy.ndarray: The transformation matrix that disentangles the input state.
    """
    ndim = vector_input.size
    if not is_power_of_two(ndim):
        print("Dimension of the input state vector (",ndim,") should be a power of 2.")
        return
    else:
        n = int(np.log2(vector_input.size))

    total_matrix = np.eye(ndim)
    vector_k = vector_input.copy()
    
    for k in np.arange(n,0,-1):

        if k==n:
            vector_pruned = vector_input.copy()
        else:
            vector_pruned = vector_new[::2]
            
        # Compute the multiplexor matrix
        multiplexor = multiplexor_matrix(k,vector_pruned)

        # Construct a padded multiplexor matrix
        if k==n:
            multiplexor_padded = multiplexor
        else:
            multiplexor_padded = np.kron(multiplexor,np.eye(2*(n-k)))

        # Update the transformation matrix
        total_matrix = np.matmul(multiplexor_padded,total_matrix)

        # Update the intermediate state vector
        vector_k = np.matmul(multiplexor_padded,vector_k)#multiplexor_padded.dot(vector_k)
        #print("\nPadded Multiplexor*Vector:\n",vector_k.reshape(-1,1))
        vector_new = multiplexor.dot(vector_pruned) # Compute new pruned vector

    # Normalize the transformation matrix to remove the global phase
    phase_factor = vector_k[0]
    total_matrix = np.conjugate(phase_factor)*total_matrix
    return total_matrix
\end{codeInput}
---------------------------------------------------------
\begin{codeInput}{python}{Decomposition with Givens Rotations}{\href{https://colab.research.google.com/github/batistagroup/qflux/blob/master/demos/tutorial/Part_I.ipynb}{\faIcon{external-link-alt}}}{QR-decomposition}
!pip install graycode
import numpy as np
import graycode

def GivensRotation(i, j, k, A):
    """
    Constructs a Givens rotation matrix that zeros out A[j,i] by rotating rows j and k
    Indices i, j, k are zero-based (Python convention)
    Parameters:
    i (int): Column index (0-based)
    j (int): Row index to be zeroed (element A[j,i])
    k (int): Row index to rotate with (element A[k,i])
    A (ndarray): The matrix A (NumPy array)

    Returns:
    The Givens rotation matrix (ndarray)
    """
    ndim = A.shape[0]
    iGjk = np.identity(ndim, dtype=A.dtype)
    aji = A[j, i]
    if aji == 0:
        return iGjk
    aki = A[k, i]
    norm = np.sqrt(abs(aji)**2 + abs(aki)**2)
    iGjk[k, k] = np.conj(aki) / norm
    iGjk[j, j] = aki / norm
    iGjk[k, j] = np.conj(aji) / norm
    iGjk[j, k] = -aji / norm
    return iGjk

def Gmatrix(U, gray=False, print_sequence=False):
    """
    Computes a transformation matrix R based on Givens rotations applied to U.
    Parameters:
    U (ndarray): A square NumPy array representing the matrix U.
    Returns:
    ndarray: The transformation matrix R@Uphase.
    """
    ndim = U.shape[0]
    n = int(np.log2(ndim))
    R = np.identity(ndim, dtype=U.dtype)
    
    # Compute the phase adjustment to make the determinant of Uphase @ U real
    detU = np.linalg.det(U)
    argDetU = np.angle(detU)
    phase_factor = np.exp(-1j * argDetU / ndim)
    Uphase = phase_factor * np.identity(ndim, dtype=U.dtype)
    
    # Adjust U with the phase factor
    Um = Uphase @ U

    # Perform Givens rotations to zero out below-diagonal elements
    if print_sequence:
        print("U = D", end=' ')
    for i in range(ndim - 1):  # i from 0 to ndim-2
        for j in range(ndim - 1, i, -1):  # j from ndim-1 down to i+1
            if gray:
                ii = graycode.gen_gray_codes(n)[i]
                jj = graycode.gen_gray_codes(n)[j]
                kk = graycode.gen_gray_codes(n)[j-1]
            else:
                ii = i
                jj = j
                kk = j-1
            if print_sequence:
                print(f"G^+[{ii+1},{jj+1},{kk+1}]", end=' ')
            RG = GivensRotation(ii, jj, kk, Um)
            R = RG @ R
            Um = RG @ Um

    if print_sequence:
        print()
        print(f"D = {np.conjugate(phase_factor)}*I")

    return R @ Uphase
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Walsh Decomposition of Diagonal Unitaries}{\href{https://colab.research.google.com/githubbatistagroup/qflux/blob/master/demos/tutorial/Part_I_appendixA.ipynb}{\faIcon{external-link-alt}}}{walsh_decomposition}
import numpy as np
from qiskit import QuantumRegister, QuantumCircuit

# Pauli matrices for quantum operations
I = np.eye(2)  # Identity gate
Z = np.array([[1, 0], [0, -1]])  # Z gate
X = np.array([[0, 1], [1, 0]])  # X gate

# === Helper Functions for Binary Representation ===

def to_binary(num, n_bits):
    """Convert integer to binary array (little-endian).
    Example: 3 with 3 bits -> [1, 1, 0]"""
    return np.array([int(bit) for bit in bin(num)[2:].zfill(n_bits)], dtype=int)

def to_decimal(binary_array):
    """Convert binary array back to integer.
    Example: [1, 1, 0] -> 3"""
    return sum(bit * (2**i) for i, bit in enumerate(binary_array))

def gray_code(num, n_bits):
    """Generate Gray code from integer.
    Uses: num XOR (num >> 1)
    Example: 3 with 3 bits, to_binary(3, 3) → [0, 1, 1]] -> Gray code: [0, 1, 0]"""
    binary = to_binary(num, n_bits)
    shifted = to_binary(num >> 1, n_bits)
    return (binary + shifted) % 2  # Bitwise XOR simplified

def highest_one_bit(binary_array):
    """Find index of highest 1 in binary array.
    Example: [0, 1, 1, 0] -> 2"""
    return max((i for i, bit in enumerate(binary_array) if bit == 1), default=-1)

# === Walsh Transform Functions ===

def walsh_coefficients(state_vector, n_bits):
    """Calculate Walsh coefficients from state vector.
    Input: array of length 2^n_bits (quantum state amplitudes)
    Output: Walsh coefficients array"""
    n_states = 2**n_bits
    if len(state_vector) != n_states:
        raise ValueError(f"State vector length must be {n_states}")
    
    coefficients = np.zeros(n_states)
    for j in range(n_states):
        j_binary = to_binary(j, n_bits)
        for k in range(n_states):
            k_binary = to_binary(k, n_bits)
            sign = (-1) ** np.dot(j_binary, k_binary)
            coefficients[j] += state_vector[k] * sign
        coefficients[j] /= n_states
    return coefficients

# === Quantum Circuit Construction ===

def walsh_circuit_list(coefficients, n_qubits, epsilon=1e-6):
    """Generate list of gates for Walsh operator diagonal unitary.
    Format: [('C', control, target), ('R', qubit, angle)]"""
    if len(coefficients) != 2**n_qubits:
        raise ValueError(f"Coefficients length must be {2**n_qubits}")
    
    gates = []
    for j in range(1, 2**n_qubits):
        gray_binary = gray_code(j, n_qubits)
        j_gray = to_decimal(gray_binary)
        
        if abs(coefficients[j_gray]) < epsilon:
            continue
            
        max_idx = highest_one_bit(gray_binary)
        
        # Forward CNOTs
        for i in range(max_idx):
            if gray_binary[i]:
                gates.append(('C', i, max_idx))
                
        # Rz rotation
        gates.append(('R', max_idx, -2 * coefficients[j_gray]))
        
        # Reverse CNOTs
        for i in range(max_idx - 1, -1, -1):
            if gray_binary[i]:
                gates.append(('C', i, max_idx))
    
    return gates

def build_circuit(gate_list, n_qubits):
    """Convert gate list to Qiskit quantum circuit."""
    qr = QuantumRegister(n_qubits)
    qc = QuantumCircuit(qr)
    
    for gate in gate_list:
        if gate[0] == 'C':
            qc.cx(gate[1], gate[2])  # CNOT gate
        elif gate[0] == 'R':
            qc.rz(gate[2], gate[1])  # Rz rotation
        else:
            raise ValueError(f"Unknown gate type: {gate[0]}")
    return qc

# === Circuit Optimization ===

def optimize_circuit(gate_list):
    """Basic optimization: remove adjacent identical CNOTs."""
    if not gate_list:
        return gate_list
        
    optimized = [gate_list[0]]
    for current in gate_list[1:]:
        if (current[0] == 'C' and 
            optimized[-1] == current):  # Adjacent identical CNOTs cancel
            optimized.pop()
        else:
            optimized.append(current)
    return optimized
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Test Code: Walsh Decomposition of Diagonal Unitary}{\href{https://colab.research.google.com/githubbatistagroup/qflux/blob/master/demos/tutorial/Part_I_appendixA.ipynb}{\faIcon{external-link-alt}}}{test_walsh_decomposition}
# Test with n_qubits

# Example with random diagonal matrix elements
n_qubits = 3 # Number of qubits
state = np.random.rand(2**n_qubits) # Random function values

# Calculate Walsh coefficients
coeffs = walsh_coefficients(state, n_qubits)
print("Walsh coefficients:", coeffs)

# Generate and optimize circuit
gates = walsh_circuit_list(coeffs, n_qubits)
gates_opt = optimize_circuit(gates)
circuit = build_circuit(gates_opt, n_qubits)

print("\nOptimized circuit:")
print(circuit)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Noisy Simulations and Error Mitigation}{\href{https://colab.research.google.com/githubbatistagroup/qflux/blob/master/demos/tutorial/Part_I_appendixA.ipynb}{\faIcon{external-link-alt}}}{bellerr}
!pip install -qqq qiskit
!pip install -qqq qiskit-ibm-runtime
!pip install -qqq qiskit-aer

from qiskit import QuantumCircuit, transpile
from qiskit.visualization import plot_histogram
from qiskit_ibm_runtime.fake_provider import FakeManilaV2
from qiskit_aer import Aer

import numpy as np
from itertools import product

def create_calibration_matrix():
    """Builds a 4x4 measurement error calibration matrix for 2 qubits."""

    cal_circuits = []
    basis_states = [''.join(bits) for bits in product('01', repeat=2)]

    for state in basis_states:
        qc = QuantumCircuit(2, 2)
        for i, bit in enumerate(reversed(state)):  # Little endian
            if bit == '1':
                qc.x(i)
        qc.measure([0, 1], [0, 1])
        cal_circuits.append(qc)

    shots = 100000
    sim = FakeManilaV2()
    results = sim.run(transpile(cal_circuits, sim),shots=shots).result()
    counts = results.get_counts()

    M = np.zeros((4, 4))  # 4 prepared states x 4 measured states
    label_to_index = {label: idx for idx, label in enumerate(basis_states)}

    for i, state in enumerate(basis_states):
        counts = results.get_counts(cal_circuits[i])
        total = sum(counts.values())
        for bitstring, count in counts.items():
            # Ensure all bitstrings are 2 bits
            padded = bitstring.zfill(2)
            j = label_to_index[padded]
            M[j, i] = count / total
    return M, basis_states

def run_noisy_circuit():
    """Runs a 2-qubit Bell circuit that ideally outputs |00⟩ and |11⟩."""
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure([0, 1], [0, 1])

    sim = FakeManilaV2()
    shots = 10000
    result = sim.run(transpile(qc, sim),shots=shots).result()
    counts = result.get_counts()

    # Convert counts to probability vector
    p_meas = np.zeros(4)
    index_map = {'00': 0, '01': 1, '10': 2, '11': 3}
    for bitstring, count in counts.items():
        padded = bitstring.zfill(2)
        idx = index_map[padded]
        p_meas[idx] = count / shots

    return p_meas, counts

def apply_correction(M, p_meas):
    """Applies inverse of calibration matrix to correct measured probabilities."""
    M_inv = np.linalg.pinv(M)  # use pseudo-inverse for stability
    p_corrected = np.dot(M_inv, p_meas)
    p_corrected = np.clip(p_corrected, 0, 1)
    return p_corrected / np.sum(p_corrected)
\end{codeInput}
---------------------------------------------------------
\noindent\begin{codeInput}{python}{Test Code for Noisy Simulation and Error Mitigation}{\href{https://colab.research.google.com/githubbatistagroup/qflux/blob/master/demos/tutorial/Part_I_appendixA.ipynb}{\faIcon{external-link-alt}}}{testerrm}
M, state_labels = create_calibration_matrix()
p_meas, raw_counts = run_noisy_circuit()
p_corrected = apply_correction(M, p_meas)

# Display
print("Calibration matrix M:")
print(np.round(M, 4))
print("\nMeasured probabilities:")
print(dict(zip(state_labels, np.round(p_meas, 4))))
print("\nCorrected probabilities:")
print(dict(zip(state_labels, np.round(p_corrected, 4))))

"""
    Plots a comparison between raw and corrected measurement probabilities.

    Args:
        state_labels (List[str]): List of bitstrings for basis states (e.g., ['00', '01', '10', '11']).
        p_meas (np.ndarray): Raw measured probabilities.
        p_corrected (np.ndarray): Corrected probabilities after error mitigation.
    """
raw_dict = dict(zip(state_labels, p_meas))
corrected_dict = dict(zip(state_labels, p_corrected))

plot_histogram(
    [raw_dict, corrected_dict],
    legend=['Raw', 'Corrected'],
    title='Measurement Error Mitigation',
    bar_labels=False
    )
\end{codeInput}
---------------------------------------------------------
